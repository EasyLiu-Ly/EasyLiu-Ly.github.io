<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    

    
    <title>Handler消息机制深入解析 | EasyLiu</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="Android">
    
    <meta name="description" content="Handler消息机制深入解析">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="Handler消息机制深入解析">
<meta property="og:url" content="http://easyliu.com/2021/03/06/android_source_analysis/handler/index.html">
<meta property="og:site_name" content="EasyLiu">
<meta property="og:description" content="Handler消息机制深入解析">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-02-17T07:17:42.486Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Handler消息机制深入解析">
<meta name="twitter:description" content="Handler消息机制深入解析">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/3.5.0/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">welcome to easyliu&#39;s blog</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Android性能优化/">Android性能优化</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Android架构学习/">Android架构学习</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Android源码解析/">Android源码解析</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Android疑难杂症/">Android疑难杂症</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Android自定义控件/">Android自定义控件</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Gradle相关/">Gradle相关</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/ios开发/">ios开发</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/从0打造音视频直播系统/">从0打造音视频直播系统</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/代码规范/">代码规范</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/刷题/">刷题</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/单元测试/">单元测试</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/周末活动/">周末活动</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/学习计划/">学习计划</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/开发工具/">开发工具</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/旅游/">旅游</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">关于</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/Android源码解析/">Android源码解析</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-android_source_analysis/handler" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        Handler消息机制深入解析
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
      <i class="fa fa-calendar"></i>
      <a href="/2021/03/06/android_source_analysis/handler/" class="article-date">
         <time datetime="2021-03-06T15:32:32.000Z" itemprop="datePublished">2021-03-06</time>
      </a>
    </div>


                

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Android/">Android</a>
    </div>

                
   <span id="/2021/03/06/android_source_analysis/handler/" class="leancloud-visitors" data-flag-title="Handler消息机制深入解析">
   <i class="fa fa-eye"></i>
   <span class="post-meta-item-text">阅读次数: </span>
   <i class="leancloud-visitors-count">0</i>
   </span>


                
   <div class="article-counter">
      <i class="fa fa-file-word-o"></i>
      <span class="post-count-item-text">本文字数: </span>
      <span class="post-count">5.8k</span>
      <i class="fa fa-clock-o"></i>
      <span class="post-time-item-text">阅读时长: </span>
      <span class="post-count">26 分钟 </span>
   </div>


            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家在日常开发中肯定用过Handler，常用的API主要有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post(<span class="meta">@NonNull</span> Runnable r) </span><br><span class="line">postDelayed(<span class="meta">@NonNull</span> Runnable r, <span class="keyword">long</span> delayMillis)</span><br><span class="line">postAtFrontOfQueue(<span class="meta">@NonNull</span> Runnable r) </span><br><span class="line">..........</span><br></pre></td></tr></table></figure>

<p>在主线程中可以通过这些API可以进行延时操作，在子线程中可以通过这些API可以进行线程切换，把消息发送到Handler对应的线程当中去执行</p>
<p>关于Handler底层实现原理的话，可能大家都能脱口而出，说出以下内容：</p>
<blockquote>
<p>1、每个Handler里面关联一个Looper,每个Looper里面又关联一个MessageQueue<br>2、当调用Handler的一些API比如post，就会往Looper.MessageQueue里面放入一个Message<br>3、Looper.loop()是一个死循环，循环的从MessageQueue里面取出Message执行<br>4、Looper里面通过ThreadLocal来保证每个Thread里面都有一个Looper副本<br>5、当MessageQueue空闲的时候，就会执行IdleHandler</p>
</blockquote>
<p>当你回答出以上问题的时候，可能面试官并不满足此，其接着会问如下问题：</p>
<blockquote>
<p>1、主线程的Looper.loop()方法是啥时候执行的？<br>2、Looper、MessageQueue以及Message三者交互的底层实现原理<br>3、Looper死循环为什么不会导致应用卡死？<br>4、ANR产生的原因<br>5、同步屏障SyncBarrier<br>6、onDraw里面调用invalidate为啥会导致IdleHandler得不到执行？<br>7、ViewAnimation循环执行为啥会导致IdleHandler得不到执行,而使用属性动画就没有这个问题？</p>
</blockquote>
<p>针对以上问题，我们通过源码的方式来一一进行解答，源码基于API30版本</p>
<h2 id="主线程的Looper-loop-方法是啥时候执行的？"><a href="#主线程的Looper-loop-方法是啥时候执行的？" class="headerlink" title="主线程的Looper.loop()方法是啥时候执行的？"></a>主线程的Looper.loop()方法是啥时候执行的？</h2><p>我们都知道，每一个应用都存在于自己的虚拟机中，那么每一个应用都有自己的一个main函数，这个main函数就是ActivityThread.java的main()函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ...........</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ...........</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出在main函数里面会通过Looper.prepareMainLooper()创建主线程的Looper，然后开始通过Looper.loop方法开启主线程的Looper循环。开启循环之后，主线程所有的代码都是运行在这个Looper里面的。</p>
<p>接下来进一步剖析整个Handler消息机制底层具体的一个执行过程</p>
<h2 id="Looper、MessageQueue以及Message三者交互的底层实现原理"><a href="#Looper、MessageQueue以及Message三者交互的底层实现原理" class="headerlink" title="Looper、MessageQueue以及Message三者交互的底层实现原理"></a>Looper、MessageQueue以及Message三者交互的底层实现原理</h2><p>我们以Handler.post方法为入口进行讲解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(@NonNull Runnable r)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(@NonNull MessageQueue queue, @NonNull Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出post方法最终会走到MessageQueue.enqueueMessage(msg, uptimeMillis)方法，深入看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析这段代码之前，需要明确几个点：</p>
<blockquote>
<p>1、Message结构体是一个链表结构，里面会有一个next指针指向下一个Message节点，每个Message在链表中的先后顺序是根据Message.when来决定的，每次来一个Message的时候会根据其when把Message插入到链表中合适的位置<br>2、MessageQueue里面有一个字段mBlocked,代表当前队列是否处于阻塞状态</p>
</blockquote>
<p>从上面的代码可以看出，enqueueMessage方法主要分为这几步：</p>
<blockquote>
<p>1、MessageQueue里面有一个mMessages变量，代表是链表的head<br>2、这个needWake代表是否需要进行唤醒，关于这个字段的含义，待会会结合Looper.loop方法一起讲解<br>3、如果现在链表是空的，或者传入的Message需要插入到队首（根据when来进行判断），那么就把链表的head设置为传入的Message，同时如果现在MessageQueue是阻塞状态，那么就需要立即唤醒<br>4、当不满足第3步的条件，就会把Message插入到链表合适的位置。如果现在是阻塞的情况下，队首Msg是一个同步屏障（通过p.target == null判断出是一个同步屏障）并且Msg是一个异步消息，才需要立即唤醒，相当于如果有同步屏障，那么其后续的消息都没法执行，只允许异步消息执行。<br>关于同步屏障以及异步消息的使用场景，稍后会专门讲解，现在只需要知道有这个概念就行</p>
</blockquote>
<p>把Message放入队列里面之后，那肯定是有一个地方会把Message从队列里面取出来执行，类似于生产者消费者模式，这个取消息的逻辑就是Looper.loop()，这个方法里面会循环从队列里面取出Message来执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    ..................</span><br><span class="line">    me.mInLoop = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    .................. </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ..............</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，这个loop方法里面有一个for循环，里面会调用MessageQueue的next方法，这个方法是有可能阻塞的,来看下这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">       <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">       <span class="comment">// which is not supported.</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">       <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//只有最开始设置为-1</span></span><br><span class="line">       <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">       <span class="comment">//下一次poll超时时间</span></span><br><span class="line">       <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//这里也是一个for循环</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">               Binder.flushPendingCommands();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//会阻塞调用native层的nativePollOnce方法来获取消息队列中的消息</span></span><br><span class="line">           <span class="comment">//这个nextPollTimeoutMillis有以下3种取值：</span></span><br><span class="line">           <span class="comment">//0，立即返回，没有阻塞</span></span><br><span class="line">           <span class="comment">//负数，一直阻塞，直到事件发生</span></span><br><span class="line">           <span class="comment">//正数，表示最多等待多久时间</span></span><br><span class="line">           <span class="comment">//因此next方法最开始nextPollTimeoutMillis设置为0，马上返回，没有阻塞</span></span><br><span class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">               Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">               Message msg = mMessages;</span><br><span class="line">               <span class="comment">//这个msg.target==null代表是一个同步屏障，找到下一个可异步消息</span></span><br><span class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       prevMsg = msg;</span><br><span class="line">                       msg = msg.next;</span><br><span class="line">                   &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                       <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                       <span class="comment">//下一个消息的时间还没到，那么就计算出一个新的nextPollTimeoutMillis</span></span><br><span class="line">                       nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// Got a message.</span></span><br><span class="line">                       <span class="comment">//获得一个msg，把这个msg从队列里面移除掉，同时返回msg，打破这个for循环</span></span><br><span class="line">                       mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           prevMsg.next = msg.next;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           mMessages = msg.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.next = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                       msg.markInUse();</span><br><span class="line">                       <span class="keyword">return</span> msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// No more messages.</span></span><br><span class="line">                   <span class="comment">//没有找到消息，设置为-1,下次轮询就一直阻塞</span></span><br><span class="line">                   nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">               <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                   dispose();</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">               <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">               <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">               <span class="comment">//由于这个pendingIdleHandlerCount只有最开始设置为-1，代表在当前for循环里面idleHandler只会执行一次</span></span><br><span class="line">               <span class="comment">//如果队列里面没有消息或者消息还没有到执行的时间，那么就考虑idleHandler</span></span><br><span class="line">               <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                       &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                   pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//如果没有idleHandler可执行，就阻塞，开始执行下一个轮询</span></span><br><span class="line">               <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                   mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//最多执行4个idleHandler</span></span><br><span class="line">               <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Run the idle handlers.</span></span><br><span class="line">           <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">               <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">               mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   keep = idler.queueIdle();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//这个返回值代表是否需要一直保存这个idleHandler，如果不需要保存就从列表里面移除掉</span></span><br><span class="line">               <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                       mIdleHandlers.remove(idler);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">           <span class="comment">//设置0，下一个循环就不会再次执行了，只执行一次</span></span><br><span class="line">           pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">           <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">           <span class="comment">//当执行完idleHandler之后，队列里面可能已经有新消息了，那么就设置nextPollTimeoutMillis为0代表立即</span></span><br><span class="line">           <span class="comment">//获取消息，无需等待</span></span><br><span class="line">           nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面的注释比较详细，我们大体来看一下：<br>next方法里面也是一个for循环，在这个循环的开头会调用一个native方法nativePollOnce，这个方法可能会阻塞，根据传入的nextPollTimeoutMillis值，有3种执行情况：<br>1、如果传入0，那么就立即返回没有阻塞<br>2、如果传入负数，一直阻塞，直到有事件发生，这个有事件发生其实就我们前面在enqueue方法里面看到的nativeWake方法，当调用这个nativeWake方法的话，这个nativePollOnce就会返回继续往下面执行<br>3、如果传入正数，表示最多等待多久时间，如果超过这个时间，这个nativePollOnce就会返回继续往下面执行</p>
<p>由于next方法刚开始传入的nextPollTimeoutMillis为0，因此第一次循环nativePollOnce方法就会马上返回，接着往下面走，如果获取到了msg就会返回（如果遇到了同步屏障，依然只能返回异步msg），打破这个for循环，回到looper的循环里面去。如果没有获取到msg,就会重新计算这个nextPollTimeoutMillis。然后接着往下走的话，就是执行IdleHandler的相关逻辑了，如果队列里面没有消息或者消息还没有到执行的时间，那么就考虑idleHandler，idleHandler执行完成之后继续从头开始下一轮循环</p>
<p>以上就是Handler消息机制的底层实现原理，涉及到Looper、MessageQueue以及Message三者之间的一个交互关系</p>
<h2 id="Looper死循环为什么不会导致应用卡死？"><a href="#Looper死循环为什么不会导致应用卡死？" class="headerlink" title="Looper死循环为什么不会导致应用卡死？"></a>Looper死循环为什么不会导致应用卡死？</h2><p>上面说了，消息能够源源不断的执行，靠的时候Looper.loop()以及MessageQueue.next()方法里面的for循环来保证的，之所以使用循环是为了保证当前线程一直存活不退出，这个其实可以理解，毕竟主线程肯定不能说运行一段时间就自动退出的，那么主线程的死循环一直运行会不会特别消耗CPU资源导致应用卡死呢？</p>
<p>注意到，通过前面的分析，我们发现这里涉及到两个native方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>; <span class="comment">/*non-static for callbacks*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个方法其实涉及到Linux pipe/epoll机制，在主线程的MessageQueue没有消息时，便阻塞在nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，然后通过调用nativeWake()方法，通过往pipe管道写端写入数据来唤醒主线程工作。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
<h2 id="ANR产生的原因"><a href="#ANR产生的原因" class="headerlink" title="ANR产生的原因"></a>ANR产生的原因</h2><p>因此，真正卡死主线程操作的是在回调方法onCreate或者TouchEvent处理等操作时间过长，5s超时导致ANR，Looper.loop()本身不会导致应用卡死</p>
<h2 id="同步屏障SyncBarrier"><a href="#同步屏障SyncBarrier" class="headerlink" title="同步屏障SyncBarrier"></a>同步屏障SyncBarrier</h2><p>在前面讲解MessageQueue.next()方法的时候我们说过如果队首的Message是一个同步屏障，那么后续的消息都得不到执行，那么这个同步屏障是用来干嘛的呢？这个同步屏障涉及到MessageQueue的以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes a synchronization barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> token The synchronization barrier token that was returned by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #postSyncBarrier&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if the barrier was not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified message queue synchronization "</span></span><br><span class="line">                    + <span class="string">" barrier token has not been posted or has already been removed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过postSyncBarrier方法来建立一个同步屏障，插入到Message链表合适的位置，然后通过removeSyncBarrier来移除一个同步屏障，那么这两个方法啥时候会调用呢？通过全局搜索系统源码，发现ViewRootImpl里面有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">"ViewAncestor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        performTraversals();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在调用scheduleTraversals的时候，会post一个SyncBarrier建立屏障，然后调用mChoreographer.postCallback方法post一个runnable，在这个runnable里面会执行doTraversal方法，然后在这个doTraversal方法里面会removeSyncBarrier移除屏障。看到这个performTraversals大家应该比较熟悉了，这里面就就会递归进行整个界面View树的绘制</p>
<p>那么问题来了，这里为啥要使用同步屏障呢？post到Choreographer的runnable啥时候执行呢？为了一探究竟，我们继续深入看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"action must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (callbackType &lt; <span class="number">0</span> || callbackType &gt; CALLBACK_LAST) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callbackType is invalid"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"PostCallback: type="</span> + callbackType</span><br><span class="line">                + <span class="string">", action="</span> + action + <span class="string">", token="</span> + token</span><br><span class="line">                + <span class="string">", delayMillis="</span> + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现传入的action会先放入到mCallbackQueues保存起来，然后进入到了scheduleFrameLocked方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Scheduling next frame on vsync."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If running on the Looper thread, then schedule the vsync immediately,</span></span><br><span class="line">            <span class="comment">// otherwise post a message to schedule the vsync from the UI thread</span></span><br><span class="line">            <span class="comment">// as soon as possible.</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Scheduling next frame in "</span> + (nextFrameTime - now) + <span class="string">" ms."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个USE_VSYNC指的是垂直同步，关于什么是垂直同步，这里不做深入讲解，只需要知道是一种屏幕刷新机制就行。如果使用垂直同步的话，就可以发现进入到了scheduleVsyncLocked方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Schedules a single vertical sync pulse to be delivered when the next</span></span><br><span class="line"><span class="comment"> * display frame begins.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释，这个方法其实就是在下一帧开始的时候安排一个垂直同步脉冲，然后会在FrameDisplayEventReceiver.onVsync收到回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when a vertical sync pulse is received.</span></span><br><span class="line"><span class="comment">     * The recipient should render a frame and then call &#123;<span class="doctag">@link</span> #scheduleVsync&#125;</span></span><br><span class="line"><span class="comment">     * to schedule the next vertical sync pulse.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestampNanos The timestamp of the pulse, in the &#123;<span class="doctag">@link</span> System#nanoTime()&#125;</span></span><br><span class="line"><span class="comment">     * timebase.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> physicalDisplayId Stable display ID that uniquely describes a (display, port) pair.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> frame The frame number.  Increases by one for each vertical sync interval.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">long</span> physicalDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">            <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">            <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">            <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">            <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">            <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Frame time is "</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                        + <span class="string">" ms in the future!  Check that graphics HAL is generating vsync "</span></span><br><span class="line">                        + <span class="string">"timestamps using the correct timebase."</span>);</span><br><span class="line">                timestampNanos = now;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Already have a pending vsync event.  There should only be "</span></span><br><span class="line">                        + <span class="string">"one at a time."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mHavePendingVsync = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mTimestampNanos = timestampNanos;</span><br><span class="line">            mFrame = frame;</span><br><span class="line">            Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从方法的注释可以看出，当一个垂直同步脉冲达到的时候就会回调这个方法，在这个方法里面会render frame，然后调用scheduleVsync开始安排下一个垂直同步脉冲。</p>
<p>从上面代码可以看出，在onVsync这个方法里面，<font color="#ff0000"> 会发送一个异步的Message</font>，前面我们说过，设置了同步屏障之后，只允许异步的Message得到执行，我们来看下这个Message的callBack执行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里会执行doFrame方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">       <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">               <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">           &#125;</span><br><span class="line">           ............</span><br><span class="line">           <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">           startNanos = System.nanoTime();</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">           <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">               <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                   Log.i(TAG, <span class="string">"Skipped "</span> + skippedFrames + <span class="string">" frames!  "</span></span><br><span class="line">                           + <span class="string">"The application may be doing too much work on its main thread."</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                   Log.d(TAG, <span class="string">"Missed vsync by "</span> + (jitterNanos * <span class="number">0.000001f</span>) + <span class="string">" ms "</span></span><br><span class="line">                           + <span class="string">"which is more than the frame interval of "</span></span><br><span class="line">                           + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">" ms!  "</span></span><br><span class="line">                           + <span class="string">"Skipping "</span> + skippedFrames + <span class="string">" frames and setting frame "</span></span><br><span class="line">                           + <span class="string">"time to "</span> + (lastFrameOffset * <span class="number">0.000001f</span>) + <span class="string">" ms in the past."</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                   Log.d(TAG, <span class="string">"Frame time appears to be going backwards.  May be due to a "</span></span><br><span class="line">                           + <span class="string">"previously skipped frame.  Waiting for next vsync."</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               scheduleVsyncLocked();</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mFPSDivisor &gt; <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">long</span> timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;</span><br><span class="line">               <span class="keyword">if</span> (timeSinceVsync &lt; (mFrameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   scheduleVsyncLocked();</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">           mFrameScheduled = <span class="keyword">false</span>;</span><br><span class="line">           mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Choreographer#doFrame"</span>);</span><br><span class="line">           AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">           mFrameInfo.markInputHandlingStart();</span><br><span class="line">           doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">           mFrameInfo.markAnimationsStart();</span><br><span class="line">           doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">           doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">           mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">           doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">           doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           AnimationUtils.unlockAnimationClock();</span><br><span class="line">           Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在这个doFrame方法里面，会先判断如果出现了丢帧现象就会调用scheduleVsyncLocked方法开始安排下一个垂直同步脉冲，否则就会把mFrameScheduled设置为false，停止监听这个Vsync信号。虽然系统会每隔16.6ms执行一次屏幕刷新，但是app上层不一定会监听这个Vsync事件，只有是调用了scheduleFrameLocked方法才会开始监听这个Vsync信号，app上层才会收到回调。比如界面需要进行刷新了，才会调用scheduleFrameLocked方法来监听屏幕刷新信号，遍历绘制View树来重新计算屏幕数据。如果界面一直不需要进行刷新，那么app上层就不会去接收每隔16.6ms回调的屏幕刷新信号了。</p>
<p>然后继续往下走的话会执行doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos)代码，这个代码里面最终会执行最开始说的TraversalRunnable来进行UI刷新，然后会调用removeSyncBarrier解除屏障。</p>
<p>同时，我们再来回顾一下前面分析的MessageQueue.next方法里面的一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line"><span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line"><span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有同步屏障的情况下，这个mMessage就是这个同步屏障Message ,这个now肯定是要大于mMessages.when的，因为同步屏障是在scheduleTraversals方法里面就加入了，因此如果屏障不解除，那么idle就永远得不到执行！</p>
<p>总结一下：</p>
<blockquote>
<p>1、从以上的分析过程来看，使用同步屏障主要是与Vsync配合使用来做屏幕刷新的，开始安排一个Vsync的时候设置一个同步屏障，只有当收到Vsync回调的时候才会解除屏障。<br>2、这里使用同步屏障的目的主要是为了保证收到Vsync信号的时候能够第一时间响应遍历绘制View树的工作，不然就会造成丢帧现象<br>3、从以上分析可以进一步看出：当我们调用invalidate等刷新界面的时候，并不是马上就会执行UI刷新操作的，而是先通过ViewRootImpl的scheduleTraversals方法向底层注册监听下一个垂直同步信号，等这个垂直同步信号来了之后，才会通过performTraversals方法来刷新界面<br>4、其实以上分析就是Android的屏幕刷新机制</p>
</blockquote>
<h2 id="onDraw里面调用invalidate为啥会导致IdleHandler得不到执行？"><a href="#onDraw里面调用invalidate为啥会导致IdleHandler得不到执行？" class="headerlink" title="onDraw里面调用invalidate为啥会导致IdleHandler得不到执行？"></a>onDraw里面调用invalidate为啥会导致IdleHandler得不到执行？</h2><p>当我们在onDraw方法里面调用invalidate方法的时候，会调用到ViewRootImpl的scheduleTraversals方法，里面会发送一个同步屏障，然后收到onVsync回调最终执行到TraversalRunnable的时候会解除屏障，同时调用performTraversals方法，这个方法里面又会调用onDraw方法，从而形成死循环，导致屏障刚被解除马上又发送了一个新的屏障，这样idle一直得不到执行。</p>
<p>因此为了避免这种case，尽量不要在onDraw方法里面调用invalidate方法！</p>
<h2 id="ViewAnimation循环执行为啥会导致IdleHandler得不到执行-而使用属性动画就没有这个问题？"><a href="#ViewAnimation循环执行为啥会导致IdleHandler得不到执行-而使用属性动画就没有这个问题？" class="headerlink" title="ViewAnimation循环执行为啥会导致IdleHandler得不到执行,而使用属性动画就没有这个问题？"></a>ViewAnimation循环执行为啥会导致IdleHandler得不到执行,而使用属性动画就没有这个问题？</h2><p>ViewAnimation底层也是通过调用invalidate来实现的，无限循环动画就会导致无限调用invalidate，就会导致idle得不到执行。</p>
<p>属性动画的实现原理不同于View动画。View动画的每一帧都是通过invalidate方法来触发重绘，而属性动画每一帧的绘制都是通过Choreographer的回调实现。因此，本质上来说，属性动画少了一个很重要的步骤，就是post一个同步屏障。在属性动画中，没有同步屏障，那么后续的任务能够继续执行，当队列中没有任务时，自然就会回调IdleHandler了。</p>
<p>关于属性动画的底层实现原理，后续有机会会进行分析</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要是从源码的角度分析了Handler消息机制的底层实现原理，包括阻塞与同步、同步屏障、android屏幕刷新机制、idleHandler得不到执行的问题等，希望通过阅读本篇文章，能够对Handler消息机制有一个全新的认识，能够达到知其然且知其所以然</p>

        </div>
        <footer class="article-footer">
            



        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "EasyLiu"
        },
        "headline": "Handler消息机制深入解析",
        "image": "http://easyliu.com",
        "keywords": "Android",
        "genre": "Android源码解析",
        "datePublished": "2021-03-06",
        "dateCreated": "2021-03-06",
        "dateModified": "2022-02-17",
        "url": "http://easyliu.com/2021/03/06/android_source_analysis/handler/",
        "description": "前言大家在日常开发中肯定用过Handler，常用的API主要有:
1234post(@NonNull Runnable r) postDelayed(@NonNull Runnable r, long delayMillis)postAtFrontOfQueue(@NonNull Runnable r) ..........

在主线程中可以通过这些API可以进行延时操作，在子线程中可以通过这些A",
        "wordCount": 8563
    }
</script>

</article>

    <section id="comments">
    
        
    <!-- Valine -->
    <div class="vcomments"></div>


    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/EasyLiu-Ly" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2021/03/16/android_source_analysis/ValueAnimator/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">下一篇</strong>
        <p class="article-nav-title">
        
            ValueAnimator属性动画深入解析
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2021/02/18/hexo/hexo_comment/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">hexo博客添加评论、字数、阅读时间以及访问量</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
<div class="widget-wrap widget-list">
    <h3 class="widget-title">目录</h3>
    <div class="widget">
        <div id="toc" class="toc-article">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主线程的Looper-loop-方法是啥时候执行的？"><span class="toc-number">2.</span> <span class="toc-text">主线程的Looper.loop()方法是啥时候执行的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Looper、MessageQueue以及Message三者交互的底层实现原理"><span class="toc-number">3.</span> <span class="toc-text">Looper、MessageQueue以及Message三者交互的底层实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Looper死循环为什么不会导致应用卡死？"><span class="toc-number">4.</span> <span class="toc-text">Looper死循环为什么不会导致应用卡死？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ANR产生的原因"><span class="toc-number">5.</span> <span class="toc-text">ANR产生的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步屏障SyncBarrier"><span class="toc-number">6.</span> <span class="toc-text">同步屏障SyncBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#onDraw里面调用invalidate为啥会导致IdleHandler得不到执行？"><span class="toc-number">7.</span> <span class="toc-text">onDraw里面调用invalidate为啥会导致IdleHandler得不到执行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ViewAnimation循环执行为啥会导致IdleHandler得不到执行-而使用属性动画就没有这个问题？"><span class="toc-number">8.</span> <span class="toc-text">ViewAnimation循环执行为啥会导致IdleHandler得不到执行,而使用属性动画就没有这个问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol>
        </div>
    </div>
</div>


            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/09/07/life/2021_8_22_seven_mother_moutain/" class="thumbnail">
    
    
        <span style="background-image:url(/2021/09/07/life/2021_8_22_seven_mother_moutain/pic_1.jpg)" alt="深圳大鹏7娘山——2021.8.22" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/周末活动/">周末活动</a></p>
                            <p class="item-title"><a href="/2021/09/07/life/2021_8_22_seven_mother_moutain/" class="title">深圳大鹏7娘山——2021.8.22</a></p>
                            <p class="item-date"><time datetime="2021-09-07T01:49:51.000Z" itemprop="datePublished">2021-09-07</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/06/08/live_study/visit_camare_through_browser/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/从0打造音视频直播系统/">从0打造音视频直播系统</a></p>
                            <p class="item-title"><a href="/2021/06/08/live_study/visit_camare_through_browser/" class="title">（一）通过浏览器访问摄像头</a></p>
                            <p class="item-date"><time datetime="2021-06-08T02:22:02.000Z" itemprop="datePublished">2021-06-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/05/10/android_performance/webViewFactory_getProvider/" class="thumbnail">
    
    
        <span style="background-image:url(/2021/05/10/android_performance/webViewFactory_getProvider/WebViewFacory_getProvider_trace.png)" alt="WebViewFactory.getProvider耗时问题的一种解决思路" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android性能优化/">Android性能优化</a></p>
                            <p class="item-title"><a href="/2021/05/10/android_performance/webViewFactory_getProvider/" class="title">WebViewFactory.getProvider耗时问题的一种解决思路</a></p>
                            <p class="item-date"><time datetime="2021-05-10T02:11:49.000Z" itemprop="datePublished">2021-05-10</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/04/27/android_performance/system_trace_use/" class="thumbnail">
    
    
        <span style="background-image:url(/2021/04/27/android_performance/system_trace_use/system_trace.png)" alt="Android SystemTrace实战" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android性能优化/">Android性能优化</a></p>
                            <p class="item-title"><a href="/2021/04/27/android_performance/system_trace_use/" class="title">Android SystemTrace实战</a></p>
                            <p class="item-date"><time datetime="2021-04-27T01:44:05.000Z" itemprop="datePublished">2021-04-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/04/27/android_source_analysis/reportSizeConfigurations_exception/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android疑难杂症/">Android疑难杂症</a></p>
                            <p class="item-title"><a href="/2021/04/27/android_source_analysis/reportSizeConfigurations_exception/" class="title">ActivityManagerService.reportSizeConfigurations异常问题规避方案</a></p>
                            <p class="item-date"><time datetime="2021-04-27T01:34:59.000Z" itemprop="datePublished">2021-04-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android性能优化/">Android性能优化</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android架构学习/">Android架构学习</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android源码解析/">Android源码解析</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android疑难杂症/">Android疑难杂症</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android自定义控件/">Android自定义控件</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Gradle相关/">Gradle相关</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ios开发/">ios开发</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/从0打造音视频直播系统/">从0打造音视频直播系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/代码规范/">代码规范</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/刷题/">刷题</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/单元测试/">单元测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/周末活动/">周末活动</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习计划/">学习计划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/旅游/">旅游</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">3</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo进阶/">hexo进阶</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios开发/">ios开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码规范/">代码规范</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/单元测试/">单元测试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习笔记/">学习笔记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习计划/">学习计划</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日常活动/">日常活动</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日常生活/">日常生活</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">4</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://github.com/EasyLiu-Ly">我的github</a>
                    </li>
                
                    <li>
                        <a href="http://blog.csdn.net/liuyi1207164339">我的csdn博客</a>
                    </li>
                
                    <li>
                        <a href="http://blog.csdn.net/lmj623565791">鸿洋大神</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2022 EasyLiu</p>
                
                <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="https://github.com/ppoffice" target="_blank">PPOffice</a></p>
                
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

    </div>
    
    
    <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
    <script>
        var GUEST = ['nick','mail','link'];
        var meta = 'undefined';
        meta = meta.split(',').filter(function (item) {
            return GUEST.indexOf(item)>-1;
        });
        var avatarcdn = 'https://gravatar.loli.net/avatar/' == true;
        new Valine({
            el: '.vcomments',
            notify: "false",
            verify: "false",
            appId: "HTT9HtdG3ACsrMQEd8X7aSD5-gzGzoHsz",
            appKey: "gEf913xnOAwiO8lVEWztLOQC",
            placeholder: "just write your comments",
            avatar:"retro",
            recordIP:"true",
            visitor: "true",
            emojiCDN: '//i0.hdslb.com/bfs/emote/', 
            emojiMaps: {
                "doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
                "亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
                "偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
                "再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
                "冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
                "发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
                "发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
                "可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
                "吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
                "呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
                "呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
                "困": "241ee304e44c0af029adceb294399391e4737ef2.png",
                "坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
                "大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
                "大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
                "委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
                "害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
                "尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
                "微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
                "思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
                "惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png"
            }
        });
    </script>





    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    

    
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

</body>
</html>
