{"meta":{"title":"EasyLiu","subtitle":"welcome to my blog","description":"欢迎来到我的博客","author":"EasyLiu","url":"http://easyliu.com"},"pages":[{"title":"关于","date":"2017-03-17T16:00:00.000Z","updated":"2020-05-17T10:42:56.681Z","comments":true,"path":"about/index.html","permalink":"http://easyliu.com/about/index.html","excerpt":"","text":"程序员一枚,专注移动端开发 Nickname: EasyLiu Email: ly_eyl@163.com Github: EasyLiu-Ly"}],"posts":[{"title":"hexo插入音频和视频","slug":"hexo/insert_video","date":"2020-11-22T04:08:15.000Z","updated":"2020-12-03T02:58:24.915Z","comments":false,"path":"2020/11/22/hexo/insert_video/","link":"","permalink":"http://easyliu.com/2020/11/22/hexo/insert_video/","excerpt":"","text":"音视频准备在线音视频如果是在线音视频的话，只要有url就行 本地音视频在public文件夹下面新建一个resources目录，把视频和音频放在这个目录里面，这里我把视频放在video子目录下面，把音频放在audio子目录下面。 为啥要把资源放在public？只有把资源放在public文件夹下面，网页才能访问！！最开始就是在这里卡了很久一直没法播放，原来是路径设置不对导致没法访问 安装插件安装aplayer以及dplayer: npm install hexo-tag-aplayer npm install hexo-tag-dplayer 关于aplayer以及dplayer语法，参考： hexo-tag-aplayer hexo-tag-dplayer Hexo博客中插入音乐/视频/ DPlayer http://dplayer.js.org/guide.html#quick-start 然后在md文件中插入如下代码，视频就正常加载起播了，这里播放的是本地视频！ 12345678910111213141516171819202122232425&#123;% dplayer \"url=/resources/video/scenery.mp4\" //设置视频目录，这里我放在了网站根目录下面，也就是public目录下面 \"pic=/resources/images/scenery_three.jpeg\" //设置封面图，同样是放在根目录下面 \"loop=yes\" //循环播放 \"theme=#FADFA3\" //主题 \"autoplay=true\" //自动播放 \"screenshot=true\" //允许截屏 \"hotkey=true\" //允许hotKey，比如点击空格暂停视频等操作 \"preload=auto\" //预加载：auto \"volume=0.9\" //初始音量 \"playbackSpeed=1\"//播放速度1倍速，可以选择1.5,2等 \"lang=zh-cn\"//语言 \"mutex=true\"//播放互斥，就比如其他视频播放就会导致这个视频自动暂停 //下面是弹幕相关 \"id=9E2E3368B56CD123BB4\" \"api=https://api.prprpr.me/dplayer/\" \"token=tokendemo\" \"maximum=1000\" \"addition=['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']\" \"user=DIYgod\" \"bottom=15%\" \"unlimited=true\"%&#125; 以上只是部分设置，更多参数设置参考DPlayer (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"autoplay\":true,\"theme\":\"#FADFA3\",\"loop\":true,\"lang\":\"zh-cn\",\"screenshot\":true,\"hotkey\":true,\"preload\":\"auto\",\"volume\":0.9,\"mutex\":true,\"video\":{\"url\":\"/resources/video/scenery.mp4\",\"pic\":\"/resources/images/scenery_three.jpeg\"},\"danmaku\":{\"id\":\"9E2E3368B56CD123BB4\",\"api\":\"https://api.prprpr.me/dplayer/\",\"token\":\"tokendemo\",\"maximum\":1000,\"addition\":[\"['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']\"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 插入音频代码,音频就正常加载起播了，这里播放的是在线音频！ aplayer安装不了，先注释： 如果您觉得写的还不错，感谢打赏：","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://easyliu.com/categories/开发工具/"}],"tags":[{"name":"hexo进阶","slug":"hexo进阶","permalink":"http://easyliu.com/tags/hexo进阶/"}]},{"title":"厦门——2020.11.22-24","slug":"life/2020_11_22-24-xiamen","date":"2020-11-22T02:39:18.000Z","updated":"2020-11-22T02:52:06.179Z","comments":false,"path":"2020/11/22/life/2020_11_22-24-xiamen/","link":"","permalink":"http://easyliu.com/2020/11/22/life/2020_11_22-24-xiamen/","excerpt":"","text":"","categories":[{"name":"旅游","slug":"旅游","permalink":"http://easyliu.com/categories/旅游/"}],"tags":[{"name":"日常生活","slug":"日常生活","permalink":"http://easyliu.com/tags/日常生活/"}]},{"title":"梧桐山——2020.11.21","slug":"life/2020_11_21_wutong_mountain","date":"2020-11-22T02:10:28.000Z","updated":"2020-11-22T02:31:26.377Z","comments":false,"path":"2020/11/22/life/2020_11_21_wutong_mountain/","link":"","permalink":"http://easyliu.com/2020/11/22/life/2020_11_21_wutong_mountain/","excerpt":"","text":"看我犀利的眼神 置身仙境","categories":[{"name":"周末活动","slug":"周末活动","permalink":"http://easyliu.com/categories/周末活动/"}],"tags":[{"name":"日常生活","slug":"日常生活","permalink":"http://easyliu.com/tags/日常生活/"}]},{"title":"Android MVVM框架之Livedata以及ViewModel","slug":"android_jetpack/livedata","date":"2020-11-07T10:07:19.000Z","updated":"2020-12-09T09:55:03.054Z","comments":false,"path":"2020/11/07/android_jetpack/livedata/","link":"","permalink":"http://easyliu.com/2020/11/07/android_jetpack/livedata/","excerpt":"","text":"背景场景1:假设现在我们在Activity或者fragment当中会监听数据Model的回调，在回调里面会更新一些UI的状态，那么就会存在以下问题： 1、当页面不可见的时候也是能收到回调的，相当于在后台进行UI刷新，这个其实是不对的。一般情况下如果想解决这个问题的话就需要在onStop的时候反注册Model监听，然后等页面回来onStart的时候重新注册Model监听且需要主动读取一次Model数据进行ui刷新，听起来是不是很麻烦？ 2、在onDestory里面会需要主动反注册Model的回调,如果忘记反注册就会导致内存泄漏问题 针对这个问题，google在jetpack组件的Android架构组件当中提供了LiveData类来解决这个问题 场景2Activity或者Fragment在后台的时候可能由于资源不足导致销毁重新创建，就会导致界面数据丢失问题，对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的Bundle恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图 针对这个问题google在jetpack组件的Android架构组件当中提供了ViewModel类来解决这个问题 MVVM框架大家可以看下google推荐的Android架构图,如下所示。ViewModel和LiveData是一起配套使用的，组成了MVVM架构： 使用方式ViewModel及LiveData的接入方式参考:https://developer.android.com/jetpack/androidx/releases/lifecycle 下面看下使用方式：1、首先自定义一个ViewModel类: 1234567891011121314public class NameViewModel extends ViewModel &#123;// Create a LiveData with a Stringprivate MutableLiveData&lt;String&gt; currentName; public MutableLiveData&lt;String&gt; getCurrentName() &#123; if (currentName == null) &#123; currentName = new MutableLiveData&lt;String&gt;(); &#125; return currentName; &#125;// Rest of the ViewModel...&#125; 自定义一个NamaViewModel继承自ViewModel，稍后会对ViewModel源码进行解析。里面有一个MutableLiveData对象，它是LiveData子类，稍后会对LiveData源码进行解析。 2、接下来看下这个NameViewModel的使用方式： 1234567891011121314151617181920212223242526public class NameActivity extends AppCompatActivity &#123; private NameViewModel model; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Other code to setup the activity... // Get the ViewModel. model = new ViewModelProvider(this,new NewInstanceFactory()).get(NameViewModel.class); // Create the observer which updates the UI. final Observer&lt;String&gt; nameObserver = new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable final String newName) &#123; // Update the UI, in this case, a TextView. nameTextView.setText(newName); &#125; &#125;; // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. model.getCurrentName().observe(this, nameObserver); &#125;&#125; 可以看出从ViewModelProvider里面根据class类型到了一个NameViewModel，然后给里面的LiveData注册了一个观察者Observer，在这个Observer会更新TextView的显示文本 3、更新数据： 1234567button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; String anotherName = \"John Doe\"; model.getCurrentName().setValue(anotherName); &#125;&#125;); 更新数据的方式也很简单，调用LiveData里面的\bsetValue方法即可，如果是在子线程，就调用postValue方法 以上就是ViewModel+LiveData的使用方式，接下来分别对LiveData及ViewModel进行源码剖析 LiveDataLiveData为什么可以解决开头提到的第一个问题场景1 来看下官网关于LiveData的描述： LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。LiveData 只会将更新通知给活跃的观察者。为观察 LiveData 对象而注册的非活跃观察者不会收到更改通知 看起来很厉害的样子，接下来从源码的角度来进行分析： LiveData源码解析首先是observer方法：12345678910111213141516public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException(\"Cannot add the same observer\" + \" with different lifecycles\"); &#125; if (existing != null) &#123; return; &#125; owner.getLifecycle().addObserver(wrapper);&#125; 可以看到observer方法传入了2个参数： LifecycleOwner（如果对LifecycleOwner不太了解，参考之前的博文：Android生命周期感应组件lifecycle ）和Observer接口，Oberver就是一个简单的观察接口，通过泛型代表具体的数据类型： 1234567public interface Observer&lt;T&gt; &#123; /** * Called when the data is changed. * @param t The new data */ void onChanged(@Nullable T t);&#125; 方法主要分为几部分： 1、如果当前LifecycleOwner是destoryed的状态就直接返回2、生成一个LifecycleBoundObserver对象wrapper，放入mObservers这个Map当中3、最后把wrapper加入到Lifecycle里面，从这里可以看出LifecycleBoundObserver实现了Lifecycle接口 解析来看下这个LifecycleBoundObserver对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;T&gt; observer) &#123; super(observer); mOwner = owner; &#125; @Override boolean shouldBeActive() &#123; return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; //1、在LifecycleOwner销毁了之后会自动移除obverver，解决内存泄漏问题 if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(mObserver); return; &#125; activeStateChanged(shouldBeActive()); &#125; @Override boolean isAttachedTo(LifecycleOwner owner) &#123; return mOwner == owner; &#125; @Override void detachObserver() &#123; mOwner.getLifecycle().removeObserver(this); &#125; &#125; private abstract class ObserverWrapper &#123; final Observer&lt;T&gt; mObserver; boolean mActive; int mLastVersion = START_VERSION; ObserverWrapper(Observer&lt;T&gt; observer) &#123; mObserver = observer; &#125; abstract boolean shouldBeActive(); boolean isAttachedTo(LifecycleOwner owner) &#123; return false; &#125; void detachObserver() &#123; &#125; void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; return; &#125; // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; //变成active状态 if (wasInactive &amp;&amp; mActive) &#123; onActive(); &#125; //变成InActive状态 if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; onInactive(); &#125; //2、从InActive变成Active，会自动dispatchVaule，也就是页面可见的时候就会自动收到最新的数据回调 if (mActive) &#123; dispatchingValue(this); &#125; &#125; &#125; 从以上代码可以看出，LifecycleBoundObserver实现了Lifecycle生命周期接口，能够自动感应生命周期的变化，并且解决了最开始场景1提出的2个问题： 1、在LifecycleOwner销毁了之后会自动移除obverver，解决内存泄漏问题2、从InActive变成Active，会自动dispatchVaule，也就是页面可见的时候就会自动收到最新的数据回调 我们还注意到LiveData有两个方法:onActive和onInactive，这两个方法在LiveData是空方法，子类可以覆写这俩个方法，在里面做一些注册和反注册的操作，如下所示： 123456789101112131415161718192021222324public class StockLiveData extends LiveData&lt;BigDecimal&gt; &#123; private StockManager stockManager; private SimplePriceListener listener = new SimplePriceListener() &#123; @Override public void onPriceChanged(BigDecimal price) &#123; setValue(price); &#125; &#125;; public StockLiveData(String symbol) &#123; stockManager = new StockManager(symbol); &#125; @Override protected void onActive() &#123; stockManager.requestPriceUpdates(listener); &#125; @Override protected void onInactive() &#123; stockManager.removeUpdates(listener); &#125;&#125; 接下来是setValue以及postValue12345678910111213141516171819202122232425262728293031323334353637383940private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; mPendingData = NOT_SET; &#125; //noinspection unchecked setValue((T) newValue); &#125;&#125;;protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);&#125;/** * Sets the value. If there are active observers, the value will be dispatched to them. * &lt;p&gt; * This method must be called from the main thread. If you need set a value from a background * thread, you can use &#123;@link #postValue(Object)&#125; * * @param value The new value */@MainThreadprotected void setValue(T value) &#123; assertMainThread(\"setValue\"); mVersion++; mData = value; dispatchingValue(null);&#125; 可以看出postValue用于在子线程调用的场景，post到主线程执行setValue。这里大家可能有个疑问就是这个postValue以及setValue都是protected方法，外部怎么调用呢？一般情况下使用MutableLiveData： 1234567891011121314151617/** * &#123;@link LiveData&#125; which publicly exposes &#123;@link #setValue(T)&#125; and &#123;@link #postValue(T)&#125; method. * * @param &lt;T&gt; The type of data hold by this instance */@SuppressWarnings(\"WeakerAccess\")public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt; &#123; @Override public void postValue(T value) &#123; super.postValue(value); &#125; @Override public void setValue(T value) &#123; super.setValue(value); &#125;&#125; 以上就是LiveData源码分析结果，可以看出主要还是借助了Lifecycle生命周期自动感应的特性来解决问题。LiveData还有一些高级的玩法，具体参考：https://developer.android.com/topic/libraries/architecture/livedata ViewModelViewModel为什么可以解决开头提到的第二个问题场景2 来看下官网关于ViewModel的描述： ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续留存。 先来回顾一下ViewModel的使用方式： 123456789101112131415161718192021222324252627public class NameActivity extends AppCompatActivity &#123; private NameViewModel model; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Other code to setup the activity... // Get the ViewModel. // 只要是同一个Activity，数据就是同一份 model = new ViewModelProvider(this,new NewInstanceFactory()).get(NameViewModel.class); // Create the observer which updates the UI. final Observer&lt;String&gt; nameObserver = new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable final String newName) &#123; // Update the UI, in this case, a TextView. nameTextView.setText(newName); &#125; &#125;; // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. model.getCurrentName().observe(this, nameObserver); &#125;&#125; 可以看出如果重新创建了NameActivity，它接收的NameViewModel实例与第一个NameActivity创建的实例相同，这样就数据就不会存在丢失的问题。当所有者NameActivity走了finish销毁之后，框架会调用ViewModel对象的onCleared()方法，以便它可以清理资源。 来看下ViewModel的生命周期 ViewModel生命周期ViewModel 对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。ViewModel 将一直留在内存中，直到限定其存在时间范围的 Lifecycle 永久消失：对于 Activity，是在 Activity 完成时；而对于 Fragment，是在 Fragment 分离时。如下图所示： 在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel。系统可能会在 Activity 的整个生命周期内多次调用 onCreate()，如在旋转设备屏幕时。ViewModel 存在的时间范围是从首次请求 ViewModel 直到 Activity 完成并销毁。 接下来看下对ViewModel源码进行解析： ViewModel源码解析ViewModel：1234567891011public abstract class ViewModel &#123; /** * This method will be called when this ViewModel is no longer used and will be destroyed. * &lt;p&gt; * It is useful when ViewModel observes some data and you need to clear this subscription to * prevent a leak of this ViewModel. */ @SuppressWarnings(\"WeakerAccess\") protected void onCleared() &#123; &#125;&#125; 可以看出ViewModel本身的话比较简单，就是一个抽象类，里面有一个onCleared（）方法，子类在这个方法里面可以做一些资源清理的操作 ViewModel有一个子类AndroidViewModel： 123456789101112131415161718public class AndroidViewModel extends ViewModel &#123; @SuppressLint(\"StaticFieldLeak\") private Application mApplication; public AndroidViewModel(@NonNull Application application) &#123; mApplication = application; &#125; /** * Return the application. */ @SuppressWarnings(\"TypeParameterUnusedInFormals\") @NonNull public &lt;T extends Application&gt; T getApplication() &#123; //noinspection unchecked return (T) mApplication; &#125;&#125; 一般情况下我们使用的时候是直接继承自AndroidViewModel，因为里面持有Application,可以获取到Android系统的一些系统资源 那么到这里大家就会有个疑问，ViewModel就这么简单？ViewModel的onCleared()方法是谁负责调用的呢？ 首先ViewModel的获取方式为： 1model = new ViewModelProvider(this,new NewInstanceFactory()).get(NameViewModel.class); ViewModelProvider我们来看下ViewModelProvider构造函数： 12345678public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) &#123; this(owner.getViewModelStore(), factory);&#125;public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) &#123; mFactory = factory; this.mViewModelStore = store;&#125; 可以看出传入的第一个参数为一个接口ViewModelStoreOwner，说明Activity实现了这个接口，返回一个ViewModelStore类型，第二个参数是一个工厂类，代表model创建工厂,系统提供了两个默认的工厂，分别是NewInstanceFactory用于创建普通的ViewModel，AndroidViewModelFactory用于创建AndroidViewModel 接下来看下get方法： 123456789101112131415161718192021222324252627282930@NonNull @MainThread public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException(\"Local and anonymous classes can not be ViewModels\"); &#125; return get(DEFAULT_KEY + \":\" + canonicalName, modelClass); &#125; @NonNull @MainThread public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel; &#125; 可以看出get方法就是从ViewModleStore里面根据key获得一个ViewModel返回，如果获取不到就通过factory创建一个ViewModel放入ViewModelStore当中,然后返回ViewModel。 ViewModelStore那么这里我们来看下ViewModelStore是个什么东东： 12345678910111213141516171819202122232425public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.onCleared(); &#125; mMap.clear(); &#125;&#125; 可以看到ViewModelStore里面其实就是一个HashMap，存有这个ViewModelProvider里面所有的ViewModel，一个ViewModelProvider跟一个页面进行对应。可以看到ViewModelStore里面还有一个clear方法，里面就调用了每个ViewModel的onCleared()方法，根据前面对ViewModel生命周期的说明，这个clear方法应该是在lifecycle的onDestroyed方法调用的。 通过Android Studio的find usage找到这个clear()方法的调用链，发现在lifecycle的extension包下面找到了一个叫做HolderFragment的类: HolderFragment12345678910111213141516171819202122232425262728293031/** * @hide */@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public class HolderFragment extends Fragment implements ViewModelStoreOwner &#123; .............. private ViewModelStore mViewModelStore = new ViewModelStore(); ................ @Override public void onDestroy() &#123; super.onDestroy(); mViewModelStore.clear(); &#125; /** * @hide */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public static HolderFragment holderFragmentFor(FragmentActivity activity) &#123; return sHolderFragmentManager.holderFragmentFor(activity); &#125; /** * @hide */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public static HolderFragment holderFragmentFor(Fragment fragment) &#123; return sHolderFragmentManager.holderFragmentFor(fragment); &#125; 在这个fragment的onDestroy()方法里面调用了ViewModelStore的clear方法。熟悉lifecycle的朋友看到这里是不是有一种豁然开朗的感觉，这个HolderFragment肯定是跟ViewModelProvider对应的页面进行了绑定！那么HolderFragment是啥时候跟页面进行绑定的呢？ 来看下holderFragmentFor(FragmentActivity activity)调用的地方： ViewModelStores123456789101112131415161718192021@SuppressWarnings(\"WeakerAccess\")public class ViewModelStores &#123; @NonNull @MainThread public static ViewModelStore of(@NonNull FragmentActivity activity) &#123; if (activity instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) activity).getViewModelStore(); &#125; return holderFragmentFor(activity).getViewModelStore(); &#125; @NonNull @MainThread public static ViewModelStore of(@NonNull Fragment fragment) &#123; if (fragment instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) fragment).getViewModelStore(); &#125; return holderFragmentFor(fragment).getViewModelStore(); &#125;&#125; 可以看出这个ViewModelStores是一个工具类，用于生成ViewModelStore，而这个ViewModelStore就是从HolderFragment获取的，这个HolderFragment就挂载在这个fragment或者activity上面，接下来看下ViewModelStores的of方法调用的地方： ViewModelProviders1234567891011121314151617181920212223242526272829303132333435public class ViewModelProviders &#123; @NonNull @MainThread public static ViewModelProvider of(@NonNull Fragment fragment) &#123; return of(fragment, null); &#125; @NonNull @MainThread public static ViewModelProvider of(@NonNull FragmentActivity activity) &#123; return of(activity, null); &#125; @NonNull @MainThread public static ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory) &#123; Application application = checkApplication(checkActivity(fragment)); if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; return new ViewModelProvider(ViewModelStores.of(fragment), factory); &#125; @NonNull @MainThread public static ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory) &#123; Application application = checkApplication(activity); if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; return new ViewModelProvider(ViewModelStores.of(activity), factory); &#125;&#125; 可以看出这个ViewModelProviders是一个工具类，用于生成ViewModelProvider，这里面就会调用ViewModelStores的of方法获取ViewModelStore，而我们刚刚也说了这个of方法里面就会挂载一个HolderFragment用于感应对应页面的生命周期。因此，要想自定义的ViewModel在页面销毁的时候能够自动调用onCleared()方法，得通过ViewModelProviders来获取： 1viewModelProvider= ViewModelProviders.of(this); 至此ViewModel源码分析完成,更多高级玩法参考：https://developer.android.com/topic/libraries/architecture/viewmodel 总结至此LiveData+ViewModel源码已经分析完成，结合之前的Android生命周期感应组件lifecycle,整个就组成了MVVM架构。 这个架构里面很多思想值得我们细细品味～～ 基于这个LiveData这些优良的特性，美团技术团队开发了一个LiveDataEventBus来代替传统的EventBus、RxJava等消息框架,感兴趣的可以看看：https://tech.meituan.com/2018/07/26/android-livedatabus.html https://github.com/JeremyLiao/LiveEventBus 如果您觉得写的还不错，感谢打赏：","categories":[{"name":"Android架构学习","slug":"Android架构学习","permalink":"http://easyliu.com/categories/Android架构学习/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"早起龙城公园爬山——2020.11.1","slug":"life/2020_11_1_longcheng_park","date":"2020-11-01T08:59:16.000Z","updated":"2020-11-22T05:17:52.545Z","comments":false,"path":"2020/11/01/life/2020_11_1_longcheng_park/","link":"","permalink":"http://easyliu.com/2020/11/01/life/2020_11_1_longcheng_park/","excerpt":"","text":"空气新鲜(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"autoplay\":true,\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"/resources/video/scenery.mp4\",\"pic\":\"/resources/image/scenery_three.jpeg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 你大爷还是你大爷","categories":[{"name":"周末活动","slug":"周末活动","permalink":"http://easyliu.com/categories/周末活动/"}],"tags":[{"name":"日常生活","slug":"日常生活","permalink":"http://easyliu.com/tags/日常生活/"}]},{"title":"Android生命周期感应组件lifecycle","slug":"android_jetpack/lifecycle","date":"2020-10-31T08:34:04.000Z","updated":"2020-11-29T09:32:32.982Z","comments":false,"path":"2020/10/31/android_jetpack/lifecycle/","link":"","permalink":"http://easyliu.com/2020/10/31/android_jetpack/lifecycle/","excerpt":"","text":"背景生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您写出更有条理且往往更精简的代码，这样的代码更易于维护。 一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。 androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。导入方法 在 Android 框架中定义的大多数应用组件都存在生命周期。生命周期由操作系统或进程中运行的框架代码管理。它们是 Android 运作方式的核心，应用必须遵循它们。如果不这样做，可能会引发内存泄露甚至应用崩溃。 假设我们有一个在屏幕上显示设备位置的 Activity。常见的实现可能如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // connect to system location service &#125; void stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; @Override public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // update UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); myLocationListener.start(); // manage other components that need to respond // to the activity lifecycle &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); // manage other components that need to respond // to the activity lifecycle &#125;&#125; 虽然此示例看起来没问题，但在真实的应用中，最终会有太多管理界面和其他组件的调用，以响应生命周期的当前状态。管理多个组件会在生命周期方法（如 onStart() 和 onStop()）中放置大量的代码，这使得它们难以维护。 androidx.lifecycle 软件包提供的类和接口可帮助您以弹性和隔离的方式解决这些问题。 LifecycleLifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。 Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态： 事件从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。 状态由 Lifecycle 对象跟踪的组件的当前状态。 Lifecycle源代码如下，可以看出下Lifecycle类主要是3个方法，分别是：添加observer、移除observer以及获取当前的状态，然后类里面有关于Event和State的定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public abstract class Lifecycle &#123; /** * Adds a LifecycleObserver that will be notified when the LifecycleOwner changes * @param observer The observer to notify. */ @MainThread public abstract void addObserver(@NonNull LifecycleObserver observer); /** * Removes the given observer from the observers list. * @param observer The observer to be removed. */ @MainThread public abstract void removeObserver(@NonNull LifecycleObserver observer); /** * Returns the current state of the Lifecycle. * * @return The current state of the Lifecycle. */ @MainThread @NonNull public abstract State getCurrentState(); @SuppressWarnings(\"WeakerAccess\") public enum Event &#123; /** * Constant for onCreate event of the &#123;@link LifecycleOwner&#125;. */ ON_CREATE, /** * Constant for onStart event of the &#123;@link LifecycleOwner&#125;. */ ON_START, /** * Constant for onResume event of the &#123;@link LifecycleOwner&#125;. */ ON_RESUME, /** * Constant for onPause event of the &#123;@link LifecycleOwner&#125;. */ ON_PAUSE, /** * Constant for onStop event of the &#123;@link LifecycleOwner&#125;. */ ON_STOP, /** * Constant for onDestroy event of the &#123;@link LifecycleOwner&#125;. */ ON_DESTROY, /** * An &#123;@link Event Event&#125; constant that can be used to match all events. */ ON_ANY &#125; /** * Lifecycle states. You can consider the states as the nodes in a graph and * &#123;@link Event&#125;s as the edges between these nodes. */ @SuppressWarnings(\"WeakerAccess\") public enum State &#123; /** * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch * any more events. For instance, for an &#123;@link android.app.Activity&#125;, this state is reached * &lt;b&gt;right before&lt;/b&gt; Activity's &#123;@link android.app.Activity#onDestroy() onDestroy&#125; call. */ DESTROYED, /** * Initialized state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this is * the state when it is constructed but has not received * &#123;@link android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet. */ INITIALIZED, /** * Created state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this state * is reached in two cases: * &lt;ul&gt; * &lt;li&gt;after &#123;@link android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call; * &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;@link android.app.Activity#onStop() onStop&#125; call. * &lt;/ul&gt; */ CREATED, /** * Started state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this state * is reached in two cases: * &lt;ul&gt; * &lt;li&gt;after &#123;@link android.app.Activity#onStart() onStart&#125; call; * &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;@link android.app.Activity#onPause() onPause&#125; call. * &lt;/ul&gt; */ STARTED, /** * Resumed state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this state * is reached after &#123;@link android.app.Activity#onResume() onResume&#125; is called. */ RESUMED; /** * Compares if this State is greater or equal to the given &#123;@code state&#125;. * * @param state State to compare with * @return true if this State is greater or equal to the given &#123;@code state&#125; */ public boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0; &#125; &#125; 类可以通过向其方法添加注解来监控组件的生命周期状态。然后，可以通过调用 Lifecycle 类的 addObserver() 方法并传递观察者的实例来添加观察者，如以下示例中所示： 12345678910111213public class MyObserver implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void connectListener() &#123; ... &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void disconnectListener() &#123; ... &#125;&#125;myLifecycleOwner.getLifecycle().addObserver(new MyObserver()); 在上面的示例中，myLifecycleOwner 对象实现了 LifecycleOwner 接口 ,接下来讲一下LifecycleOwner接口： LifecycleOwner首先来看下LifecycleOwner接口的源码： 12345678910111213141516/** * A class that has an Android lifecycle. These events can be used by custom components to * handle lifecycle changes without implementing any code inside the Activity or the Fragment. * * @see Lifecycle */@SuppressWarnings(&#123;\"WeakerAccess\", \"unused\"&#125;)public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125; Android源码中，Activity以及Fragment均实现了这个LifecycleOwner接口，这样使用就非常简单了，直接使用getLifecycle().addObserver(new MyObserver())就可以把Observer注册到Lifecycle上，自动感应生命周期了。 生命周期自动感应原理解析那么问题来了，fragment或者activity是怎么把自身的生命周期分发给每一个Observer的呢？生命周期自动感应是怎么工作的呢？我们通过解析源码来找到答案。 查看SupportActivity的源码： 12345678910111213141516171819202122public class SupportActivity extends Activity implements LifecycleOwner, Component &#123; private SimpleArrayMap&lt;Class&lt;? extends SupportActivity.ExtraData&gt;, private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); public SupportActivity() &#123; &#125; protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this); &#125; @CallSuper protected void onSaveInstanceState(Bundle outState) &#123; this.mLifecycleRegistry.markState(State.CREATED); super.onSaveInstanceState(outState); &#125; public Lifecycle getLifecycle() &#123; return this.mLifecycleRegistry; &#125;&#125; 可以看出在activity的onCreate方法调用了一个方法： ReportFragment.injectIfNeededIn(activity)，接下来看下这个init做了什么事情： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ReportFragment extends Fragment &#123; private static final String REPORT_FRAGMENT_TAG = \"android.arch.lifecycle\" + \".LifecycleDispatcher.report_fragment_tag\"; public static void injectIfNeededIn(Activity activity) &#123; // ProcessLifecycleOwner should always correctly work and some activities may not extend // FragmentActivity from support lib, so we use framework fragments for activities android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); &#125; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE); &#125; @Override public void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START); &#125; @Override public void onResume() &#123; super.onResume(); dispatchResume(mProcessListener); dispatch(Lifecycle.Event.ON_RESUME); &#125;..................... @Override public void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won't leak reference to an activity mProcessListener = null; &#125; private void dispatch(Lifecycle.Event event) &#123; Activity activity = getActivity(); if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125; &#125;&#125; 这个代码就比较清晰了：在activity上面挂了一个ReportFragment专门用来感应activity的生命周期，把activity的生命周期分发给activity里面的Lifecycle,其中activity里面的Lifecycle是一个LifecycleRegistry对象。通过这种方式就完成了activity生命周期到Lifecycle的转发。 到这里大家可能会有一个疑问了：那么fragment的生命周期是怎么感应的呢？因为fragment的生命周期是可能比activity的生命周期要短的，这个我们从fragment源码中寻找答案： 123456789101112131415void performStart() &#123; .......... this.mLifecycleRegistry.handleLifecycleEvent(Event.ON_START); if (this.mView != null) &#123; this.mViewLifecycleRegistry.handleLifecycleEvent(Event.ON_START); &#125; &#125; void performResume() &#123; .............. this.mLifecycleRegistry.handleLifecycleEvent(Event.ON_RESUME); if (this.mView != null) &#123; this.mViewLifecycleRegistry.handleLifecycleEvent(Event.ON_RESUME); &#125; &#125; 可以看出fragment中生命周期是主动转发的，主动调用LifecycleRegistry的方法进行转发。 至此，activity和fragment的生命周期转发机制已经了解清楚了，接下来我们看下LifecycleRegistry是怎么把生命周期进一步转发给LifecycleObserver的。 LifecycleRegistry源码解析上面说了activity和fragment里面都持有LifecycleRegistry,通过这个类来进行生命周期转发，接下来对LifecycleRegistry源码进行解析： 添加观察者：添加观察者通过addObserver方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic void addObserver(@NonNull LifecycleObserver observer) &#123; State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; //把传入的observer封装成一个ObserverWithState对象 ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); //如果之前已经有这个observer，就直接返回 if (previous != null) &#123; return; &#125; //获取到LifecycleOwner LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; /**是否是可重入的，什么意思呢？这里有两个判断条件： 1、mAddingObserverCounter ！=0，什么时候会满足这个条件呢，就是在下面的statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));方法里面可能又会调用addObserver,这次addObserver的时候这个mAddingObserverCounter就不为0了 2、mHandlingEvent为true代表正在进行状态转移 isReentrance这个值主要是为了防止重复调用sync方法，在嵌套的情况下，保证只有最上层最后调用这个sync方法，这个下面也有注释说明 **/ boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; //计算出目标的State State targetState = calculateTargetState(observer); mAddingObserverCounter++; //如果observer目前呢的state小于要转移的targetState,那么就要进行state转移，比如目前页面的state状态为CREATED,但是oberver.mState初始化的状态是INITIALIZED,那么就要把状态转移到CREATED while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); //upEvent方法就是把state转移到下一个生命周期Event，然后再把这个Event通知给oberver进行分发，然后在这个 //statefulObserver内部会根据这个Event更新自己的mState //这里每次只能进行一个Event转移，就比如说现在页面的state状态为STARTED,那么就需要进行两次转移，也就是这个这个while循环会执行2次，相应的observer会先后收到ON_CREATE和ON_START回调 statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); //再次计算targetState,判断observer.mState是否达到了targetState,这里是一个while循环，直到达到了 //targetState才会退出 targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. //把当前页面的state状态同步给所有的oberver sync(); &#125; mAddingObserverCounter--;&#125; 可以看出addObserver主要是分为几个步骤： 1、把传入的observer封装成一个ObserverWithState对象，保存到一个map里面，key值就是这个observer。我们来看下ObserverWithState的构造方法： 12345678910111213141516static class ObserverWithState &#123; State mState; GenericLifecycleObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; mLifecycleObserver = Lifecycling.getCallback(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; &#125;&#125; 在构造方法里面会通过Lifecycling.getCallback(observer)方法把observer转换为一个GenericLifecycleObserver对象。刚刚上面说了类可以通过向其方法添加注解来监控组件的生命周期状态，这个Lifecycling.getCallback方法里面就是会去读取每个LifecycleObserver对象方法上面的注解，然后转换成对应的GenericLifecycleObserver： 123456789101112131415161718192021222324252627static GenericLifecycleObserver getCallback(Object object) &#123; if (object instanceof FullLifecycleObserver) &#123; return new FullLifecycleObserverAdapter((FullLifecycleObserver) object); &#125; if (object instanceof GenericLifecycleObserver) &#123; return (GenericLifecycleObserver) object; &#125; //根据注解生成对应的GenericLifecycleObserver ，一般不推荐这种方式 final Class&lt;?&gt; klass = object.getClass(); int type = getObserverConstructorType(klass); if (type == GENERATED_CALLBACK) &#123; List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors = sClassToAdapters.get(klass); if (constructors.size() == 1) &#123; GeneratedAdapter generatedAdapter = createGeneratedAdapter( constructors.get(0), object); return new SingleGeneratedAdapterObserver(generatedAdapter); &#125; GeneratedAdapter[] adapters = new GeneratedAdapter[constructors.size()]; for (int i = 0; i &lt; constructors.size(); i++) &#123; adapters[i] = createGeneratedAdapter(constructors.get(i), object); &#125; return new CompositeGeneratedAdaptersObserver(adapters); &#125; return new ReflectiveGenericLifecycleObserver(object);&#125; 从上面代码也可以看出我们可以让我们自定义的LifecycleObserver直接实现FullLifecycleObserver或者GenericLifecycleObserver接口，如果没有实现这两个接口，继续往下走的话就是注解相关处理，然后包装生成对应的GenericLifecycleObserver子类，一般情况下不推荐这种方式，因为涉及到runtime反射，会有一定的性能开销。最佳操作是如果工程支持java8的话，可以实现DefaultLifecycleObserver接口,子类根据自身需求实现对应的方法（不得不说default真是个好东西啊～～）： 1234567891011121314151617181920212223242526public interface DefaultLifecycleObserver extends FullLifecycleObserver &#123; @Override default void onCreate(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onStart(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onResume(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onPause(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onStop(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onDestroy(@NonNull LifecycleOwner owner) &#123; &#125;&#125; ObserverWithState对象封装好了之后，继续往下走： 2、根据当前页面state对observer进行state转移，这里可能会涉及到多次转移 3、把当前页面的state状态同步给所有的oberver 移除观察者移除观察者通过removeObserver方法： 123456789101112131415public void removeObserver(@NonNull LifecycleObserver observer) &#123; // we consciously decided not to send destruction events here in opposition to addObserver. // Our reasons for that: // 1. These events haven't yet happened at all. In contrast to events in addObservers, that // actually occurred but earlier. // 2. There are cases when removeObserver happens as a consequence of some kind of fatal // event. If removeObserver method sends destruction events, then a clean up routine becomes // more cumbersome. More specific example of that is: your LifecycleObserver listens for // a web connection, in the usual routine in OnStop method you report to a server that a // session has just ended and you close the connection. Now let's assume now that you // lost an internet and as a result you removed this observer. If you get destruction // events in removeObserver, you should have a special case in your onStop method that // checks if your web connection died and you shouldn't try to report anything to a server. mObserverMap.remove(observer);&#125; 可以看出removeObserver只做了一件事，就是把observer从map里面移除。 生命周期转发当生命周期发生改变的时候，会调用handleLifecycleEvent方法进行分发，里面调用moveToState方法进行状态转移，同步给所有的observer 12345678910111213141516171819public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next);&#125;private void moveToState(State next) &#123; if (mState == next) &#123; return; &#125; mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) &#123; mNewEventOccurred = true; // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; sync(); mHandlingEvent = false;&#125; 通过以上这3个方法就完成了生命周期-&gt;oberver的转发，实现了生命周期的自动监听实现。 自定义LifecycleOwner如果您有一个自定义类并希望使其成为 LifecycleOwner，您可以使用 LifecycleRegistry 类，但需要将事件转发到该类，如以下代码示例中所示： 1234567891011121314151617181920212223public class MyActivity extends Activity implements LifecycleOwner &#123; private LifecycleRegistry lifecycleRegistry; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); lifecycleRegistry = new LifecycleRegistry(this); lifecycleRegistry.markState(Lifecycle.State.CREATED); &#125; @Override public void onStart() &#123; super.onStart(); lifecycleRegistry.markState(Lifecycle.State.STARTED); &#125; @NonNull @Override public Lifecycle getLifecycle() &#123; return lifecycleRegistry; &#125;&#125; 总结Lifecycle组件实际上就是对activity或者fragment的生命周期进行自动化监听，然后业务方根据自己的需求可以往Lifecycle组件里面在add或者remove监听，就是一种典型的观察者模式，去掉了以往需要直接在acivity和fragment的生命周期方法中显示调用组件对应方法的过程，让组件代码更有条理，也避免了activity和fragment的代码膨胀，提升代码的可维护性。 如果您觉得写的还不错，感谢打赏：","categories":[{"name":"Android架构学习","slug":"Android架构学习","permalink":"http://easyliu.com/categories/Android架构学习/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android Jetpack简介","slug":"android_jetpack/jetpack_intro","date":"2020-10-31T07:31:26.000Z","updated":"2020-10-31T08:29:02.997Z","comments":false,"path":"2020/10/31/android_jetpack/jetpack_intro/","link":"","permalink":"http://easyliu.com/2020/10/31/android_jetpack/jetpack_intro/","excerpt":"","text":"Jetpack简介Jetpack 是一个由多个库组成的套件，可帮助开发者遵循最佳做法，减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者精力集中编写重要的代码。 Jetpack 包含与平台 API 解除捆绑的 androidx.* 软件包库。这意味着，它可以提供向后兼容性，且比 Android 平台的更新频率更高，以此确保您始终可以获取最新且最好的 Jetpack 组件版本。 优势加速开发组件可以单独采用（不过这些组件是为协同工作而构建的），同时利用 Kotlin 语言功能帮助您提高工作效率。 消除样板代码Android Jetpack 可管理繁琐的 Activity（如后台任务、导航和生命周期管理），以便您可以专注于如何让您的应用出类拔萃。 构建高质量的强大应用Android Jetpack 组件围绕现代化设计实践构建而成，具有向后兼容性，可以减少崩溃和内存泄漏。 以下是jetpack包含的内容： jetpack文档 jetpack视频介绍 Jetpack架构组件设计思路应用架构指南 基于移动应用用户体验在大多数情况下，桌面应用会在桌面或程序启动器中有一个入口点，且作为一个单体式进程运行。Android 应用则不然，它们的结构要复杂得多。典型的 Android 应用包含多个应用组件，包括 Activity、Fragment、Service、内容提供程序和广播接收器。 您需要在应用清单中声明其中的大多数应用组件。Android 操作系统随后会使用此文件来决定如何将您的应用集成到设备的整体用户体验中。鉴于正确编写的 Android 应用包含多个组件，并且用户经常会在短时间内与多个应用进行互动，因此应用需要适应不同类型的用户驱动型工作流和任务。 例如，思考一下当您在自己喜欢的社交网络应用中分享照片时会发生什么： 该应用将触发相机 intent。Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交网络应用，但他们的体验仍然是无缝的。 相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用。 最后，用户返回社交网络应用并分享照片。 在此过程中，用户随时可能会被电话或通知打断。处理之后，用户希望能够返回并继续分享照片。这种应用跳跃行为在移动设备上很常见，因此您的应用必须正确处理这些流程。 请注意，移动设备的资源也很有限，因此操作系统可能会随时终止某些应用进程，以便为新的进程腾出空间。 鉴于这种环境条件，您的应用组件可以不按顺序地单独启动，并且操作系统或用户可以随时销毁它们。由于这些事件不受您的控制，因此您不应在应用组件中存储任何应用数据或状态，并且应用组件不应相互依赖。 常见的架构原则如果您不应使用应用组件存储应用数据和状态，那么您应该如何设计应用呢？ 关注分离点要遵循的最重要的原则是分离关注点。一种常见的错误是在一个 Activity 或 Fragment 中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。您应使这些类尽可能保持精简，这样可以避免许多与生命周期相关的问题。 请注意，您并非拥有 Activity 和 Fragment 的实现；它们只是表示 Android 操作系统与应用之间关系的粘合类。操作系统可能会根据用户互动或因内存不足等系统条件随时销毁它们。为了提供令人满意的用户体验和更易于管理的应用维护体验，您最好尽量减少对它们的依赖。 通过模型驱动界面另一个重要原则是您应该通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。它们独立于应用中的 View 对象和应用组件，因此不受应用的生命周期以及相关的关注点的影响。 持久性是理想之选，原因如下： 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据。 当网络连接不稳定或不可用时，应用会继续工作。 应用所基于的模型类应明确定义数据管理职责，这样将使应用更可测试且更一致。 基于以上讨论就演变出来了如何使用Jetpack架构组件构建应用，如下所示： 请注意，每个组件仅依赖于其下一级的组件。例如，Activity 和 Fragment 仅依赖于视图模型。存储区是唯一依赖于其他多个类的类；在本例中，存储区依赖于持久性数据模型和远程后端数据源。 这种设计打造了一致且愉快的用户体验。无论用户上次使用应用是在几分钟前还是几天之前，现在回到应用时都会立即看到应用在本地保留的用户信息。如果此数据已过时，则应用的存储区模块将开始在后台更新数据。 Jetpack架构组件介绍Jetpack架构组件 Android 架构组件是一组库，可帮助您设计稳健、可测试且易维护的应用。您可以从管理界面组件生命周期和处理数据持久性的类着手。 通过应用架构指南，学习有关汇编稳健应用的基础知识。 管理应用的生命周期。新的生命周期感知型组件可帮助您管理 Activity 和 Fragment 的生命周期。在配置更改后继续有效、避免内存泄漏，以及轻松加载数据到界面中。 使用 LiveData 构建数据对象，在基础数据库改变时通知视图。 ViewModel 存储界面相关的数据，这些数据不会在应用轮转时销毁。 Room 是一个 SQLite 对象映射库。它可用来避免样板代码，并轻松地将 SQLite 表数据转换为 Java 对象。Room 提供 SQLite 语句的编译时检查，并且可以返回 RxJava、Flowable 和 LiveData 可观察对象。 以上就是对Jetpack组件的介绍，接下来会对Jetpack里面的架构组件进行剖析讲解。","categories":[{"name":"Android架构学习","slug":"Android架构学习","permalink":"http://easyliu.com/categories/Android架构学习/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"android组件化","slug":"android_architecture/component","date":"2020-09-19T16:21:14.000Z","updated":"2020-09-19T16:24:08.454Z","comments":false,"path":"2020/09/20/android_architecture/component/","link":"","permalink":"http://easyliu.com/2020/09/20/android_architecture/component/","excerpt":"","text":"学习资料Android彻底组件化demo发布 知乎 Android 客户端组件化实践 微信Android模块化架构重构实践 中心思想1、代码解耦。如何将一个庞大的工程拆分成有机的整体？2、组件单独运行。每个组件都是一个完整的整体，如何让其单独运行和调试呢？3、数据传递。因为每个组件都会给其他组件提供的服务，那么主项目（Host）与组件、组件与组件之间如何传递数据？4、UI跳转。UI跳转可以认为是一种特殊的数据传递，在实现思路上有啥不同？5、组件的生命周期。我们的目标是可以做到对组件可以按需、动态的使用，因此就会涉及到组件加载、卸载和降维的生命周期。6、集成调试。在开发阶段如何做到按需的编译组件？一次调试中可能只有一两个组件参与集成，这样编译的时间就会大大降低，提高开发效率。7、代码隔离。组件之间的交互如果还是直接引用的话，那么组件之间根本没有做到解耦，如何从根本上避免组件之间的直接引用呢？也就是如何从根本上杜绝耦合的产生呢？只有做到这一点才是彻底的组件化。","categories":[{"name":"Android架构学习","slug":"Android架构学习","permalink":"http://easyliu.com/categories/Android架构学习/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"2020.9-2020.12学习计划","slug":"study_plan/2020.9-2020.12","date":"2020-09-19T16:06:37.000Z","updated":"2020-12-07T13:51:04.598Z","comments":false,"path":"2020/09/20/study_plan/2020.9-2020.12/","link":"","permalink":"http://easyliu.com/2020/09/20/study_plan/2020.9-2020.12/","excerpt":"","text":"学习计划 执行情况组件化 已完成MVVM 已完成热修复与插件化 大致看了一下源码，还没有具体细看编译插桩技术 还没开始学习","categories":[{"name":"学习计划","slug":"学习计划","permalink":"http://easyliu.com/categories/学习计划/"}],"tags":[{"name":"学习计划","slug":"学习计划","permalink":"http://easyliu.com/tags/学习计划/"}]},{"title":"学习路线","slug":"android/StudyPlan","date":"2020-09-18T03:38:59.000Z","updated":"2020-09-19T05:45:17.020Z","comments":false,"path":"2020/09/18/android/StudyPlan/","link":"","permalink":"http://easyliu.com/2020/09/18/android/StudyPlan/","excerpt":"","text":"学习路线图","categories":[{"name":"学习计划","slug":"学习计划","permalink":"http://easyliu.com/categories/学习计划/"}],"tags":[{"name":"学习计划","slug":"学习计划","permalink":"http://easyliu.com/tags/学习计划/"}]},{"title":"4、linkedList","slug":"algorithm/linkedList","date":"2020-07-12T06:49:39.000Z","updated":"2020-07-18T10:02:34.864Z","comments":false,"path":"2020/07/12/algorithm/linkedList/","link":"","permalink":"http://easyliu.com/2020/07/12/algorithm/linkedList/","excerpt":"","text":"链表结构体定义123456789101112131415161718192021222324252627public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; ListNode listNode = (ListNode) o; boolean valueEqual = val == listNode.val; boolean nextEqual = (next == null &amp;&amp; listNode.next == null) || (next != null &amp;&amp; next.equals(listNode.next)); return valueEqual &amp;&amp; nextEqual; &#125; @Override public int hashCode() &#123; return Objects.hash(val, next); &#125;&#125; 链表相关操作创建链表123456789101112131415161718192021/** * 创建链表 */public static ListNode createList(int[] arrays) &#123; if (arrays == null || arrays.length &lt;= 0) &#123; return null; &#125; ListNode head = null; ListNode cur = null; for (int val : arrays) &#123; ListNode newNode = new ListNode(val); if (head == null) &#123; head = newNode; cur = head; &#125; else &#123; cur.next = newNode; cur = cur.next; &#125; &#125; return head;&#125; 找到链表的最后一个节点12345678910111213/** * 找到最后一个节点 */public static ListNode findLastNode(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode lastNode = head; while (lastNode.next != null) &#123; lastNode = lastNode.next; &#125; return lastNode;&#125; 删除一个节点12345678910111213141516171819202122232425/** * 删除一个节点 */public static ListNode deleteNode(ListNode head, ListNode toDelete) &#123; if (toDelete == null || head == null) &#123; return null; &#125; ListNode tmp; if (head.val == toDelete.val) &#123; tmp = head; head = head.next; tmp.next = null; return head; &#125; ListNode cur = head; while (cur != null &amp;&amp; cur.next != null) &#123; if (cur.next.val == toDelete.val) &#123; tmp = cur.next; cur.next = cur.next.next; tmp.next = null; &#125; cur = cur.next; &#125; return head;&#125; 插入链表123456789101112131415161718192021222324252627/** * 插入一个节点或者链表 */public static ListNode insertNode(ListNode head, ListNode toInsert, int pos) &#123; if (pos &lt; 0 || head == null || toInsert == null) &#123; return head; &#125; int count = 0; ListNode curNode = head; if (pos &gt; 0) &#123; while (curNode.next != null) &#123; curNode = curNode.next; count++; if (count == pos) &#123; break; &#125; &#125; &#125; if (count == pos) &#123; ListNode tmp = curNode.next; curNode.next = toInsert; //找到insertNode的最后一个节点指向tmp ListNode lastNodeOfInsertNode = findLastNode(toInsert); lastNodeOfInsertNode.next = tmp; &#125; return head;&#125; 反转链表使用stack实现1234567891011121314151617181920212223/** * 反转链表，使用stack实现 */public static ListNode reverseListWithStack(ListNode head) &#123; if (head == null) &#123; return null; &#125; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); stack.push(head); while (head.next != null) &#123; stack.push(head.next); head.next = head.next.next; &#125; ListNode newHead = stack.pop(); ListNode pNode = newHead; while (!stack.isEmpty()) &#123; ListNode curNode = stack.pop(); pNode.next = curNode; pNode = curNode; &#125; pNode.next = null; return newHead;&#125; 使用双向指针实现1234567891011121314/** * 反转链表，使用双指针实现 */public static ListNode reverseListWithDoublePointer(ListNode head) &#123; ListNode tmp; ListNode pre = null; while (head != null) &#123; tmp = head.next; head.next = pre; pre = head; head = tmp; &#125; return pre;&#125; 单元测试删除节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.easyliu.test.linklist;import org.junit.Assert;import org.junit.Test;public class DeleteNodeTest &#123; /** * 自测用例： * 1、head为null * 2、要删除的节点为null * 3、删除头部的节点 * 4、删除尾部的节点 * 5、删除中间节点 * 6、有多个val一样的节点，删除第一个相等的节点 */ @Test public void testNullHead() &#123; //arrange //act ListNode result = ListOperate.deleteNode(null, null); //verify Assert.assertNull(result); &#125; @Test public void testNulToDeleteNode() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2&#125;); //act ListNode result = ListOperate.deleteNode(listNode, null); //verify Assert.assertNull(result); &#125; @Test public void testDeleteHeadNode() &#123; //arrange ListNode head = ListOperate.createList(new int[]&#123;1, 2&#125;); ListNode toDeleteNode = ListOperate.createList(new int[]&#123;1&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;2&#125;); //act ListNode result = ListOperate.deleteNode(head, toDeleteNode); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testDeleteTailNode() &#123; //arrange ListNode head = ListOperate.createList(new int[]&#123;1, 2&#125;); ListNode toDeleteNode = ListOperate.createList(new int[]&#123;2&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1&#125;); //act ListNode result = ListOperate.deleteNode(head, toDeleteNode); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testDeleteMiddleNode() &#123; //arrange ListNode head = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); ListNode toDeleteNode = ListOperate.createList(new int[]&#123;2&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 3&#125;); //act ListNode result = ListOperate.deleteNode(head, toDeleteNode); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testDeleteRepeatNode() &#123; //arrange ListNode head = ListOperate.createList(new int[]&#123;1, 2, 2, 3&#125;); ListNode toDeleteNode = ListOperate.createList(new int[]&#123;2&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); //act ListNode result = ListOperate.deleteNode(head, toDeleteNode); //verify Assert.assertEquals(expectList, result); &#125;&#125; 插入节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.easyliu.test.linklist;import org.junit.Assert;import org.junit.Test;public class InsertNodeTest &#123; /** * 自测用例 * 1、pos小于0 * 2、head为null * 3、toInsertNode为null * 4、pos=0 * 5、pos为size-1 * 6、pos&gt;0&amp;&amp;pos&lt;size-1 * 7、toInsert有多个节点 */ @Test public void testNullHead() &#123; //arrange //act ListNode result = ListOperate.insertNode(null, null, 0); //verify Assert.assertNull(result); &#125; @Test public void testNegativePos() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); //act ListNode result = ListOperate.insertNode(listNode, null, -1); //verify Assert.assertEquals(listNode, result); &#125; @Test public void testNullInsertNode() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); //act ListNode result = ListOperate.insertNode(listNode, null, 0); //verify Assert.assertEquals(listNode, result); &#125; @Test public void testZeroPos() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); ListNode insertNode = ListOperate.createList(new int[]&#123;1&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 1, 2, 3&#125;); //act ListNode result = ListOperate.insertNode(listNode, insertNode, 0); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testMaxPos() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); ListNode insertNode = ListOperate.createList(new int[]&#123;1&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 2, 3, 1&#125;); //act ListNode result = ListOperate.insertNode(listNode, insertNode, 2); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testMiddlePos() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); ListNode insertNode = ListOperate.createList(new int[]&#123;1&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 2, 1, 3&#125;); //act ListNode result = ListOperate.insertNode(listNode, insertNode, 1); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testMultiNodeOfInsert() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); ListNode insertNode = ListOperate.createList(new int[]&#123;5, 6, 7, 8&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 2, 5, 6, 7, 8, 3&#125;); //act ListNode result = ListOperate.insertNode(listNode, insertNode, 1); //verify Assert.assertEquals(expectList, result); &#125;&#125; 反转链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.easyliu.test.linklist;import org.junit.Assert;import org.junit.Test;public class ReverseListTest &#123; @Test public void testNullInput() &#123; //arrange ListNode head = null; //act ListNode result = ListOperate.reverseListWithStack(head); ListNode doubleResult = ListOperate.reverseListWithDoublePointer(head); //verify Assert.assertNull(result); Assert.assertNull(doubleResult); &#125; @Test public void testSingleNodeNormal() &#123; //arrange ListNode listOne = ListOperate.createList(new int[]&#123;1&#125;); ListNode listTwo = ListOperate.createList(new int[]&#123;1&#125;); //act ListNode result = ListOperate.reverseListWithStack(listOne); ListNode doubleResult = ListOperate.reverseListWithDoublePointer(listTwo); //verify ListNode expect = ListOperate.createList(new int[]&#123;1&#125;); Assert.assertEquals(expect, result); Assert.assertEquals(expect, doubleResult); &#125; @Test public void testNormal() &#123; //arrange ListNode listOne = ListOperate.createList(new int[]&#123;1, 2, 3, 4, 5&#125;); ListNode listTwo = ListOperate.createList(new int[]&#123;1, 2, 3, 4, 5&#125;); //act ListNode result = ListOperate.reverseListWithStack(listOne); ListNode doubleResult = ListOperate.reverseListWithDoublePointer(listTwo); //verify ListNode expect = ListOperate.createList(new int[]&#123;5, 4, 3, 2, 1&#125;); Assert.assertEquals(expect, result); Assert.assertEquals(expect, doubleResult); &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://easyliu.com/categories/刷题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"3、SecondArrayFind","slug":"algorithm/SecondArrayFind","date":"2020-06-18T03:40:08.000Z","updated":"2020-07-12T07:02:12.659Z","comments":false,"path":"2020/06/18/algorithm/SecondArrayFind/","link":"","permalink":"http://easyliu.com/2020/06/18/algorithm/SecondArrayFind/","excerpt":"","text":"题目在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 输入int[][] inputArray = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };int target = 6; 输出true 实现1234567891011121314151617181920212223242526public class SecondArrayFind &#123; public static boolean secondArrayFindTarget(final int[][] inputArray, final int target) &#123; if (inputArray == null) &#123; return false; &#125; if (inputArray[0] == null) &#123; return false; &#125; int rowSize = inputArray.length; int columnSize = inputArray[0].length; int row = 0; int column = columnSize - 1; while (column &gt;= 0 &amp;&amp; row &lt; rowSize) &#123; int curValue = inputArray[row][column]; if (curValue &lt; target) &#123; row++; &#125; else if (curValue &gt; target) &#123; column--; &#125; else &#123; break; &#125; &#125; return column &gt;= 0 &amp;&amp; row &lt; rowSize; &#125;&#125; 单元测试123456789101112131415161718192021public class SecondArrayFindTest &#123; @Test public void testNullInput() &#123; Assert.assertFalse(SecondArrayFind.secondArrayFindTarget(null, 100)); &#125; @Test public void testNormalFound() &#123; int[][] inputArray = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; int target = 6; Assert.assertTrue(SecondArrayFind.secondArrayFindTarget(inputArray, target)); &#125; @Test public void testNormalNotFound() &#123; int[][] inputArray = &#123;&#123;1, 2, 3&#125;, &#123;6, 7, 8&#125;, &#123;7, 8, 9&#125;&#125;; int target = 5; Assert.assertFalse(SecondArrayFind.secondArrayFindTarget(inputArray, target)); &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://easyliu.com/categories/刷题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"2、findFirstOneTimeChar","slug":"algorithm/findFirstOneTimeChar","date":"2020-06-10T03:00:22.000Z","updated":"2020-07-12T07:01:57.441Z","comments":false,"path":"2020/06/10/algorithm/findFirstOneTimeChar/","link":"","permalink":"http://easyliu.com/2020/06/10/algorithm/findFirstOneTimeChar/","excerpt":"","text":"题目请实现一个函数，输入一个字符串，找出第一个只出现一次的字符。 输入“asdfasdfo” 输出‘o’ 实现12345678910111213141516public static char findFirstOneTimeChar(String input) &#123; if (input == null || input.length() &lt;= 0) &#123; return 0; &#125; char[] chars = input.toCharArray(); final int[] numArray = new int[256]; for (char curChar : chars) &#123; numArray[curChar]++; &#125; for (char curChar : chars) &#123; if (numArray[curChar] == 1) &#123; return curChar; &#125; &#125; return 0;&#125; 单元测试12345678910111213141516171819202122232425public class FindFirstOneTimeCharTest &#123; @Test public void testNulInput() &#123; Assert.assertEquals(FindFirstOneTimeChar.findFirstOneTimeChar(null), 0); &#125; @Test public void testEmptyInput() &#123; Assert.assertEquals(FindFirstOneTimeChar.findFirstOneTimeChar(\"\"), 0); &#125; @Test public void testSpaceInput() &#123; Assert.assertEquals(FindFirstOneTimeChar.findFirstOneTimeChar(\" \"), ' '); &#125; @Test public void testNormalInput() &#123; String input = \"asdfasdfo\"; char expect = 'o'; char result = FindFirstOneTimeChar.findFirstOneTimeChar(input); Assert.assertEquals(expect, result); &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://easyliu.com/categories/刷题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"1、replaceSpace","slug":"algorithm/repalceSpace","date":"2020-06-07T07:37:57.000Z","updated":"2020-07-12T07:01:48.844Z","comments":false,"path":"2020/06/07/algorithm/repalceSpace/","link":"","permalink":"http://easyliu.com/2020/06/07/algorithm/repalceSpace/","excerpt":"","text":"题目请实现一个函数，把字符串中的每个空格替换为”%20”。 输入“We are happy” 输出“We%20are%20happy” 实现1234567891011121314151617181920212223242526272829 public static String replaceSpace(String input) &#123; if (input == null) &#123; return null; &#125; if (\"\".equals(input)) &#123; return null; &#125; //计算空格的个数 char[] chars = input.toCharArray(); int numOfSpace = 0; for (char curChar : chars) &#123; if (curChar == ' ') &#123; numOfSpace++; &#125; &#125; //创建一个新的字符数组 char[] newChars = new char[chars.length + numOfSpace * 2]; int indexOfNewChar = -1; for (char curChar : chars) &#123; if (curChar != ' ') &#123; newChars[++indexOfNewChar] = curChar; &#125; else &#123; newChars[++indexOfNewChar] = '%'; newChars[++indexOfNewChar] = '2'; newChars[++indexOfNewChar] = '0'; &#125; &#125; return String.valueOf(newChars);&#125; 单元测试123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.easyliu.test.replace_space;import org.junit.Assert;import org.junit.Test;public class ReplaceSpaceTest &#123; @Test public void testNullInput() &#123; Assert.assertNull(ReplaceSpace.replaceSpace(null)); &#125; @Test public void testEmptyInput() &#123; Assert.assertNull(ReplaceSpace.replaceSpace(\"\")); &#125; @Test public void testNormalSpace() &#123; String expect = \"we%20are%20happy\"; String result = ReplaceSpace.replaceSpace(\"we are happy\"); Assert.assertEquals(expect, result); &#125; @Test public void testMultiSpace() &#123; String expect = \"we%20%20are%20%20happy\"; String result = ReplaceSpace.replaceSpace(\"we are happy\"); Assert.assertEquals(expect, result); &#125; @Test public void testSingleSpace() &#123; String expect = \"%20\"; String result = ReplaceSpace.replaceSpace(\" \"); Assert.assertEquals(expect, result); &#125; @Test public void testNoSpace() &#123; String expect = \"we\"; String result = ReplaceSpace.replaceSpace(\"we\"); Assert.assertEquals(expect, result); &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://easyliu.com/categories/刷题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"Android studio 快捷键","slug":"android/as_shortcut","date":"2020-05-30T03:38:43.000Z","updated":"2020-05-30T04:33:49.100Z","comments":false,"path":"2020/05/30/android/as_shortcut/","link":"","permalink":"http://easyliu.com/2020/05/30/android/as_shortcut/","excerpt":"","text":"重构快捷键shift+alt+M 选中抽取方法ctrl+alt+c 抽取常量","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://easyliu.com/categories/开发工具/"}],"tags":[{"name":"android","slug":"android","permalink":"http://easyliu.com/tags/android/"}]},{"title":"java代码规范","slug":"code/java_code_style","date":"2020-05-26T13:31:58.000Z","updated":"2020-05-30T04:27:58.837Z","comments":false,"path":"2020/05/26/code/java_code_style/","link":"","permalink":"http://easyliu.com/2020/05/26/code/java_code_style/","excerpt":"","text":"1、减少嵌套层级，提前返回2、一行不大于100个字符3、函数参数个数不宜过多，太多了考虑抽象成类4、private成员变量以m为前缀5、常量为全大写，以下划线拼接6、静态成员变量以s为前缀7、单个函数行数不宜过多，超过20 line就考虑抽取函数8、经常进行重构9、时常考虑抽象、封装、多态10、命名规则：精简但能清楚表达语义11、写函数的时候从方便单测的角度进行考虑，进行单测覆盖","categories":[{"name":"代码规范","slug":"代码规范","permalink":"http://easyliu.com/categories/代码规范/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"http://easyliu.com/tags/代码规范/"}]},{"title":"xcode快捷键","slug":"ios/xcode_shortcut","date":"2020-05-17T09:34:22.000Z","updated":"2020-05-30T05:15:02.829Z","comments":false,"path":"2020/05/17/ios/xcode_shortcut/","link":"","permalink":"http://easyliu.com/2020/05/17/ios/xcode_shortcut/","excerpt":"","text":"1、cmd+shift+j 在左边文件管理区定位到当前文件 2、cmd+shift+o 快速查找某个类，对应Android studio开发的话是shift+shift 3、ctrl+cmd+往左箭头或者往右箭头 光标返回到上一个选中的位置或者下一个选中的位置","categories":[{"name":"ios开发","slug":"ios开发","permalink":"http://easyliu.com/categories/ios开发/"}],"tags":[{"name":"ios开发","slug":"ios开发","permalink":"http://easyliu.com/tags/ios开发/"}]},{"title":"PowerMockIo单元测试基础语法","slug":"unit_test/unit_test","date":"2020-05-17T09:05:17.000Z","updated":"2020-05-17T09:14:52.356Z","comments":true,"path":"2020/05/17/unit_test/unit_test/","link":"","permalink":"http://easyliu.com/2020/05/17/unit_test/unit_test/","excerpt":"","text":"1、使用verifyPrivate来验证私有方法被调用//arrangeSeeVideoBoardTopStartVM fakeVm = PowerMockito.mock(SeeVideoBoardTopStartVM.class);Whitebox.setInternalState(mTestVm, “mSeeVideoBoardTopVM”, fakeVm);//actWhitebox.invokeMethod(mTestVm, “resetPlayer”);//assertPowerMockito.verifyPrivate(mTestVm).invoke(“setPlayStatus”, IUpdatePlayStatus.BEFORE);PowerMockito.verifyPrivate(fakeVm).invoke(“onUnbindView”); 2、PowerMockIo来mock静态方法：PowerMockito.mockStatic(AdaptiveUI.class);PowerMockito.when(AdaptiveUI.getCurUISizeType(Mockito.any(Context.class))).thenReturn(UISizeType.REGULAR); 3、调用private方法boolean result = Whitebox.invokeMethod(mBasePBSectionController, MOCK_METHOD, section);Assert.assertFalse(result); 4、模拟私有方法PowerMockito.when(mockPrivateClass, “privateFunc”).thenReturn(“test”); 5、mock公有方法PowerMockito.when(mTestVm.getTextViewWidth()).thenReturn(FAKE_TEXT_WIDTH); 6、设置私有成员变量Whitebox.setInternalState(mTestVm, “mSeeVideoBoardTopVM”, fakeVm); 7、当你需要使用PowerMock强大功能（Mock静态、final、私有方法等）的时候，就需要加注解@PrepareForTest8、如果一个对象，只希望mock它的部分方法，而其他方法希望和真实对象的行为一眼，可以使用PowerMockito.spy(Class clazz)代替PowerMockito.mock(Class clazz)方法，其后的设置依旧，这时，没有通过when设置过的方法，测试调用时，行为和真实对象一样","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://easyliu.com/categories/单元测试/"}],"tags":[{"name":"单元测试","slug":"单元测试","permalink":"http://easyliu.com/tags/单元测试/"}]},{"title":"Gradle基础之Grovy语法","slug":"android/Gradle基础之Grovy语法","date":"2018-02-11T15:56:14.000Z","updated":"2018-02-11T16:37:38.000Z","comments":true,"path":"2018/02/11/android/Gradle基础之Grovy语法/","link":"","permalink":"http://easyliu.com/2018/02/11/android/Gradle基础之Grovy语法/","excerpt":"","text":"Gradle基础之Groovy语法在使用Android Studio开发app的过程中，都会接触到Gradle配置，而Gradle的配置是基于Grovvy语法的。因此，要想熟练的使用Gradle进行配置，就必须熟悉Groovy语法，下面开始讲解下Groovy的基本语法。 Groovy可以看作是java的加强版，扩展了java的语法，拥有自己的一些特性。 Groovy语法官方文档 注释单行注释单行注释如下所示，跟java一样： 12// a standalone single line commentprintln \"hello\" // a comment till the end of the line 多行注释多行注释如下所示，跟java一样： 12345/* a standalone multiline comment spanning two lines */println \"hello\" /* a multiline comment starting at the end of a statement */println 1 /* one */ + 2 /* two */ GroovyDoc 注释GroovyDoc跟javaDoc语法也是一样的，如下所示： 1234567891011121314151617/** * A Class description */class Person &#123; /** the name of the person */ String name /** * Creates a greeting method for a certain person. * * @param otherPerson the person to greet * @return a greeting message */ String greet(String otherPerson) &#123; \"Hello $&#123;otherPerson&#125;\" &#125;&#125; Shebang line除了单行注释，还有一种特殊的单行注释，如下所示，叫做Shebang line（各位可以自行去翻译）。这行注释主要是便于unix理解，有了这行注释就可以直接在命令行运行groovy脚本文件啦。当然前提是电脑上要安装了Groovy，且要把Groovy加入path环境变量，注意这种注释中#必须是第一个字符，否则会报编译错误。 12#!/usr/bin/env groovyprintln \"Hello from the shebang line\" Groovy关键字Groovy语法的关键字如下所示： as assert break finally implements new switch trait case catch class false import null符号 switch true const continue def for in package this try default do else goto instanceof return throw while enum enum extends if interface super throws ### 标识符 #### 正常的标识符 标识符可以由字母、美元符号以及下划线开头，不能以数字开头。 字符的范围如下： * ‘a’ to ‘z’ (lowercase ascii letter) * ‘A’ to ‘Z’ (uppercase ascii letter) * ‘\\u00C0’ to ‘\\u00D6’ * ‘\\u00D8’ to ‘\\u00F6’ * ‘\\u00F8’ to ‘\\u00FF’ * ‘\\u0100’ to ‘\\uFFFE’ 如下为有效的标识符： 1234def namedef item3def with_underscoredef $dollarStart 如下的标识符就是非法的： 123def 3tierdef a+bdef a#b 所有的关键字如果跟在一个dot后面也都是合法的标识符： 12345foo.asfoo.assertfoo.breakfoo.casefoo.catch 引用标识符引用标识符出现在一个打点运算符之后，如下所示： 123456def map= [:]map.\"an identifier with a space and double quotes\" = \"ALLOWED\"map.'with-dash-signs-and-single-quotes' = \"ALLOWED\"assert map.\"an identifier with a space and double quotes\" == \"ALLOWED\"assert map.'with-dash-signs-and-single-quotes' == \"ALLOWED\" Groovy允许多种类型的字符串，后面会讲到。这些字符串都可以出现在打点运算符之后，如下所示： 123456map.'single quote'map.\"double quote\"map.'''triple single quote'''map.\"\"\"triple double quote\"\"\"map./slashy string/map.$/dollar slashy string/$ 有一种特殊的Groovy GStrings，也叫做插值字符串，如下所示： 123def firstname = \"Homer\"map.\"Simpson-$&#123;firstname&#125;\" = \"Homer Simpson\" //被插值为Simpson-Homerassert map.'Simpson-Homer' == \"Homer Simpson\" 字符串Groovy支持两种字符串，一种是java原生的java.lang.String，一种是groovy.lang.GString，叫做插值字符串。 单引号字符串单引号字符串就是java.lang.String，不支持插值，如下所示： 1'a single quoted string' 字符串连接所有的Groovy字符串均支持+操作，如下所示： 1assert 'ab' == 'a' + 'b' 三单引号字符串三单引号字符串如下所示： 1'''a triple single quoted string''' 三单引号支持多行，也是java.lang.String类型，不支持插值，如下所示： 1234567891011121314151617def aMultilineString = '''line oneline twoline three'''def startingAndEndingWithANewline = '''line oneline twoline three'''def strippedFirstNewline = '''\\line oneline twoline three'''assert !strippedFirstNewline.startsWith('\\n') 转义特殊字符可以使用反斜杠字符转义单引号字符，这样就可以避免字符串的终止： 1'an escaped single quote: \\' needs a backslash' 可以使用双重反斜杠转义反斜杠，如下所示： 1'an escaped escape character: \\\\ needs a double backslash' 如下所示为转义字符对照表： Unicode转义序列对于键盘上没有出现的字符，可以使用一个反斜杠+’u’+四个十六进制数字表示。例如欧元符号可以使用一下方式表示： 1'The Euro currency symbol: \\u20AC' 双引用字符串双引用字符串如下所示： 1\"a double quoted string\" 对于双引用字符串来说，如果其中没有插值表达式那就是java.lang.String类型，否则就是groovy.lang.GString类型。 字符串插值在Groovy所有的字符串字面量表示中，除了单引用和三引用字符串，其他的均支持插值。所谓字符串插值：就是将占位表达式的值替换到字符串中相应的位置当中，如下所示： 1234def name = 'Guillaume' // a plain stringdef greeting = \"Hello $&#123;name&#125;\" //把name插入到greeting当中assert greeting.toString() == 'Hello Guillaume' 还支持算数运算符： 12def sum = \"The sum of 2 and 3 equals $&#123;2 + 3&#125;\"assert sum.toString() == 'The sum of 2 and 3 equals 5' 在${}当中还支持表达式，如下所示： 1\"The sum of 1 and 2 is equal to $&#123;def a = 1; def b = 2; a + b&#125;\" 还支持$占位符，当使用点号表达式时： 12def person = [name: 'Guillaume', age: 36]assert \"$person.name is $person.age years old\" == 'Guillaume is 36 years old' 如下是非法的，会抛出groovy.lang.MissingPropertyException异常，因为系统会认为你在获取一个number的toString属性，从而报错。 1234def number = 3.14shouldFail(MissingPropertyException) &#123; println \"$number.toString()\"&#125; 如果你想去掉GString中的插值，只需要一个反斜杠即可： 1assert '$&#123;name&#125;' == \"\\$&#123;name&#125;\" //\"\\$&#123;name&#125;\"就和普通的'$&#123;name&#125;'相等了，因为去掉了插值 插值闭包表达式插值占位符还支持闭包表达式，如下所示： 12345def sParameterLessClosure = \"1 + 2 == $&#123;-&gt; 3&#125;\" //这个闭包表达式没有参数assert sParameterLessClosure == '1 + 2 == 3'def sOneParamClosure = \"1 + 2 == $&#123; w -&gt; w &lt;&lt; 3&#125;\" //这个闭包表达式有一个java.io.StringWriter类型的参数assert sOneParamClosure == '1 + 2 == 3' 闭包的一个最大的好处是惰性求值lazy evaluation，如下所示： 12345678910def number = 1def eagerGString = \"value == $&#123;number&#125;\"def lazyGString = \"value == $&#123; -&gt; number &#125;\"assert eagerGString == \"value == 1\"assert lazyGString == \"value == 1\"number = 2assert eagerGString == \"value == 1\" //eagerGString的值已经被固定了assert lazyGString == \"value == 2\" //lazyGString的值被重新计算 和java进行交互当一个方法需要java.lang.String参数，传入的却是一个GString类型的参数，这个参数的toString()方法就会被自动调用，看起来像我们可以直接将一个GString赋值给一个String变量一样： 1234567891011String takeString(String message) &#123; assert message instanceof String return message&#125;def message = \"The message is $&#123;'hello'&#125;\" assert message instanceof GString def result = takeString(message) assert result instanceof Stringassert result == 'The message is hello' GString和String的hashCodeGString和String的hashCode是不一样的，即便他们的最终结果是一样： 1assert \"one: $&#123;1&#125;\".hashCode() != \"one: 1\".hashCode() 因此在Map当中不能不能使用GString作为Key值，如下所示： 1234defkey= \"a\"def m = [\"$&#123;key&#125;\": \"letter $&#123;key&#125;\"] // key类型是一个GStringassert m[\"a\"] == null // 用一个普通String类型的key去取值,会找不到这个key,因此就会取不到值 三双引号字符串三双引号字符串类似于双引号字符串，但是是多行的，因此又类似于三引号字符串： 123456789101112def name = 'Groovy'def template = \"\"\" Dear Mr $&#123;name&#125;, You're the winner of the lottery! Yours sincerly, Dave\"\"\"assert template.toString().contains('Groovy') 斜线字符串除了使用引号来括住字符串，还可以使用/，斜线字符串一般用来定义正则表达式： 12def fooPattern = /.*foo.*/assert fooPattern == '.*foo.*' 只有正斜线需要用反斜线转义： 12def escapeSlash = /The character \\/ is a forward slash/assert escapeSlash == 'The character / is a forward slash' 斜线字符串是多行的： 12def escapeSlash = /The character \\/ is a forward slash/assert escapeSlash == 'The character / is a forward slash' 斜线字符串也可以被插值： 1234defcolor= 'blue'def interpolatedSlashy = /a $&#123;color&#125; car/assert interpolatedSlashy == 'a blue car' 注意：一个空的斜线字符串不能使用两个正斜线表示，因为Groovy会把其理解为注释。因此，下面的断言不会被编译，因为这个是一个非终止的语句： 1assert '' == // 美元斜线字符串这种字符串使用$/开始，使用/$结束，其中的转义字符为$： 123456789101112131415161718192021222324252627def name = \"Guillaume\"def date = \"April, 1st\"def dollarSlashy = $/ Hello $name, today we're $&#123;date&#125;. $ dollar sign $$ escaped dollar sign \\ backslash / forward slash $/ escaped forward slash $$$/ escaped opening dollar slashy $/$$ escaped closing dollar slashy/$assert [ 'Guillaume', 'April, 1st', '$ dollar sign', '$ escaped dollar sign', '\\\\ backslash', '/ forward slash', '/ escaped forward slash', '$/ escaped opening dollar slashy', '/$ escaped closing dollar slashy'].every &#123; dollarSlashy.contains(it) &#125; 字符串总结 字符Groovy当中并没有明确的字符字面量，需要明确指明： 12345678char c1 = 'A'assert c1 instanceof Characterdef c2 = 'B' as charassert c2 instanceof Characterdef c3 = (char)'C'assert c3 instanceof Character 数字Groovy支持不同类型的整型字面量和小数字面量。 整型字面量支持的整型字面量和java是一样的： byte char short int long java.lang.BigInteger 如下所示： 123456789// primitive typesbyte b = 1char c = 2short s = 3int i = 4long l = 5// infinite precisionBigInteger bi = 6 当使用def指明整数字面量时，变量的类型会根据数字的大小自动调整: 123456789101112131415161718def a = 1assert a instanceof Integer// Integer.MAX_VALUEdef b = 2147483647assert b instanceof Integer// Integer.MAX_VALUE + 1def c = 2147483648assert c instanceof Long// Long.MAX_VALUEdef d = 9223372036854775807assert d instanceof Long// Long.MAX_VALUE + 1def e = 9223372036854775808assert e instanceof BigInteger 对于负数也是如此： 123456789101112131415161718def na = -1assert na instanceof Integer// Integer.MIN_VALUEdef nb = -2147483648assert nb instanceof Integer// Integer.MIN_VALUE - 1def nc = -2147483649assert nc instanceof Long// Long.MIN_VALUEdef nd = -9223372036854775808assert nd instanceof Long// Long.MIN_VALUE - 1def ne = -9223372036854775809assert ne instanceof BigInteger 数字的非十进制表示数字可以用二进制、八进制、16进制以及小数表示。数字二进制表示如下，以ob开头： 1234567891011121314151617int xInt = 0b10101111assert xInt == 175short xShort = 0b11001001assert xShort == 201 as shortbyte xByte = 0b11assert xByte == 3 as bytelong xLong = 0b101101101101assert xLong == 2925lBigInteger xBigInteger = 0b111100100001assert xBigInteger == 3873gint xNegativeInt = -0b10101111assert xNegativeInt == -175 数字的八进制表示如下,以0开头： 1234567891011121314151617int xInt = 077assert xInt == 63short xShort = 011assert xShort == 9 as shortbyte xByte = 032assert xByte == 26 as bytelong xLong = 0246assert xLong == 166lBigInteger xBigInteger = 01111assert xBigInteger == 585gint xNegativeInt = -077assert xNegativeInt == -63 数字的16进制表示如下，以0x开头： 1234567891011121314151617181920int xInt = 0x77assert xInt == 119short xShort = 0xaaassert xShort == 170 as shortbyte xByte = 0x3aassert xByte == 58 as bytelong xLong = 0xffffassert xLong == 65535lBigInteger xBigInteger = 0xaaaaassert xBigInteger == 43690gDouble xDouble = new Double('0x1.0p0')assert xDouble == 1.0dint xNegativeInt = -0x77assert xNegativeInt == -119 小数字面量小数字面量也跟java是一样的： float double java.lang.BigDemical 如下所示： 123456// primitive typesfloat f = 1.234double d = 2.345// infinite precisionBigDecimal bd = 3.456 小数还支持科学计数法： 12345assert 1e3 == 1_000.0assert 2E4 == 20_000.0assert 3e+1 == 30.0assert 4E-2 == 0.04assert 5e-1 == 0.5 为了精确的计算小数，groovy选择java.lang.BigDecimal作为其小数类型。此外，float和double也是支持的小数类型，但是这俩类型需要一个显式类型声明、强制类型转换或后缀声明。 12def decimal = 123.456println decimal.getClass() // class java.lang.BigDecimal 字面中的下划线12345678long creditCardNumber = 1234_5678_9012_3456Llong socialSecurityNumbers = 999_99_9999Ldouble monetaryAmount = 12_345_132.12long hexBytes = 0xFF_EC_DE_5Elong hexWords = 0xFFEC_DE5Elong maxLong = 0x7fff_ffff_ffff_ffffLlong alsoMaxLong = 9_223_372_036_854_775_807Llong bytes = 0b11010010_01101001_10010100_10010010 数字类型后缀可以给一个数字加入后缀把其转换为指定类型，如下所示：Type|Suffix—|—BigInteger|G or gLong|L or lInteger|I or iBigDecimal|G or gDouble|D or dFloat|F or f 如下所示： 12345678910111213assert 42I == new Integer('42')assert 42i == new Integer('42') // lowercase i more readableassert 123L == new Long(\"123\") // uppercase L more readableassert 2147483648 == new Long('2147483648') // Long type used, value too large for an Integerassert 456G == new BigInteger('456')assert 456g == new BigInteger('456')assert 123.45 == new BigDecimal('123.45') // default BigDecimal type usedassert 1.200065D == new Double('1.200065')assert 1.234F == new Float('1.234')assert 1.23E23D == new Double('1.23E23')assert 0b1111L.class == Long // binaryassert 0xFFi.class == Integer // hexadecimalassert 034G.class == BigInteger // octal 数学运算以下是数学运算表（除法运算和指数运算例外）： 除法运算如果两个数中其中有一个是float或double类型，那么除法运算/或者/=得到的结果就是double类型，否则就是BigDemical类型。 指数运算运算表如下所示： 12345678910111213141516171819202122232425262728293031323334353637// base and exponent are ints and the result can be represented by an Integerassert 2 ** 3 instanceof Integer // 8assert 10 ** 9 instanceof Integer // 1_000_000_000// the base is a long, so fit the result in a Long// (although it could have fit in an Integer)assert 5L ** 2 instanceof Long // 25// the result can't be represented as an Integer or Long, so return a BigIntegerassert 100 ** 10 instanceof BigInteger // 10e20assert 1234 ** 123 instanceof BigInteger // 170515806212727042875...// the base is a BigDecimal and the exponent a negative int// but the result can be represented as an Integerassert 0.5 ** -2 instanceof Integer // 4// the base is an int, and the exponent a negative float// but again, the result can be represented as an Integerassert 1 ** -0.3f instanceof Integer // 1// the base is an int, and the exponent a negative int// but the result will be calculated as a Double// (both base and exponent are actually converted to doubles)assert 10 ** -1 instanceof Double // 0.1// the base is a BigDecimal, and the exponent is an int, so return a BigDecimalassert 1.2 ** 10 instanceof BigDecimal // 6.1917364224// the base is a float or double, and the exponent is an int// but the result can only be represented as a Double valueassert 3.4f ** 5 instanceof Double // 454.35430372146965assert 5.6d ** 2 instanceof Double // 31.359999999999996// the exponent is a decimal value// and the result can only be represented as a Double valueassert 7.8 ** 1.9 instanceof Double // 49.542708423868476assert 2 ** 0.1f instanceof Double // 1.0717734636432956 布尔型如下所示： 123def myBooleanVariable = trueboolean untypedBooleanVar = falseboolean Field = true true和false只是两个基础的布尔值，关于更复杂的boolean操作，参考：logical operators.special rules 列表ListGroovy列表就是java.util.List，默认的子类就是java.util.ArrayList，如下所示： 1234def numbers = [1, 2, 3] assert numbers instanceof List assert numbers.size() == 3 列表中可以支持各种类型： 1def heterogeneous = [1, \"a\", true] 还可以定义各种类型的List，默认是ArrayList: 12345678def arrayList = [1, 2, 3]assert arrayList instanceof java.util.ArrayListdef linkedList = [2, 3, 4] as LinkedList assert linkedList instanceof java.util.LinkedListLinkedList otherLinked = [3, 4, 5] assert otherLinked instanceof java.util.LinkedList 可以通过[]运算来获取列表的元素以及设置列表元素的值，下标可以是正数、负数、范围，还可以使用&lt;&lt;运算符来给list追加元素，如下所示： 1234567891011121314151617def letters = ['a', 'b', 'c', 'd']assert letters[0] == 'a' assert letters[1] == 'b'assert letters[-1] == 'd' //获取最后一个元素，-1是从数组末尾开始的第一个元素assert letters[-2] == 'c'letters[2] = 'C' //赋值 assert letters[2] == 'C'letters &lt;&lt; 'e' //在末尾追加一个元素 assert letters[ 4] == 'e'assert letters[-1] == 'e'assert letters[1, 3] == ['b', 'd'] // 一次性获取两个元素，返回一个新的List assert letters[2..4] == ['C', 'd', 'e'] //使用一个范围获取范围内的元素，返回一个新的List 还可以组成多维List： 12def multi = [[0, 1], [2, 3]] assert multi[1][0] == 2 数组数组需要显式定义数组的类型： 123456789String[] arrStr = ['Ananas', 'Banana', 'Kiwi'] assert arrStr instanceof String[] assert !(arrStr instanceof List)def numArr = [1, 2, 3] as int[] assert numArr instanceof int[] assert numArr.size() == 3 可以定义多维数组： 123456def matrix3 = new Integer[3][3] assert matrix3.size() == 3Integer[][] matrix2 matrix2 = [[1, 2], [3, 4]]assert matrix2 instanceof Integer[][] 获取数组元素的方式跟List一样： 12345String[] names = ['Cédric', 'Guillaume', 'Jochen', 'Paul']assert names[0] == 'Cédric' names[2] = 'Blackdrag' assert names[2] == 'Blackdrag' 映射表Maps如下所示： 123456789101112def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF'] assert colors['red'] == '#FF0000' assert colors.green == '#00FF00' colors['pink'] = '#FF00FF' colors.yellow = '#FFFF00' assert colors.pink == '#FF00FF'assert colors['yellow'] == '#FFFF00'assert colors instanceof java.util.LinkedHashMap //默认是LinkedHashMap类型 当获取一个map中不存在的key，会返回null: 1assert colors.unknown == null 除了使用string类型的key，还可以使用其他类型的key: 123def numbers = [1: 'one', 2: 'two']assert numbers[1] == 'one' 如果key是一个变量，如下所示： 12345def key = 'name'def person = [key: 'Guillaume'] //'Guilaume'对应的key为\"key\"，而不是变量key所关联的值 assert !person.containsKey('name') //不包含'name'这个keyassert person.containsKey('key') //包含'key'这个key 要想解决上述问题，可以如下所示： 12345def key = 'name'person = [(key): 'Guillaume'] //此时'Guilaume'对应的key就是变量key所对应的值 assert person.containsKey('name') assert !person.containsKey('key') 以上就是Groovy的基本语法，关于Groovy的语法特性，还包含一下几个方面，直接看官方文档即可，有兴趣的可以了解下。运算符 Operators程序结构 Program structureGroovy 面向对象语法 Object orientation 闭包 ClosuresGroovy 语义 Semantics","categories":[{"name":"Gradle相关","slug":"Gradle相关","permalink":"http://easyliu.com/categories/Gradle相关/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"SimpleSlidingMenu","slug":"android/SimpleSlidingMenu","date":"2017-05-14T03:26:19.000Z","updated":"2017-06-01T15:59:40.000Z","comments":true,"path":"2017/05/14/android/SimpleSlidingMenu/","link":"","permalink":"http://easyliu.com/2017/05/14/android/SimpleSlidingMenu/","excerpt":"","text":"概述一个简单的Android侧滑菜单，支持left, right,left_right三种菜单模式，支持edge,all两种滑动模式，支持设置菜单的宽度，支持滑动动画 效果如下每个Fragment里面是一个RecyclerView，解决了滑动冲突问题，包含滑动动画 使用方式12345678910111213141516171819202122232425private SlidingMenuLayout mSlideMenuLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSlideMenuLayout = new SlidingMenuLayout(this); setContentView(mSlideMenuLayout); initSlideMenuLayout(); &#125; private void initSlideMenuLayout() &#123; getSupportFragmentManager().beginTransaction() .replace(SlidingMenuLayout.LEFT_TAG, ItemFragment.newInstance(1)) .commit(); getSupportFragmentManager().beginTransaction() .replace(SlidingMenuLayout.MIDDLE_TAG, ItemFragment.newInstance(1)) .commit(); getSupportFragmentManager().beginTransaction() .replace(SlidingMenuLayout.RIGHT_TAG, ItemFragment.newInstance(1)) .commit(); mSlideMenuLayout.setBackgroundColor(Color.parseColor(\"#4876FF\")); mSlideMenuLayout.setMenuMode(SlidingMenuLayout.MenuMode.LEFT_RIGHT); mSlideMenuLayout.setSlidingMode(SlidingMenuLayout.SlidingMode.ALL); mSlideMenuLayout.setSlideEnable(true); mSlideMenuLayout.setMenuContentWidthRation(0.75f); &#125; 把SlidingMenuLayout作为根布局 左侧，中间，以及右侧菜单布局都会有一个tag，通过给每一个布局设置一个fragment即可！ 具体参考代码中的：MainActivity.java 关于滑动动画滑动动画主要是给SlideMenuLayout设置IOnMenuOpenListener接口，在接口里面对菜单以及中间视图进行一些缩放、透明度以及平移操作，从而达到动画效果，如下所示： 12345678910111213141516171819mSlideMenuLayout.setOnMenuOpenListener(new SlidingMenuLayout.IOnMenuOpenListener() &#123; @Override public void menuOpen(View menuView, View middleView, float openPercent, boolean isLeftMenu) &#123; float menuScale = (float) (0.8 + 0.2 * openPercent);//0.8到1 float contentScale = (float) (1 - 0.2 * openPercent);//1到0.8 float translationXScale = 0; if (isLeftMenu) &#123; translationXScale = (1 - openPercent) * 0.6f;//范围是0.6到0 &#125; else &#123; translationXScale = -(1 - openPercent) * 0.6f;//范围是-0.6到0 &#125; menuView.setScaleX(menuScale); menuView.setScaleY(menuScale); menuView.setAlpha(openPercent); menuView.setTranslationX(menuView.getWidth() * translationXScale); middleView.setScaleX(contentScale); middleView.setScaleY(contentScale); &#125; &#125;); 代码地址：https://github.com/EasyLiu-Ly/SimpleSlidingMenu.git","categories":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://easyliu.com/categories/Android自定义控件/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"SlideFinishActivity","slug":"android/SlideFinishActivity","date":"2017-05-14T03:07:05.000Z","updated":"2017-06-01T15:59:44.000Z","comments":true,"path":"2017/05/14/android/SlideFinishActivity/","link":"","permalink":"http://easyliu.com/2017/05/14/android/SlideFinishActivity/","excerpt":"","text":"概述让Activity跟随者手指的滑动而滑动，当向右滑动到一定距离或者往右滑动到达一定速度就finish，类似于微信滑动finish的效果。 效果如下 支持边界滑动和全屏滑动两种模式 解决了滑动冲突问题，例如上图中Activity当中就包含了ViewPager，解决了和ViewPager的滑动冲突问题 使用方式如下 自定义的Activity继承自BaseSlideFinishActivity 自定义的Activity的主题需要包含以下两个属性12&lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; 滑动动画在滑动的时候，可以实现滑动动画效果，如下所示，类似于酷狗播放界面滑动Finish的效果。具体实现查看SlideFinishRelativeLayout中的IOnSlideFinishChangeListener接口，在BaseSlideFinishActivity当中实现了这个接口，在这个接口里面对顶层视图进行rotation操作即可。 代码地址：https://github.com/EasyLiu-Ly/SlideFinishActivity.git","categories":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://easyliu.com/categories/Android自定义控件/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android应用层View触摸事件分发机制","slug":"android/ViewDispatchTouchEvent","date":"2017-04-24T14:39:11.000Z","updated":"2017-06-01T15:56:50.000Z","comments":true,"path":"2017/04/24/android/ViewDispatchTouchEvent/","link":"","permalink":"http://easyliu.com/2017/04/24/android/ViewDispatchTouchEvent/","excerpt":"","text":"概述前两篇博客从源码的角度对View绘制流程进行了分析，那么当用户需要跟View进行交互的时候，比如点击按钮的时候，按钮是如何得到点击事件的呢？当用户在屏幕上进行点击或触摸的时候，事件是如何传递到各个View的呢？这个就是本篇博客研究的点：View事件分发机制。只有同时掌握View事件分发机和View绘制流程，并辅以一定的练习，才能真正掌握自定义View。下面开始进入正题！注：源码基于API25。 触摸事件的来源及View事件分发入口还记得之前说过，在Activity的attach方法里面会新建一个PhoneWindow作为顶层Window，如下所示： 12345678910111213141516171819final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); .......... .......... &#125; 在上面的代码当中有一句：mWindow.setCallback(this),这句话给Window设置了一个Callback回调接口给Activity,来看一下这个回调接口： 1234567891011121314151617181920212223/** * API from a Window back to its caller. This allows the client to * intercept key dispatching, panels and menus, etc. */ public interface Callback &#123; public boolean dispatchKeyEvent(KeyEvent event); public boolean dispatchKeyShortcutEvent(KeyEvent event); /** * Called to process touch screen events. At the very least your * implementation must call * &#123;@link android.view.Window#superDispatchTouchEvent&#125; to do the * standard touch screen processing. * * @param event The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent event); ............. 可以发现这个回调接口里面有很多回调方法，前三个方法都是对事件进行分发，第三个方法dispatchTouchEvent就是触摸事件分发。当android系统发生触摸事件时，会把触摸事件发送给顶层Window（至于是怎么传递给Window的，这里暂时不深入研究，涉及到WindowManager,WindowManagerService等跨进程的调用过程，也涉及到Activity的启动过程分析）,这里是PhoneWindow,由于给PhoneWindow设置了回调接口，在Activity当中实现了这个接口，因此，我们查看Activity当中的dispatchTouchEvent方法，如下所示： 12345678910111213141516171819/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 可以看出，如果Action为ACTION_DOWN,首先会调用onUserInteraction方法，这个方法如下所示： 123456789101112131415161718192021/** * Called whenever a key, touch, or trackball event is dispatched to the * activity. Implement this method if you wish to know that the user has * interacted with the device in some way while your activity is running. * This callback and &#123;@link #onUserLeaveHint&#125; are intended to help * activities manage status bar notifications intelligently; specifically, * for helping activities determine the proper time to cancel a notfication. * * &lt;p&gt;All calls to your activity's &#123;@link #onUserLeaveHint&#125; callback will * be accompanied by calls to &#123;@link #onUserInteraction&#125;. This * ensures that your activity will be told of relevant user activity such * as pulling down the notification pane and touching an item there. * * &lt;p&gt;Note that this callback will be invoked for the touch down action * that begins a touch gesture, but may not be invoked for the touch-moved * and touch-up actions that follow. * * @see #onUserLeaveHint() */ public void onUserInteraction() &#123; &#125; 关于这个方法，注释已经说的很明白了，一般和onUserLeaveHint方法配对使用，主要是用来帮助Activity管理状态栏通知。 调用完onUserInteraction方法之后，就会调用getWindow.superDispatchTouchEvent方法，也就是调用PhoneWindow的superDispatchTouchEvent方法。如果这个方法返回true,就直接返回true,否则会调用Activity的onTouchEvent方法。 我们可以在Activity重写dispatchTouchEvent方法来对所有的触摸事件进行拦截，防止其分发至window。 当Activity的onTouchEvent被调用的时候，说明Window的superDispatchTouchEvent方法返回false,也就是没有消耗事件，事件最终交给Activity进行处理，因此我们也可以在Activity当中重写onTouchEvent方法来进行事件处理。 来看下PhoneWindow的superDispatchTouchEvent方法： 1234@Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125; 可以看出其调用的是顶层视图DecorView的superDispatchTouchEvent方法，如下所示： 123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; 可以看出，DecorView调用了其父类的dispatchTouchEvent方法，跳进去看发现调用的是ViewGroup的dispatchTouchEvent方法。这个也可以理解，因为DecorView是继承自FrameLayout，而FrameLayout是继承自ViewGroup。 通过以上分析可以看出，View触摸事件的入口是DecorView, 也就是ViewGroup。整个事触摸件的传递过程如下：**-&gt; 顶层PhoneWindow得到触摸事件，调用其dispatchTouchEvent方法-&gt; Activity当中收到dispatchTouchEvent回调方法，调用mWindow的superDispatchTouchEvent方法-&gt; 调用PhoneWindow的superDispatchTouchEvent方法-&gt; 调用DecorView的superDispatchTouchEvent方法-&gt; 最终调用ViewGroup的dispatchTouchEvent方法-&gt; View触摸事件分发入口** ViewGroup事件分发机制既然View触摸事件的入口是ViewGroup的dispatchTouchEvent方法，说明这个方法至关重要，接下来看下这个dispatchTouchEvent方法,这个方法比较长，我会在代码中加入注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224public boolean dispatchTouchEvent(MotionEvent ev) &#123; ................ boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; //ACTION_DOWN的话就恢复初始状态，清除TouchTarget if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // 检测事件拦截 final boolean intercepted;//这个标志用于是否拦截事件，如果拦截的话，就交给自身的这个ViewGroup进行处理 //如果是ACTION_DOWN或者mFirstTouchTarget不为空（说明已经有了TouchTarget），就开始判断是否拦截事件 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //是否不允许拦截，在ViewGroup当中有一个requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法 //这个函数可以用来设置是否拦截，一般用在子View当中，通过调用父View的这个方法来阻止父View拦截事件 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; //允许拦截的话，就调用onInterceptTouchEvent方法，一般我们需要重写这个方法，来根据需求来进行事件拦截 if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; //不允许拦截 intercepted = false; &#125; &#125; else &#123; //如果没有TouchTarget且当前action不是初始的ACTION_DOWN,就拦截 //如果当前ViewGroup拦截了ACTION_DOWN,那么剩下的ACTION_UP,ACTION_MOVE事件都是交给它处理，且onInterceptTouchEvent方法 // 不会再次调用，因为此时mFirstTouchTarget==null且action!=ACTION_DOWN // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //如果事件没有取消且没有拦截事件 if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; //发现没有，这里只是对ACTION_DOWN进行处理，那么ACTION_UP和ACTION_MOVE呢？ if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. //开始遍历子View，找到能够接收事件的子View final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; //判断子view是否能接收pointer事件或者当前的触摸点在子view的边界内， //如果这两个没有一个满足，就continue，跳到循环的下一步，也就是下一个子view if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); // 如果child已经接收了触摸事件 if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // 这个函数内部调用了child.dispatchTouchEvent方法 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // 有子View接收这个事件 // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //把child的TouchTarget加入到链表的开头且返回child的TouchTarget newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; //这里有三种情况：一种是当前ViewGroup拦截了事件，一种是没有子View，还有一种是子View的dispatchTouchEvent方法返回了false //这三种情况下就交给当前ViewGroup进行处理 // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // 我们发现前面只是对ACTION_DOWN进行了分发,当某个子当某个子View返回true时，会中止Down事件的分发， // 同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理,如下所示。 // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 以上对ViewGroup的dispatchTouchEvent方法进行了分析，总结如下： 1、每次当触摸事件为ACTION_DOWN的时候就会清除之前的状态，开始一次新的事件分发2、如果当前ViewGroup拦截了ACTION_DOWN,那么剩下的ACTION_UP,ACTION_MOVE事件都是交给它处理3、在自定义继承自ViewGroup的View的时候，通过重写onInterceptTouchEvent对事件进行拦截，事件拦截仅仅是针对于ViewGroup，对于View来说不存在事件拦截的说法4、ViewGroup当中有一个requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法，可以用来设置是否拦截，一般用在子View当中，通过调用父View的这个方法来阻止父View进行事件拦截5、有三种情况，触摸事件会交给当前的ViewGroup进行处理，此时就把ViewGroup当成普通的View,走的是View事件分发逻辑，调用的是View的dispatchTouchEvent方法： 一种是当前ViewGroup拦截了事件 一种是没有子View， 还有一种是子View的dispatchTouchEvent方法返回了false 6、事件分发只是针对ACTION_DOWN进行了分发,当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理！这个就有点类似于：一旦一个活交给你干了，你就得干到底的意思！ View事件分发机制之dispatchTouchEvent方法以上讲的是ViewGroup的事件分发机制，对于View来说，触摸事件都是由父ViewGroup分发而来，调用的是View的dispatchTouchEvent方法，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; // 如果满足：mOnTouchListener!=null、View是ENABLED的、mOnTouchListener的onTouch方法返回true,那么result为true if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; //如果上面的result为true，那么就不会调用下面的onTouchEvent方法 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 可以看出： 如果View是使能的、设置了TouchListener接口、接口中的onTouch方法返回true的话，这三个条件同时满足的话就不会调用下面的onTouchEvent方法！ 比如对于一个Button, 如果它是使能的，且给它设置一个TouchListener，在onTouch方法里面返回true，那么就无法响应点击事件（这个大家可以验证一下）， 按钮的点击事件以及长按事件是在onTouchEvent方法里面响应的 当View不使能的时候，是可以继续调用onTouchEvent方法的 如果onTouchEvent返回true,那么整个dispatchTouchEvent也就返回true，代表当前View消耗了事件。 View事件分发机制之onTouchEvent方法来看下onTouchEvent方法，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); // view不使能 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; //ACTION_UP事件，设置按下状态为false if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; //一个不使能的view,如果是可点击的依然会消耗这个事件，比如button,即使是不使能的，也会返回true消耗事件，只是不对事件作出响应而已。 //因为button默认是可点击的，除非手动设置为不可点击 // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; // 如果设置了触摸代理，调用触摸代理的onTouchEvent方法，如果返回true,就消耗事件。 // 这个触摸代理常常用在扩大View的点击区域，比如一个图标太小，就可以扩大其点击区域 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; // 如果是可点击的 if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // 如果View还没有获得焦点的话就主动获得焦点 // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; // 如果长按的动作没有发生且没有忽略下一个ACTION_UP事件 if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // 移除长按检测 // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. //这个PerformClick是一个Runnable对象 if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; //把mPerformClick给post到消息队列 if (!post(mPerformClick)) &#123; // 如果上述Runnable执行失败，就直接调用performClick方法，在这个方法里面调用 // OnClickListener回调接口 performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away // 设置为按下状态 setPressed(true, x, y); // 检测长按，如果长按下成功，会把mHasPerformedLongPress置为true，这样点击事件就得不到响应 // 也就是说长按事件会屏蔽点击事件 checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: //复位 setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false; &#125; 从以上代码可以看出： 一个不使能的view,如果是可点击的依然会消耗这个事件，比如button,即使是不使能的，也会返回true消耗事件，只是不对事件作出响应而已。因为button默认是可点击的，除非手动设置为不可点击 这要这个View是可点击的，不管是否使能，都会消耗事件 如果长按检测成功，会把mHasPerformedLongPress置为true，这样点击事件就得不到响应，也就是说长按事件会屏蔽点击事件 还有一点，像ImageView这种控件默认是不可点击的，但是如果给它设置OnClickListener或者onLongClickListener的话，就会主动把其设置为可点击 以上从源码的角度对触摸事件的来源、ViewGroup事件分发机制、View事件分发机制进行了解读。在自定义View的时候，当需要对触摸事件进行处理的时候，一般是重写onTouchEvent方法，拥有子类的View一般还需要重写onInterceptTouchEvent方法进行事件拦截，要想让这两个方法很好的配合使用，就需要熟悉并且理解触摸事件分发机制，再配合之前的View绘制流程，就能自定义出各式各样的View啦！ 感谢大家的阅读！有啥问题，欢迎指出，谢谢！","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android应用层View绘制流程之measure,layout,draw三步曲","slug":"android/ViewInvalidteProcessTwo","date":"2017-04-22T13:20:18.000Z","updated":"2017-06-01T15:57:10.000Z","comments":true,"path":"2017/04/22/android/ViewInvalidteProcessTwo/","link":"","permalink":"http://easyliu.com/2017/04/22/android/ViewInvalidteProcessTwo/","excerpt":"","text":"概述上一篇博文对DecorView和ViewRootImpl的关系进行了剖析，这篇文章主要是来剖析View绘制的三个基本流程:measure,layout,draw，只有把这三个基本流程搞清楚了，平时在自定义View的时候才会有清晰的思路！开始进入正题。 View的measure过程三个流程均是从ViewRootImpl的performTraversals方法开始的，如下所示： 123456789101112private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ...... mView.draw(canvas); ...... &#125; 首先看下getRootMeasureSpec方法,如下所示： 1234567891011121314151617181920212223242526272829303132/** * Figures out the measure spec for the root view in a window based on it's * layout params. * * @param windowSize * The available width or height of the window * * @param rootDimension * The layout params for one dimension (width or height) of the * window. * * @return The measure spec to use to measure the root view. */ private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec; &#125; 从上面的注释可以看出这个getRootMeasureSpec是为了根据根视图的LayoutParams计算根视图的MeasureSpec，这个根视图就是上篇博客讲的DecorView。 关于MeasureSpec关于MeasureSpec来做一个简单的说明：通过MeasureSpec.makeMeasureSpec来得到一个32位的整数，高两位代码测量模式mode,低30位代表测量大小size，如下所示： 12345678public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; 然后再通过getMode和getSize这两个方法来得到对应的测试模式mode和测量尺寸size，如下所示： 1234567891011121314151617181920212223/** * Extracts the mode from the supplied measure specification. * * @param measureSpec the measure specification to extract the mode from * @return &#123;@link android.view.View.MeasureSpec#UNSPECIFIED&#125;, * &#123;@link android.view.View.MeasureSpec#AT_MOST&#125; or * &#123;@link android.view.View.MeasureSpec#EXACTLY&#125; */ @MeasureSpecMode public static int getMode(int measureSpec) &#123; //noinspection ResourceType return (measureSpec &amp; MODE_MASK); &#125; /** * Extracts the size from the supplied measure specification. * * @param measureSpec the measure specification to extract the size from * @return the size in pixels defined in the supplied measure specification */ public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; View的measure和onMeasure方法通过getRootMeasureSpec来得到DecorView的widthMeasureSpec和heightMeasureSpec之后，就需要来设置DecorView的大小了，也就是调用： 1mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); 发现这个measure是View的方法，如下所示： 12345678910111213141516171819202122232425/** * &lt;p&gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * &lt;/p&gt; * * &lt;p&gt; * The actual measurement work of a view is performed in * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses. * &lt;/p&gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */ public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ........... onMeasure(widthMeasureSpec, heightMeasureSpec); ........... &#125; 通过注释可以看出，这个方法是用来计算当前View应该为多大，也就是实际的宽高。widthMeasureSpec和heightMeasureSpec是由父View传入的约束信息，代表了父View给当前View的测量规格，当前View的宽高是由父View和自身一起决定的。measure方法是final的，不可重载，实际的测量过程是在onMeasure方法里面完成了，因此子类必须且只能重载onMeasure方法来实现自身的测量逻辑。 接下来看onMeasure方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * &lt;p&gt; * Measure the view and its content to determine the measured width and the * measured height. This method is invoked by &#123;@link #measure(int, int)&#125; and * should be overridden by subclasses to provide accurate and efficient * measurement of their contents. * &lt;/p&gt; * * &lt;p&gt; * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you * &lt;em&gt;must&lt;/em&gt; call &#123;@link #setMeasuredDimension(int, int)&#125; to store the * measured width and height of this view. Failure to do so will trigger an * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by * &#123;@link #measure(int, int)&#125;. Calling the superclass' * &#123;@link #onMeasure(int, int)&#125; is a valid use. * &lt;/p&gt; * * &lt;p&gt; * The base class implementation of measure defaults to the background size, * unless a larger size is allowed by the MeasureSpec. Subclasses should * override &#123;@link #onMeasure(int, int)&#125; to provide better measurements of * their content. * &lt;/p&gt; * * &lt;p&gt; * If this method is overridden, it is the subclass's responsibility to make * sure the measured height and width are at least the view's minimum height * and width (&#123;@link #getSuggestedMinimumHeight()&#125; and * &#123;@link #getSuggestedMinimumWidth()&#125;). * &lt;/p&gt; * * @param widthMeasureSpec horizontal space requirements as imposed by the parent. * The requirements are encoded with * &#123;@link android.view.View.MeasureSpec&#125;. * @param heightMeasureSpec vertical space requirements as imposed by the parent. * The requirements are encoded with * &#123;@link android.view.View.MeasureSpec&#125;. * * @see #getMeasuredWidth() * @see #getMeasuredHeight() * @see #setMeasuredDimension(int, int) * @see #getSuggestedMinimumHeight() * @see #getSuggestedMinimumWidth() * @see android.view.View.MeasureSpec#getMode(int) * @see android.view.View.MeasureSpec#getSize(int) */ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 注释已经写的非常明白了，子类必须复写onMeasure方法，且最终通过调用setMeasuredDimension方法来存储当前View测量得到的宽和高。这个宽和高是通过getDefaultSize方法得来的，如下所示： 12345678910111213141516171819202122232425/** * Utility to return a default size. Uses the supplied size if the * MeasureSpec imposed no constraints. Will get larger if allowed * by the MeasureSpec. * * @param size Default size for this view * @param measureSpec Constraints imposed by the parent * @return The size this view should be. */ public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; 可以看出，如果specMode等于AT_MOST或者EXACTLY就返回specSize，也就是父类指定的specSize，否则返回通过getSuggestedMinimumWidth和getSuggestedMinimumHeight得到的size，从名字可以看出是建议的最小宽度和高度，代码如下所示： 1234567protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125;protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125; 可以看出，建议的最小宽度和高度是由view的background以及其mMinWidth、mMinHeight共同决定的。 setMeasuredDimension方法如下所示： 12345678910111213141516171819protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; &#125; setMeasuredDimensionRaw(measuredWidth, measuredHeight);&#125;private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123; mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;&#125; 可以看出这个方法就是给mMeasuredHeight和mMeasuredWidth进行赋值。进行了赋值之后调用View 的getMeasuredWidth和getMeasuredHeight方法才能得到其正确的测量宽高！ ViewGroup的measure过程上面提到View的measure方法传入的widthMeasureSpec和heightMeasureSpec是由父View传入的约束信息，那么这些信息是何时传入的呢？由于View是嵌套的，因此measure过程也是递归传递的，子View的measure是由父类调用的，然后子View根据传入的父类约束来设置自身的测量规格。 ** 继承自ViewGroup的视图均需要实现onMeasure方法，在这个方法里面对其子View进行测量，同时也对自身进行测量，比如LinearLayout的onMeasure方法如下：** 12345678@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125; &#125; 根据布局的方向分别调用measureHorizontal和measureVertical方法。 在ViewGroup中定义了measureChildren, measureChild, measureChildWithMargins方法来对子视图进行测量。measureChildren内部循环调用了measureChild。measureChild和measureChildWithMargins的区别在于measureChildWithMargins把child的margin也考虑在内。下面来对measureChildWithMargins方法来分析： 12345678910111213141516171819202122232425262728/** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding * and margins. The child must have MarginLayoutParams The heavy lifting is * done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param widthUsed Extra space that has been used up by the parent * horizontally (possibly by other children of the parent) * @param parentHeightMeasureSpec The height requirements for this view * @param heightUsed Extra space that has been used up by the parent * vertically (possibly by other children of the parent) */ protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //子视图的测量规格是由父视图的测量测量规格以及子视图的LayoutParams来共同决定的 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //调用子视图的measure方法来设置子视图的测量规格 child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 从以上代码可以看出：子视图的测量规格是由父视图的测量测量规格以及子视图的LayoutParams来共同决定的，因此关键函数是getChildMeasureSpec函数，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * Does the hard part of measureChildren: figuring out the MeasureSpec to * pass to a particular child. This method figures out the right MeasureSpec * for one dimension (height or width) of one child view. * * The goal is to combine information from our MeasureSpec with the * LayoutParams of the child to get the best possible results. For example, * if the this view knows its size (because its MeasureSpec has a mode of * EXACTLY), and the child has indicated in its LayoutParams that it wants * to be the same size as the parent, the parent should ask the child to * layout given an exact size. * * @param spec The requirements for this view * @param padding The padding of this view for the current dimension and * margins, if applicable * @param childDimension How big the child wants to be in the current * dimension * @return a MeasureSpec integer for the child */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec);//得到父视图的mode int specSize = MeasureSpec.getSize(spec);//得到父视图的size //得到Parent视图剩余的大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; //根据Parent视图的specMode来进行分支判断 switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY://父类是精确模式 if (childDimension &gt;= 0) &#123; //子视图是精确模式，直接设置了精确的大小（在xml当中设置了layout_width=\"xxx\"或者在代码中设置了具体的数值),子视图的size就是精确值,子视图的mode就是EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; //如果子视图的layout_width或者layout_height为MATCH_PARENT,也就是为父视图的大小，那么子视图的size就是Parent视图剩余的大小，且mode与父类相同，也为EXACTLY // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; //如果子视图的layout_width或者layout_height为WRAP_CONTENT,也就是不超过父视图的大小，那么子视图的size为size，且mode为AT_MOST。 // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; //子视图是精确模式，直接设置了精确的大小（在xml当中设置了layout_width=\"xxx\"或者在代码中设置了具体的数值),子视图的size就是精确值,子视图的mode就是EXACTLY // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; //如果子视图的layout_width或者layout_height为MATCH_PARENT,也就是为父视图的大小，那么子视图的size就是Parent视图剩余的大小，且mode与父类相同，也是AT_MOST。 // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; //如果子视图的layout_width或者layout_height为WRAP_CONTENT,也就是不超过父视图的大小，那么子视图的size为size，且mode为AT_MOST。 // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; // 将resultSize和resultMode进行组装为32为整数返回 //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 可以看到，getChildMeasureSpec就是根据父视图的specSize和specMode以及child视图的LayoutParams来确定子视图的resultSize和resultMode，然后把resultSize和resultMode进行组装成32位的整数，作为child.measure的参数来对子视图进行测量。 ** 有一个需要特别注意的地方：** 当childDimension == LayoutParams.WRAP_CONTENT的时候，其specSize和specMode分别为父视图的size和MeasureSpec.AT_MOST。 再回到上面的View测量过程当中的getDefaultSize方法，如下所示。我们发现当View的specMode为AT_MOST的时候，其size默认就是parent视图的size! 因此，在我们自定义View的时候，需要考虑当specMode为AT_MOST的时候（也就是在xml布局当中设置为WRAP_CONTENT的时候）给当前View的宽高设置一个具体的值，大家可以去看看比如TextView的源代码，均对WRAP_CONTENT的情况进行了特殊的处理！ 123456789101112public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); ...... case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 以上就是View和ViewGroup的measure过程,在ViewGroup的实现视图当中递归调用子视图的的measure方法来实现整个View树的测量。在自定义View的时候，当我们需要对View的尺寸进行更改的时候，需要实现onMeasure方法，在里面根据父视图给的specSize和specMode来设置当前View的specMode和specSize,需要注意的是当父视图给的specMode==AT_MOST的时候，需要给当前View的宽高设置一个具体的值。 View的layout过程讲完了View的measure过程，接下来就是layout过程。那么这个layout过程是干什么的呢？在measure过程当中设置了view的宽高，那么设置了宽高之后，具体view是显示在屏幕的哪个位置呢？这个就是layout过程干的事。 layout跟measure一样，也是递归结构，来看下View的layout方法： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Assign a size and position to a view and all of its * descendants * * &lt;p&gt;This is the second phase of the layout mechanism. * (The first is measuring). In this phase, each parent calls * layout on all of its children to position them. * This is typically done using the child measurements * that were stored in the measure pass().&lt;/p&gt; * * &lt;p&gt;Derived classes should not override this method. * Derived classes with children should override * onLayout. In that method, they should * call layout on each of their children.&lt;/p&gt; * * @param l Left position, relative to parent * @param t Top position, relative to parent * @param r Right position, relative to parent * @param b Bottom position, relative to parent */ @SuppressWarnings(&#123;\"unchecked\"&#125;) public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //setFrame方法把参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量 //判断布局是否发生改变 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); ........ &#125; ...... &#125; 在layout方法里面首先通过setFrame来设置自身的位置，然后调用了onLayout方法，是不是跟measure方法里面调用onMeasure方法类似！来看下onLayout方法： 123456789101112131415/** * Called from layout when this view should * assign a size and position to each of its children. * * Derived classes with children should override * this method and call layout on each of * their children. * @param changed This is a new size or position for this view * @param left Left position, relative to parent * @param top Top position, relative to parent * @param right Right position, relative to parent * @param bottom Bottom position, relative to parent */ protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; &#125; 发现onLayout是一个空方法，通过注释可以看出：具有子视图的子类需要重写这个onLayout方法并且调用其每一个子视图的layout方法。这就完全明白了：也就是说直接或者间接继承自ViewGroup的视图需要重写onLayout方法，然后调用其每个子视图的layout方法来设置子视图的位置！我们可以查看LinearLayout，其肯定是实现了onLayout方法，在这个方法里面来一一设置子视图的位置！LinearLayout的onLayout方法如下所示： 12345678@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125; &#125; 来看下layoutVertical方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Position the children during a layout pass if the orientation of this * LinearLayout is set to &#123;@link #VERTICAL&#125;. * * @see #getOrientation() * @see #setOrientation(int) * @see #onLayout(boolean, int, int, int, int) * @param left * @param top * @param right * @param bottom */ void layoutVertical(int left, int top, int right, int bottom) &#123; final int paddingLeft = mPaddingLeft; int childTop; int childLeft; // Where right end of child should go final int width = right - left; int childRight = width - mPaddingRight; //child可以使用的空间 // Space available for child int childSpace = width - paddingLeft - mPaddingRight; //得到 child的个数 final int count = getVirtualChildCount(); final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK; final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK; //根据majorGravity计算childTop的位置 switch (majorGravity) &#123; case Gravity.BOTTOM: // mTotalLength contains the padding already childTop = mPaddingTop + bottom - top - mTotalLength; break; // mTotalLength contains the padding already case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; &#125; // 开始进行遍历child视图 for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123;//child不为GONE,因为GONE是不占空间的 final int childWidth = child.getMeasuredWidth();// 得到onMeasure之后的测量宽度 final int childHeight = child.getMeasuredHeight();// 得到onMeasure之后的测量高度 final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); // 根据absoluteGravity计算childLeft的值 switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; &#125; if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; //通过setChildFrame函数来设置child的位置， setChildFrame函数如下所示 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125; &#125; private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height); &#125; 上面这个方法还是比较易懂的，主要就是调用child的layout方法来设置child的位置，当我们给一个View设置好位置之后，其内部的四个变量mLeft、mTop、mRight和mBottom也就确定了，不过要注意这些值都是相对父视图而言的，而不是相对整个屏幕而言的。这个四个变量是通过以下方式获取的。 1234567891011121314151617181920212223public final int getWidth() &#123; return mRight - mLeft; &#125; public final int getHeight() &#123; return mBottom - mTop; &#125; public final int getLeft() &#123; return mLeft; &#125; public final int getRight() &#123; return mRight; &#125; public final int getTop() &#123; return mTop; &#125; public final int getBottom() &#123; return mBottom; &#125; 在View当中还有下面两个函数，这也解释了为什么有时候getWidth()和getMeasuredWidth()以及getHeight()和getMeasuredHeight()会得到不同的值的原因。 1234567public final int getMeasuredWidth() &#123; return mMeasuredWidth &amp; MEASURED_SIZE_MASK; &#125; public final int getMeasuredHeight() &#123; return mMeasuredHeight &amp; MEASURED_SIZE_MASK; &#125; 以上就是View的layout过程，layout相对measure过程来说还是算比较简单的。 ** 总结起来就是：直接或者间接继承自ViewGroup的视图需要重写onLayout方法，然后调用其每个子视图的layout方法来设置子视图的位置。** View的draw过程讲完了View的layout流程，接下来就是draw流程，draw负责对view进行绘制。在ViewRootImpl的drawSoftware方法当中： 123456789101112131415161718192021/** * @return true if drawing was successful, false if an error occurred */ private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; final int left = dirty.left; final int top = dirty.top; final int right = dirty.right; final int bottom = dirty.bottom; canvas = mSurface.lockCanvas(dirty); ................ mView.draw(canvas); ......... return true; &#125; 在上述方法当中调用了mView的draw方法，来看View的draw方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * &#123;@link #onDraw(android.graphics.Canvas)&#125; instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered. */ @CallSuper public void draw(Canvas canvas) &#123; ............... /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; ........ // skip step 2 &amp; 5 if possible (common case) ....... // Step 2, save the canvas' layers if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; ........ // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); &#125; ............... // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); &#125; 通过注释可以看出整个绘制过程分为6部分，在大多数情况下第2步和第5步可以跳过，在自定义View的时候需要实现onDraw方法而不是实现draw方法。接下来对剩下的四步进行分析： 第一步：绘制背景 通过调用drawBackground方法实现123456789101112131415161718private void drawBackground(Canvas canvas) &#123; final Drawable background = mBackground; if (background == null) &#123; return; &#125; setBackgroundBounds(); ............... final int scrollX = mScrollX; final int scrollY = mScrollY; if ((scrollX | scrollY) == 0) &#123; background.draw(canvas); &#125; else &#123; canvas.translate(scrollX, scrollY); background.draw(canvas); canvas.translate(-scrollX, -scrollY); &#125;&#125; 如上所示，调用了background的draw方法，也就是Drawable的draw方法。 第三步：绘制内容 通过调用onDraw方法实现1234567/** * Implement this to do your drawing. * * @param canvas the canvas on which the background will be drawn */ protected void onDraw(Canvas canvas) &#123; &#125; 我们发现onDraw是一个空的方法，需要子类去实现，一般我们在自定义View的时候都会重写onDraw方法来进行绘制。 第四步：绘制子类 通过调用dispatchDraw实现123456789/** * Called by draw to draw the child views. This may be overridden * by derived classes to gain control just before its children are drawn * (but after its own view has been drawn). * @param canvas the canvas on which to draw the view */ protected void dispatchDraw(Canvas canvas) &#123; &#125; 发现dispatchDraw为空，根据注释：如果View包含子类就需要重写这个方法，那么说明下ViewGroup应该重写了这个方法，看下ViewGroup的dispatchDraw方法，如下所示： 123456789101112131415161718192021222324@Override protected void dispatchDraw(Canvas canvas) &#123; ............. for (int i = 0; i &lt; childrenCount; i++) &#123; while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123; final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; transientIndex++; if (transientIndex &gt;= transientCount) &#123; transientIndex = -1; &#125; &#125; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; ............. &#125; 从上述方法看出主要是遍历child,然后调用child的drawChild方法，来看下drawChild方法： 123protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 可以看出，在drawChild方法当中调用了child.draw方法来实现子视图的绘制。 第六步：绘制装饰，比如前景色，滚动条等 通过onDrawForeground方法实现1234567891011121314151617/** * Draw any foreground content for this view. * * &lt;p&gt;Foreground content may consist of scroll bars, a &#123;@link #setForeground foreground&#125; * drawable or other view-specific decorations. The foreground is drawn on top of the * primary view content.&lt;/p&gt; * * @param canvas canvas to draw into */ public void onDrawForeground(Canvas canvas) &#123; onDrawScrollIndicators(canvas); onDrawScrollBars(canvas); ........ final Drawable foreground = mForegroundInfo != null ? mForegroundInfo.mDrawable : null; ........ foreground.draw(canvas); &#125; 可以看出主要是对滚动条和前景色进行绘制。 到此，View绘制的三个基本流程：measure,layout,draw就讲完了，measure过程应该是三个流程里面最为复杂的。希望通过本次对源码的剖析，能够对View的绘制流程有一个清楚的认识，在以后自定义View的时候能够少走弯路～～ View树的重绘还记得在上一篇博客中我们讲ViewGroup#addView方法会导致View树的重新绘制，代码如下所示： 1234567891011121314public void addView(View child, int index, LayoutParams params) &#123; if (DBG) &#123; System.out.println(this + \" addView\"); &#125; if (child == null) &#123; throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\"); &#125; // addViewInner() will call child.requestLayout() when setting the new LayoutParams // therefore, we call requestLayout() on ourselves before, so that the child's request // will be blocked at our level requestLayout(); invalidate(true); addViewInner(child, index, params, false);&#125; 其实归根结底是调用了requestLayout和invalidate方法的原因，导致View进行重新绘制，下面来对这两个方法进行分析： View的requestLayout方法：requestLayout是view的方法，如下所示： 12345678@CallSuper public void requestLayout() &#123; ............ if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123; mParent.requestLayout(); &#125; ......... &#125; 核心代码是mParent.requestLayout，这个方法就会一层层的往上递归，一直到ViewRootImpl的requestLayout。ViewRootImpl的requestLayout方法在上一篇博客中已经分析过，这个方法会导致整个View树的重绘。 View的invalidate方法：12345678910111213141516171819202122public void invalidate() &#123; invalidate(true);&#125;void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);&#125;void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) &#123; ........... // Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage); &#125; ...........&#125; 我们发现最终调用了当前view父视图的invalidateChid方法，于是查看ViewGroup的invalidateChid方法： 12345678910111213141516171819202122232425262728293031/** * Don't call or override this method. It is used for the implementation of * the view hierarchy. */ @Override public final void invalidateChild(View child, final Rect dirty) &#123; ViewParent parent = this; ............. do &#123; View view = null; if (parent instanceof View) &#123; view = (View) parent; &#125; .......... parent = parent.invalidateChildInParent(location, dirty); if (view != null) &#123; // Account for transform on current parent Matrix m = view.getMatrix(); if (!m.isIdentity()) &#123; RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); m.mapRect(boundingRect); dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom)); &#125; &#125; &#125; while (parent != null); &#125; &#125; 我们发现invalidateChild方法里面有一个do-while循环，在这个循环里面循环调用invalidateChildInParent方法，到这里我们自然就可以想到最终会调用ViewRootImpl的invalidateChildInParent方法，ViewRootImpl的invalidateChildInParent方法如下所示： 1234567891011121314@Override public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; checkThread(); if (DEBUG_DRAW) Log.v(mTag, \"Invalidate child: \" + dirty); if (dirty == null) &#123; invalidate(); return null; &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123; return null; &#125; ............ return null; &#125; 可以看到在这个方法里面调用了invalidate方法，如下所示： 123456void invalidate() &#123; mDirty.set(0, 0, mWidth, mHeight); if (!mWillDrawSoon) &#123; scheduleTraversals(); &#125; &#125; 看到这里是否有一种很熟悉的赶脚（如果看了上一篇博客的话），这个scheduleTraversals方法最终会调用View的三个基本绘制流程来实现整个View树的绘制。 View的postInvalidate方法：当我们想在非ui线程当中刷新View的时候一般都是调用postInvalidate方法，View的postInvalidate方法如下所示： 123456789101112public void postInvalidate() &#123; postInvalidateDelayed(0); &#125;public void postInvalidateDelayed(long delayMilliseconds) &#123; // We try only with the AttachInfo because there's no point in invalidating // if we are not attached to our window final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds); &#125; &#125; 可以看出是调用了ViewRootImpl的dispatchInvalidateDelayed方法： 1234public void dispatchInvalidateDelayed(View view, long delayMilliseconds) &#123; Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view); mHandler.sendMessageDelayed(msg, delayMilliseconds); &#125; 这个方法就是发送一个MSG_INVALIDATE消息到消息队列当中，那肯定是在Handler的handleMessage方法里面对消息进行了处理： 123456@Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_INVALIDATE: ((View) msg.obj).invalidate(); break; 在handleMessage方法里面调用了View的invalidate方法,而关于invalidate方法，在上面进行了详细的分析。 到此为止，对View绘制的三个基本流程从源码的角度进行了详细的剖析，谢谢各位的阅读，不足之处欢迎指出。","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android应用层View绘制流程之DecorView与ViewRootImpl","slug":"android/ViewInvalidteProcessOne","date":"2017-04-22T09:22:24.000Z","updated":"2017-06-01T15:57:00.000Z","comments":true,"path":"2017/04/22/android/ViewInvalidteProcessOne/","link":"","permalink":"http://easyliu.com/2017/04/22/android/ViewInvalidteProcessOne/","excerpt":"","text":"概述一直对Android中View的整个绘制流程不是很了解，View是怎么添加到Activity当中去的？当View中的内容发生改变的时候是怎样执行界面的刷新的？因此，今天准备从源码的角度来对View的整个绘制流程来进行分析，源码基于API25。由于篇幅限制，这篇文章只分析顶层视图DecorView的显示逻辑，具体的View树绘制三部曲:measure,layout,draw将在下篇博文进行深入剖析。 从Activity的setContentView方法说起我们都知道给Activity设置布局通常就是调用其setContentView方法，这个方法有几个重载的方法，如下所示： 1234567891011121314public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125; public void setContentView(View view) &#123; getWindow().setContentView(view); initWindowDecorActionBar(); &#125;public void setContentView(View view, ViewGroup.LayoutParams params) &#123; getWindow().setContentView(view, params); initWindowDecorActionBar();&#125; 从上面的三个方法可以看出其均调用了getWindow()的相对应的方法，我们来看getWindow()方法： 123public Window getWindow() &#123; return mWindow; &#125; 可以看出这个方法返回的是一个Window类型的变量mWindow，那么这个mWindow肯定是在Activity某个地方进行初始化,如下所示在attach方法里面进行了初始化： 12345678910111213141516171819final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); .......... .......... &#125; mWindow是一个PhoneWindow类型的变量，其实我们通过查看抽象类Window最开始的简介可以知道，PhoneWindow是Window的唯一子类！ 1234567891011/** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */public abstract class Window &#123; 接下来查看PhoneWindow的setContentView方法，跟Activity对应，也有三个重载的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 @Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125;@Overridepublic void setContentView(View view) &#123; setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));&#125;@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; mContentParent.addView(view, params); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 对setContentView(View view,ViewGroup.LayoutParams)方法进行分析： 首先判断mContentParent是否为null，如果为null的话就执行方法installDecor，这个mContentParent是一个ViewGroup类型，这个方法如下所示： 1234567891011121314151617 private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); ........ .......&#125; generateDecor用于产生mDecor,mDecor是DecorView类型，是整个Activity的顶层视图，DecorView是FrameLayout的子类，有兴趣的可以看看DecorView源码，这里只是给个结论。然后是generateLayout方法，这个方法很长，看关键代码： 123456 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(\"Window couldn't find content container view\"); &#125;....return contentParent; 从上述代码可以看出，上面讲到的mContentParent是顶层视图mDecor中的一个子View，这个子View的id为： 1234/** * The ID that the main layout in the XML layout file should have. */ public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; 因此，执行了installDecor方法之后就得到了mDecor和mContentParent，然后是一句很关键的代码，如下所示：1mContentParent.addView(view, params); 通过这句代码就把我们在Activity当中设置的布局视图加入了mContentParent里面。** 层次关系为：DecorView &gt; contentParent &gt; Activity中的布局。**由于mContentParent是ViewGroup类型，查看ViewGroup#addView方法，如下所示： 123456789101112131415161718192021222324252627/** * Adds a child view with the specified layout parameters. * * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; do not invoke this method from * &#123;@link #draw(android.graphics.Canvas)&#125;, &#123;@link #onDraw(android.graphics.Canvas)&#125;, * &#123;@link #dispatchDraw(android.graphics.Canvas)&#125; or any related method.&lt;/p&gt; * * @param child the child view to add * @param index the position at which to add the child or -1 to add last * @param params the layout parameters to set on the child */ public void addView(View child, int index, LayoutParams params) &#123; if (DBG) &#123; System.out.println(this + \" addView\"); &#125; if (child == null) &#123; throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\"); &#125; // addViewInner() will call child.requestLayout() when setting the new LayoutParams // therefore, we call requestLayout() on ourselves before, so that the child's request // will be blocked at our level requestLayout(); invalidate(true); addViewInner(child, index, params, false); &#125; 这个addView方法最后会调用requestLayout()和invalidate()方法，这两个方法会导致整个View树进行重新绘制，这样就把我们在Activity当中自定义的布局文件给显示出来了！ 整个过程总结如下：Activity.setContentView -&gt; PhoneWindow.setContentView -&gt;初始化PhoneWindow中的mDecor和mContentParent -&gt; 把Activity当中的布局视图加入mContentParent -&gt; 导致整个View树进行重新绘制，从而把布局文件显示出来！ DecorView是怎么显示出来的前面说了DecorView是整个Activity的顶层视图，那么这个DecorView是怎么显示出来了的呢？主要实现过程在ActivityThread的handleResumeActivity方法里面，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); if (!checkAndUpdateLifecycleSeq(seq, r, \"resumeActivity\")) &#123; return; &#125; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration r = performResumeActivity(token, clearHide, reason); if (r != null) &#123; final Activity a = r.activity; if (localLOGV) Slog.v( TAG, \"Resume \" + r + \" started activity: \" + a.mStartedActivity + \", hideForNow: \" + r.hideForNow + \", finished: \" + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; ................................ &#125;&#125; 如上述方法所示，首先从ActivityThread保存的mActivities列表里面得到一个ActivityClientRecord对象，这个对象保存了Activity的一些信息。 得到Activity之后调用View decor = r.window.getDecorView();方法得到顶层视图DecorView，这个视图前面说过是保存在PhoneWindow里面，也就是一个Activity对应一个 PhoneWindow，从而对应一个DecorView。 然后是调用ViewManager wm = a.getWindowManager();方法得到Activity当中的WindowManager对象，那为什么返回的是ViewManager对象呢？查看WindowManager接口，如下所示，发现WindowManager是继承自ViewManager接口的。 1public interface WindowManager extends ViewManager &#123; ViewManager接口如下所示，从注释可以看出这个接口主要是用来往Activity当中添加或者移除View。 12345678910111213141516171819/** Interface to let you add and remove child views to an Activity. To get an instance * of this class, call &#123;@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()&#125;. */public interface ViewManager&#123; /** * Assign the passed LayoutParams to the passed View and add the view to the window. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.BadTokenException&#125; for certain programming * errors, such as adding a second view to a window without removing the first view. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.InvalidDisplayException&#125; if the window is on a * secondary &#123;@link Display&#125; and the specified display can't be found * (see &#123;@link android.app.Presentation&#125;). * @param view The view to be added to this window. * @param params The LayoutParams to assign to view. */ public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 得到Activity当中的WindowManager之后，调用wm.addView(decor, l);方法，就把DecorView加入了WindowManager。我们知道WindowManager只是一个接口，具体的实现类是WindowManagerImpl,看下其addView方法： 12345@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; 发现这个addView方法其实是调用了成员变量mGlobal的addVeiw方法，mGlobal是WindowManagerGlobal类型，我们来看下其addView方法，如下所示： 123456789101112131415161718192021222324252627282930public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ........................ ViewRootImpl root; View panelParentView = null; ......................... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); ........................... // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125; &#125; 通过上述代码可以发现顶层视图DecorView最终被加入到了ViewRootImpl里面，且应该是在其setView方法里面执行了某些操作，导致DecorView被显示出来。这个方法比较长，大家可以自行查看，在里面有一句关键的代码： 1234// Schedule the first layout -before- adding to the window// manager, to make sure we do the relayout before receiving// any other events from the system.requestLayout(); requestLayout方法如下： 12345678@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; 在这个方法当中调用了scheduleTraversals方法，如下所示： 12345678910111213void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125; &#125; 在这个方法当中把mTraversalRunnable给post到了消息队列里面，来看看这个Runnable里面执行了什么操作： 1234567final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125; &#125; final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); 从上面可以看出在TraversalRunnable里面执行了doTraversal方法： 1234567891011121314151617void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(\"ViewAncestor\"); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125; &#125; 在这个方法当中又执行了performTraversals方法，这个方法最终负责整个View树的绘制流程，因此这个方法比较关键。这个方法比较长，其负责绘制的View树的核心语句如下，其中mView就是顶层视图DecorView。 123456789101112private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ...... mView.draw(canvas); ...... &#125; 上面对顶层视图DecorView的显示机制进行了深入剖析，通过一层层分析，最终得出ViewRootImpl负责整个View树的绘制。measure,layout,draw是View树绘制三个主要流程，只有理解了这三个基本流程的原理，在自定义View的时候才能做到游刃有余（当然还有View事件分发机制也很关键）！关于这三个流程的具体细节剖析将在下一篇博客中进行讲解。感谢大家的阅读！","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-18T06:51:26.000Z","updated":"2017-03-18T06:51:26.000Z","comments":true,"path":"2017/03/18/hello-world/","link":"","permalink":"http://easyliu.com/2017/03/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"杂项","slug":"杂项","permalink":"http://easyliu.com/categories/杂项/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://easyliu.com/tags/其他/"}]},{"title":"自定义圆形进度条的实现","slug":"android/CustomizeProgressBar","date":"2017-03-16T11:09:47.000Z","updated":"2017-06-01T15:59:36.000Z","comments":true,"path":"2017/03/16/android/CustomizeProgressBar/","link":"","permalink":"http://easyliu.com/2017/03/16/android/CustomizeProgressBar/","excerpt":"","text":"概述Android中自带有进度条，但是有的时候自带的进度条不能满足我们的需求，这时候就需要自定义进度条了，今天带来的就是一个自定义的圆形进度条首先来看效果，效果如下所示。 实现从上面的效果可以看出，主要有以下几个自定义属性： 背景颜色 进度扇形颜色 半径 起始角度 因此，在attrs.xml中定义如下属性： 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"SimpleRoundProgressBar\"&gt; &lt;attr format=\"color\" name=\"roundColor\"/&gt; &lt;attr format=\"color\" name=\"roundProgressColor\"/&gt; &lt;attr format=\"dimension\" name=\"circleRadius\"/&gt; &lt;attr format=\"integer\" name=\"startAngle\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 下面是SimpleRoundProgressBar代码，在onMeasure当中确定view的大小，在onDraw来进行绘制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.easyliu.demo.customizeview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.util.AttributeSet;import android.view.View;/*** Created by easyliu on 2017/2/24.*/public class SimpleRoundProgressBar extends View &#123; private Paint mPaint;//画笔 private RectF mRectF;//扇形绘制的矩形范围 private int mRoundColor;//圆环的颜色 private int mRoundProgressColor; //进度条的颜色 private float mRadius;//半径 private int mWidth; //宽度 private int mHeight; //高度 private int mCenterX; //中心X坐标 private int mCenterY; //中心Y坐标 private int mStartAngle; //初始角度 private int mSweepAngle; //扫过的角度 private static final int DEFAULT_INIT_ANGLE = 0;//默认的初始化角度 private static final int DEFAULT_RADIUS = 10;//默认的半径 public SimpleRoundProgressBar(Context context) &#123; this(context, null); &#125; public SimpleRoundProgressBar(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SimpleRoundProgressBar(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mPaint = new Paint(); mRectF = new RectF(); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.SimpleRoundProgressBar); mRoundColor = typedArray.getColor(R.styleable.SimpleRoundProgressBar_roundColor, Color.GRAY); mRoundProgressColor = typedArray.getColor(R.styleable.SimpleRoundProgressBar_roundProgressColor, Color.RED); mRadius = typedArray.getDimension(R.styleable.SimpleRoundProgressBar_circleRadius, DEFAULT_RADIUS); mStartAngle = typedArray.getInteger(R.styleable.SimpleRoundProgressBar_startAngle, DEFAULT_INIT_ANGLE); typedArray.recycle(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //获取测量模式 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); //获取测量大小 int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); //如果为确定值 if (heightMode == MeasureSpec.EXACTLY) &#123; mHeight = heightSize; &#125; else &#123; //如果为wrap_content，高度为半径大小乘以2，注意padding mHeight = (int) (mRadius * 2) + getPaddingTop() + getPaddingBottom(); &#125; //如果为确定值 if (widthMode == MeasureSpec.EXACTLY) &#123; mWidth = widthSize; mHeight=mWidth;//宽和高相等 &#125; else &#123; //如果为wrap_content，宽度为半径大小乘以2,注意padding mWidth = (int) (mRadius * 2) + getPaddingLeft() + getPaddingRight(); &#125; //设置视图的大小 setMeasuredDimension(mWidth, mHeight); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setColor(mRoundColor); mPaint.setAntiAlias(true); mCenterX = mWidth / 2; mCenterY = mHeight / 2; //注意处理padding mRadius = (mWidth - getPaddingLeft() - getPaddingRight()) / 2; //画圆 canvas.drawCircle(mCenterX, mCenterY, mRadius, mPaint); mPaint.setColor(mRoundProgressColor); //注意处理padding mRectF.left = getPaddingLeft(); mRectF.right = mWidth - getPaddingRight(); mRectF.top = getPaddingTop(); mRectF.bottom = mHeight - getPaddingBottom(); //画扇形 canvas.drawArc(mRectF, (float) mStartAngle, mSweepAngle, true, mPaint); &#125; public int getRoundColor() &#123; return mRoundColor; &#125; public void setRoundColor(int roundColor) &#123; this.mRoundColor = roundColor; &#125; /** * 得到初始角度 */ public synchronized int getStartAngle() &#123; return mStartAngle; &#125; /** * 设置初始角度 */ public synchronized void setStartAngle(int startAngle) &#123; if (startAngle &lt; -360) &#123; throw new IllegalArgumentException(\"the angle can not less than -360\"); &#125; if (startAngle &gt; 360) &#123; throw new IllegalArgumentException(\"the angle can not larger than 360\"); &#125; this.mStartAngle = startAngle; &#125; /** * 得到扫过的角度 */ public synchronized int getSweepAngle() &#123; return mSweepAngle; &#125; /** * 设置扫过的角度,相对于起始点 * * @param sweepAngle 0~360 */ public synchronized void setSweepAngle(int sweepAngle) &#123; if (sweepAngle &lt; 0) &#123; throw new IllegalArgumentException(\"the angle can not less than 0\"); &#125; if (sweepAngle &gt; 360) &#123; throw new IllegalArgumentException(\"the angle can not larger than 360\"); &#125; this.mSweepAngle = sweepAngle; postInvalidate(); &#125;&#125; 定义好了之后就可以使用了，首先是xml文件： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:easyliu=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.easyliu.demo.customizeview.RoundProgressBarActivity\" &gt; &lt;com.easyliu.demo.customizeview.SimpleRoundProgressBar android:id=\"@+id/progress_demo\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:padding=\"10dp\" easyliu:circleRadius=\"50dp\" easyliu:roundColor=\"#5F000000\" easyliu:roundProgressColor=\"#ff8d33\" /&gt; &lt;com.easyliu.demo.customizeview.SimpleRoundProgressBar android:id=\"@+id/progress_demo2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/progress_demo\" android:layout_centerHorizontal=\"true\" android:padding=\"10dp\" easyliu:circleRadius=\"60dp\" easyliu:roundColor=\"@color/colorPrimary\" easyliu:roundProgressColor=\"@color/colorAccent\" /&gt;&lt;/RelativeLayout&gt; 然后是Activity代码，在代码中使用定时器来定时更新进度即可。 123456789101112131415161718192021222324252627282930313233343536package com.easyliu.demo.customizeview;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import java.util.Timer;import java.util.TimerTask;public class RoundProgressBarActivity extends AppCompatActivity &#123; private int mCurrentAngle = 0; private SimpleRoundProgressBar mRoundProgressBar1; private SimpleRoundProgressBar mRoundProgressBar2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_progress_bar); initViews(); Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; mCurrentAngle++; mRoundProgressBar1.setSweepAngle(mCurrentAngle); mRoundProgressBar2.setSweepAngle(mCurrentAngle); if (mCurrentAngle &gt;= 360) &#123; mCurrentAngle = 0; &#125; &#125; &#125;, 0, 20); &#125; private void initViews()&#123; mRoundProgressBar1 = (SimpleRoundProgressBar) findViewById(R.id.progress_demo); mRoundProgressBar1.setStartAngle(-90); mRoundProgressBar2= (SimpleRoundProgressBar) findViewById(R.id.progress_demo2); mRoundProgressBar2.setStartAngle(0); &#125;&#125; 这样就完成了一个简单的圆形进度条的自定义。","categories":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://easyliu.com/categories/Android自定义控件/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Hexo搭建个人博客","slug":"hexo/hexo","date":"2017-03-15T15:28:55.000Z","updated":"2020-11-22T04:24:43.693Z","comments":false,"path":"2017/03/15/hexo/hexo/","link":"","permalink":"http://easyliu.com/2017/03/15/hexo/hexo/","excerpt":"","text":"您好，欢迎来到easyliu的技术博客！ 相关链接： 在 hexo 中无痛使用本地图片 程序猿修炼之道(4)-技能篇之Markdown（附：工具推荐） hexo官网 大道至简——Hexo简洁主题推荐 npm install reports error “npm ERR! Unexpected end of JSON input while parsing near hueman-theme 关于hexo中使用连续{报错的解决方案:把括号进行隔开即可 相关笔记： 代码块高亮的方式为三个```之后加上语言，记得之间的空格，不然无效 对于引用图片，在同一目录下面新建asset文件夹，把图片放入其中，然后引用即可 在_post下面的ios目录下面新建xcode_shortcut.md文件：hexo new –path ios/xcode_shortcut “xcode_shortcut”","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://easyliu.com/categories/开发工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://easyliu.com/tags/hexo/"}]}]}