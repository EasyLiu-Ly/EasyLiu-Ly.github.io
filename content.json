{"meta":{"title":"EasyLiu","subtitle":"welcome to my blog","description":"欢迎来到我的博客","author":"EasyLiu","url":"http://easyliu.com"},"pages":[{"title":"关于","date":"2017-03-17T16:00:00.000Z","updated":"2020-05-17T10:42:56.681Z","comments":true,"path":"about/index.html","permalink":"http://easyliu.com/about/index.html","excerpt":"","text":"程序员一枚,专注移动端开发 Nickname: EasyLiu Email: ly_eyl@163.com Github: EasyLiu-Ly"}],"posts":[{"title":"SecondArrayFind","slug":"algorithm/SecondArrayFind","date":"2020-06-18T03:40:08.000Z","updated":"2020-06-18T11:06:54.560Z","comments":false,"path":"2020/06/18/algorithm/SecondArrayFind/","link":"","permalink":"http://easyliu.com/2020/06/18/algorithm/SecondArrayFind/","excerpt":"","text":"题目在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 输入int[][] inputArray = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };int target = 6; 输出true 实现1234567891011121314151617181920212223242526public class SecondArrayFind &#123; public static boolean secondArrayFindTarget(final int[][] inputArray, final int target) &#123; if (inputArray == null) &#123; return false; &#125; if (inputArray[0] == null) &#123; return false; &#125; int rowSize = inputArray.length; int columnSize = inputArray[0].length; int row = 0; int column = columnSize - 1; while (column &gt;= 0 &amp;&amp; row &lt; rowSize) &#123; int curValue = inputArray[row][column]; if (curValue &lt; target) &#123; row++; &#125; else if (curValue &gt; target) &#123; column--; &#125; else &#123; break; &#125; &#125; return column &gt;= 0 &amp;&amp; row &lt; rowSize; &#125;&#125; 单元测试123456789101112131415161718192021public class SecondArrayFindTest &#123; @Test public void testNullInput() &#123; Assert.assertFalse(SecondArrayFind.secondArrayFindTarget(null, 100)); &#125; @Test public void testNormalFound() &#123; int[][] inputArray = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; int target = 6; Assert.assertTrue(SecondArrayFind.secondArrayFindTarget(inputArray, target)); &#125; @Test public void testNormalNotFound() &#123; int[][] inputArray = &#123;&#123;1, 2, 3&#125;, &#123;6, 7, 8&#125;, &#123;7, 8, 9&#125;&#125;; int target = 5; Assert.assertFalse(SecondArrayFind.secondArrayFindTarget(inputArray, target)); &#125;&#125;","categories":[{"name":"每周三题","slug":"每周三题","permalink":"http://easyliu.com/categories/每周三题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"findFirstOneTimeChar","slug":"algorithm/findFirstOneTimeChar","date":"2020-06-10T03:00:22.000Z","updated":"2020-06-10T03:03:50.187Z","comments":false,"path":"2020/06/10/algorithm/findFirstOneTimeChar/","link":"","permalink":"http://easyliu.com/2020/06/10/algorithm/findFirstOneTimeChar/","excerpt":"","text":"题目请实现一个函数，输入一个字符串，找出第一个只出现一次的字符。 输入“asdfasdfo” 输出‘o’ 实现12345678910111213141516public static char findFirstOneTimeChar(String input) &#123; if (input == null || input.length() &lt;= 0) &#123; return 0; &#125; char[] chars = input.toCharArray(); final int[] numArray = new int[256]; for (char curChar : chars) &#123; numArray[curChar]++; &#125; for (char curChar : chars) &#123; if (numArray[curChar] == 1) &#123; return curChar; &#125; &#125; return 0;&#125; 单元测试12345678910111213141516171819202122232425public class FindFirstOneTimeCharTest &#123; @Test public void testNulInput() &#123; Assert.assertEquals(FindFirstOneTimeChar.findFirstOneTimeChar(null), 0); &#125; @Test public void testEmptyInput() &#123; Assert.assertEquals(FindFirstOneTimeChar.findFirstOneTimeChar(\"\"), 0); &#125; @Test public void testSpaceInput() &#123; Assert.assertEquals(FindFirstOneTimeChar.findFirstOneTimeChar(\" \"), ' '); &#125; @Test public void testNormalInput() &#123; String input = \"asdfasdfo\"; char expect = 'o'; char result = FindFirstOneTimeChar.findFirstOneTimeChar(input); Assert.assertEquals(expect, result); &#125;&#125;","categories":[{"name":"每周三题","slug":"每周三题","permalink":"http://easyliu.com/categories/每周三题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"replaceSpace","slug":"algorithm/repalceSpace","date":"2020-06-07T07:37:57.000Z","updated":"2020-06-10T03:06:23.773Z","comments":false,"path":"2020/06/07/algorithm/repalceSpace/","link":"","permalink":"http://easyliu.com/2020/06/07/algorithm/repalceSpace/","excerpt":"","text":"题目请实现一个函数，把字符串中的每个空格替换为”%20”。 输入“We are happy” 输出“We%20are%20happy” 实现1234567891011121314151617181920212223242526272829 public static String replaceSpace(String input) &#123; if (input == null) &#123; return null; &#125; if (\"\".equals(input)) &#123; return null; &#125; //计算空格的个数 char[] chars = input.toCharArray(); int numOfSpace = 0; for (char curChar : chars) &#123; if (curChar == ' ') &#123; numOfSpace++; &#125; &#125; //创建一个新的字符数组 char[] newChars = new char[chars.length + numOfSpace * 2]; int indexOfNewChar = -1; for (char curChar : chars) &#123; if (curChar != ' ') &#123; newChars[++indexOfNewChar] = curChar; &#125; else &#123; newChars[++indexOfNewChar] = '%'; newChars[++indexOfNewChar] = '2'; newChars[++indexOfNewChar] = '0'; &#125; &#125; return String.valueOf(newChars);&#125; 单元测试123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.easyliu.test.replace_space;import org.junit.Assert;import org.junit.Test;public class ReplaceSpaceTest &#123; @Test public void testNullInput() &#123; Assert.assertNull(ReplaceSpace.replaceSpace(null)); &#125; @Test public void testEmptyInput() &#123; Assert.assertNull(ReplaceSpace.replaceSpace(\"\")); &#125; @Test public void testNormalSpace() &#123; String expect = \"we%20are%20happy\"; String result = ReplaceSpace.replaceSpace(\"we are happy\"); Assert.assertEquals(expect, result); &#125; @Test public void testMultiSpace() &#123; String expect = \"we%20%20are%20%20happy\"; String result = ReplaceSpace.replaceSpace(\"we are happy\"); Assert.assertEquals(expect, result); &#125; @Test public void testSingleSpace() &#123; String expect = \"%20\"; String result = ReplaceSpace.replaceSpace(\" \"); Assert.assertEquals(expect, result); &#125; @Test public void testNoSpace() &#123; String expect = \"we\"; String result = ReplaceSpace.replaceSpace(\"we\"); Assert.assertEquals(expect, result); &#125;&#125;","categories":[{"name":"每周三题","slug":"每周三题","permalink":"http://easyliu.com/categories/每周三题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"Android studio 快捷键","slug":"android/as_shortcut","date":"2020-05-30T03:38:43.000Z","updated":"2020-05-30T04:33:49.100Z","comments":false,"path":"2020/05/30/android/as_shortcut/","link":"","permalink":"http://easyliu.com/2020/05/30/android/as_shortcut/","excerpt":"","text":"重构快捷键shift+alt+M 选中抽取方法ctrl+alt+c 抽取常量","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://easyliu.com/categories/开发工具/"}],"tags":[{"name":"android","slug":"android","permalink":"http://easyliu.com/tags/android/"}]},{"title":"java代码规范","slug":"code/java_code_style","date":"2020-05-26T13:31:58.000Z","updated":"2020-05-30T04:27:58.837Z","comments":false,"path":"2020/05/26/code/java_code_style/","link":"","permalink":"http://easyliu.com/2020/05/26/code/java_code_style/","excerpt":"","text":"1、减少嵌套层级，提前返回2、一行不大于100个字符3、函数参数个数不宜过多，太多了考虑抽象成类4、private成员变量以m为前缀5、常量为全大写，以下划线拼接6、静态成员变量以s为前缀7、单个函数行数不宜过多，超过20 line就考虑抽取函数8、经常进行重构9、时常考虑抽象、封装、多态10、命名规则：精简但能清楚表达语义11、写函数的时候从方便单测的角度进行考虑，进行单测覆盖","categories":[{"name":"代码规范","slug":"代码规范","permalink":"http://easyliu.com/categories/代码规范/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"http://easyliu.com/tags/代码规范/"}]},{"title":"xcode快捷键","slug":"ios/xcode_shortcut","date":"2020-05-17T09:34:22.000Z","updated":"2020-05-30T05:15:02.829Z","comments":false,"path":"2020/05/17/ios/xcode_shortcut/","link":"","permalink":"http://easyliu.com/2020/05/17/ios/xcode_shortcut/","excerpt":"","text":"1、cmd+shift+j 在左边文件管理区定位到当前文件 2、cmd+shift+o 快速查找某个类，对应Android studio开发的话是shift+shift 3、ctrl+cmd+往左箭头或者往右箭头 光标返回到上一个选中的位置或者下一个选中的位置","categories":[{"name":"ios开发","slug":"ios开发","permalink":"http://easyliu.com/categories/ios开发/"}],"tags":[{"name":"ios开发","slug":"ios开发","permalink":"http://easyliu.com/tags/ios开发/"}]},{"title":"PowerMockIo单元测试基础语法","slug":"unit_test/unit_test","date":"2020-05-17T09:05:17.000Z","updated":"2020-05-17T09:14:52.356Z","comments":true,"path":"2020/05/17/unit_test/unit_test/","link":"","permalink":"http://easyliu.com/2020/05/17/unit_test/unit_test/","excerpt":"","text":"1、使用verifyPrivate来验证私有方法被调用//arrangeSeeVideoBoardTopStartVM fakeVm = PowerMockito.mock(SeeVideoBoardTopStartVM.class);Whitebox.setInternalState(mTestVm, “mSeeVideoBoardTopVM”, fakeVm);//actWhitebox.invokeMethod(mTestVm, “resetPlayer”);//assertPowerMockito.verifyPrivate(mTestVm).invoke(“setPlayStatus”, IUpdatePlayStatus.BEFORE);PowerMockito.verifyPrivate(fakeVm).invoke(“onUnbindView”); 2、PowerMockIo来mock静态方法：PowerMockito.mockStatic(AdaptiveUI.class);PowerMockito.when(AdaptiveUI.getCurUISizeType(Mockito.any(Context.class))).thenReturn(UISizeType.REGULAR); 3、调用private方法boolean result = Whitebox.invokeMethod(mBasePBSectionController, MOCK_METHOD, section);Assert.assertFalse(result); 4、模拟私有方法PowerMockito.when(mockPrivateClass, “privateFunc”).thenReturn(“test”); 5、mock公有方法PowerMockito.when(mTestVm.getTextViewWidth()).thenReturn(FAKE_TEXT_WIDTH); 6、设置私有成员变量Whitebox.setInternalState(mTestVm, “mSeeVideoBoardTopVM”, fakeVm); 7、当你需要使用PowerMock强大功能（Mock静态、final、私有方法等）的时候，就需要加注解@PrepareForTest8、如果一个对象，只希望mock它的部分方法，而其他方法希望和真实对象的行为一眼，可以使用PowerMockito.spy(Class clazz)代替PowerMockito.mock(Class clazz)方法，其后的设置依旧，这时，没有通过when设置过的方法，测试调用时，行为和真实对象一样","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://easyliu.com/categories/单元测试/"}],"tags":[{"name":"单元测试","slug":"单元测试","permalink":"http://easyliu.com/tags/单元测试/"}]},{"title":"Gradle基础之Grovy语法","slug":"android/Gradle基础之Grovy语法","date":"2018-02-11T15:56:14.000Z","updated":"2018-02-11T16:37:38.000Z","comments":true,"path":"2018/02/11/android/Gradle基础之Grovy语法/","link":"","permalink":"http://easyliu.com/2018/02/11/android/Gradle基础之Grovy语法/","excerpt":"","text":"Gradle基础之Groovy语法在使用Android Studio开发app的过程中，都会接触到Gradle配置，而Gradle的配置是基于Grovvy语法的。因此，要想熟练的使用Gradle进行配置，就必须熟悉Groovy语法，下面开始讲解下Groovy的基本语法。 Groovy可以看作是java的加强版，扩展了java的语法，拥有自己的一些特性。 Groovy语法官方文档 注释单行注释单行注释如下所示，跟java一样： 12// a standalone single line commentprintln \"hello\" // a comment till the end of the line 多行注释多行注释如下所示，跟java一样： 12345/* a standalone multiline comment spanning two lines */println \"hello\" /* a multiline comment starting at the end of a statement */println 1 /* one */ + 2 /* two */ GroovyDoc 注释GroovyDoc跟javaDoc语法也是一样的，如下所示： 1234567891011121314151617/** * A Class description */class Person &#123; /** the name of the person */ String name /** * Creates a greeting method for a certain person. * * @param otherPerson the person to greet * @return a greeting message */ String greet(String otherPerson) &#123; \"Hello $&#123;otherPerson&#125;\" &#125;&#125; Shebang line除了单行注释，还有一种特殊的单行注释，如下所示，叫做Shebang line（各位可以自行去翻译）。这行注释主要是便于unix理解，有了这行注释就可以直接在命令行运行groovy脚本文件啦。当然前提是电脑上要安装了Groovy，且要把Groovy加入path环境变量，注意这种注释中#必须是第一个字符，否则会报编译错误。 12#!/usr/bin/env groovyprintln \"Hello from the shebang line\" Groovy关键字Groovy语法的关键字如下所示： as assert break finally implements new switch trait case catch class false import null符号 switch true const continue def for in package this try default do else goto instanceof return throw while enum enum extends if interface super throws ### 标识符 #### 正常的标识符 标识符可以由字母、美元符号以及下划线开头，不能以数字开头。 字符的范围如下： * ‘a’ to ‘z’ (lowercase ascii letter) * ‘A’ to ‘Z’ (uppercase ascii letter) * ‘\\u00C0’ to ‘\\u00D6’ * ‘\\u00D8’ to ‘\\u00F6’ * ‘\\u00F8’ to ‘\\u00FF’ * ‘\\u0100’ to ‘\\uFFFE’ 如下为有效的标识符： 1234def namedef item3def with_underscoredef $dollarStart 如下的标识符就是非法的： 123def 3tierdef a+bdef a#b 所有的关键字如果跟在一个dot后面也都是合法的标识符： 12345foo.asfoo.assertfoo.breakfoo.casefoo.catch 引用标识符引用标识符出现在一个打点运算符之后，如下所示： 123456def map= [:]map.\"an identifier with a space and double quotes\" = \"ALLOWED\"map.'with-dash-signs-and-single-quotes' = \"ALLOWED\"assert map.\"an identifier with a space and double quotes\" == \"ALLOWED\"assert map.'with-dash-signs-and-single-quotes' == \"ALLOWED\" Groovy允许多种类型的字符串，后面会讲到。这些字符串都可以出现在打点运算符之后，如下所示： 123456map.'single quote'map.\"double quote\"map.'''triple single quote'''map.\"\"\"triple double quote\"\"\"map./slashy string/map.$/dollar slashy string/$ 有一种特殊的Groovy GStrings，也叫做插值字符串，如下所示： 123def firstname = \"Homer\"map.\"Simpson-$&#123;firstname&#125;\" = \"Homer Simpson\" //被插值为Simpson-Homerassert map.'Simpson-Homer' == \"Homer Simpson\" 字符串Groovy支持两种字符串，一种是java原生的java.lang.String，一种是groovy.lang.GString，叫做插值字符串。 单引号字符串单引号字符串就是java.lang.String，不支持插值，如下所示： 1'a single quoted string' 字符串连接所有的Groovy字符串均支持+操作，如下所示： 1assert 'ab' == 'a' + 'b' 三单引号字符串三单引号字符串如下所示： 1'''a triple single quoted string''' 三单引号支持多行，也是java.lang.String类型，不支持插值，如下所示： 1234567891011121314151617def aMultilineString = '''line oneline twoline three'''def startingAndEndingWithANewline = '''line oneline twoline three'''def strippedFirstNewline = '''\\line oneline twoline three'''assert !strippedFirstNewline.startsWith('\\n') 转义特殊字符可以使用反斜杠字符转义单引号字符，这样就可以避免字符串的终止： 1'an escaped single quote: \\' needs a backslash' 可以使用双重反斜杠转义反斜杠，如下所示： 1'an escaped escape character: \\\\ needs a double backslash' 如下所示为转义字符对照表： Unicode转义序列对于键盘上没有出现的字符，可以使用一个反斜杠+’u’+四个十六进制数字表示。例如欧元符号可以使用一下方式表示： 1'The Euro currency symbol: \\u20AC' 双引用字符串双引用字符串如下所示： 1\"a double quoted string\" 对于双引用字符串来说，如果其中没有插值表达式那就是java.lang.String类型，否则就是groovy.lang.GString类型。 字符串插值在Groovy所有的字符串字面量表示中，除了单引用和三引用字符串，其他的均支持插值。所谓字符串插值：就是将占位表达式的值替换到字符串中相应的位置当中，如下所示： 1234def name = 'Guillaume' // a plain stringdef greeting = \"Hello $&#123;name&#125;\" //把name插入到greeting当中assert greeting.toString() == 'Hello Guillaume' 还支持算数运算符： 12def sum = \"The sum of 2 and 3 equals $&#123;2 + 3&#125;\"assert sum.toString() == 'The sum of 2 and 3 equals 5' 在${}当中还支持表达式，如下所示： 1\"The sum of 1 and 2 is equal to $&#123;def a = 1; def b = 2; a + b&#125;\" 还支持$占位符，当使用点号表达式时： 12def person = [name: 'Guillaume', age: 36]assert \"$person.name is $person.age years old\" == 'Guillaume is 36 years old' 如下是非法的，会抛出groovy.lang.MissingPropertyException异常，因为系统会认为你在获取一个number的toString属性，从而报错。 1234def number = 3.14shouldFail(MissingPropertyException) &#123; println \"$number.toString()\"&#125; 如果你想去掉GString中的插值，只需要一个反斜杠即可： 1assert '$&#123;name&#125;' == \"\\$&#123;name&#125;\" //\"\\$&#123;name&#125;\"就和普通的'$&#123;name&#125;'相等了，因为去掉了插值 插值闭包表达式插值占位符还支持闭包表达式，如下所示： 12345def sParameterLessClosure = \"1 + 2 == $&#123;-&gt; 3&#125;\" //这个闭包表达式没有参数assert sParameterLessClosure == '1 + 2 == 3'def sOneParamClosure = \"1 + 2 == $&#123; w -&gt; w &lt;&lt; 3&#125;\" //这个闭包表达式有一个java.io.StringWriter类型的参数assert sOneParamClosure == '1 + 2 == 3' 闭包的一个最大的好处是惰性求值lazy evaluation，如下所示： 12345678910def number = 1def eagerGString = \"value == $&#123;number&#125;\"def lazyGString = \"value == $&#123; -&gt; number &#125;\"assert eagerGString == \"value == 1\"assert lazyGString == \"value == 1\"number = 2assert eagerGString == \"value == 1\" //eagerGString的值已经被固定了assert lazyGString == \"value == 2\" //lazyGString的值被重新计算 和java进行交互当一个方法需要java.lang.String参数，传入的却是一个GString类型的参数，这个参数的toString()方法就会被自动调用，看起来像我们可以直接将一个GString赋值给一个String变量一样： 1234567891011String takeString(String message) &#123; assert message instanceof String return message&#125;def message = \"The message is $&#123;'hello'&#125;\" assert message instanceof GString def result = takeString(message) assert result instanceof Stringassert result == 'The message is hello' GString和String的hashCodeGString和String的hashCode是不一样的，即便他们的最终结果是一样： 1assert \"one: $&#123;1&#125;\".hashCode() != \"one: 1\".hashCode() 因此在Map当中不能不能使用GString作为Key值，如下所示： 1234defkey= \"a\"def m = [\"$&#123;key&#125;\": \"letter $&#123;key&#125;\"] // key类型是一个GStringassert m[\"a\"] == null // 用一个普通String类型的key去取值,会找不到这个key,因此就会取不到值 三双引号字符串三双引号字符串类似于双引号字符串，但是是多行的，因此又类似于三引号字符串： 123456789101112def name = 'Groovy'def template = \"\"\" Dear Mr $&#123;name&#125;, You're the winner of the lottery! Yours sincerly, Dave\"\"\"assert template.toString().contains('Groovy') 斜线字符串除了使用引号来括住字符串，还可以使用/，斜线字符串一般用来定义正则表达式： 12def fooPattern = /.*foo.*/assert fooPattern == '.*foo.*' 只有正斜线需要用反斜线转义： 12def escapeSlash = /The character \\/ is a forward slash/assert escapeSlash == 'The character / is a forward slash' 斜线字符串是多行的： 12def escapeSlash = /The character \\/ is a forward slash/assert escapeSlash == 'The character / is a forward slash' 斜线字符串也可以被插值： 1234defcolor= 'blue'def interpolatedSlashy = /a $&#123;color&#125; car/assert interpolatedSlashy == 'a blue car' 注意：一个空的斜线字符串不能使用两个正斜线表示，因为Groovy会把其理解为注释。因此，下面的断言不会被编译，因为这个是一个非终止的语句： 1assert '' == // 美元斜线字符串这种字符串使用$/开始，使用/$结束，其中的转义字符为$： 123456789101112131415161718192021222324252627def name = \"Guillaume\"def date = \"April, 1st\"def dollarSlashy = $/ Hello $name, today we're $&#123;date&#125;. $ dollar sign $$ escaped dollar sign \\ backslash / forward slash $/ escaped forward slash $$$/ escaped opening dollar slashy $/$$ escaped closing dollar slashy/$assert [ 'Guillaume', 'April, 1st', '$ dollar sign', '$ escaped dollar sign', '\\\\ backslash', '/ forward slash', '/ escaped forward slash', '$/ escaped opening dollar slashy', '/$ escaped closing dollar slashy'].every &#123; dollarSlashy.contains(it) &#125; 字符串总结 字符Groovy当中并没有明确的字符字面量，需要明确指明： 12345678char c1 = 'A'assert c1 instanceof Characterdef c2 = 'B' as charassert c2 instanceof Characterdef c3 = (char)'C'assert c3 instanceof Character 数字Groovy支持不同类型的整型字面量和小数字面量。 整型字面量支持的整型字面量和java是一样的： byte char short int long java.lang.BigInteger 如下所示： 123456789// primitive typesbyte b = 1char c = 2short s = 3int i = 4long l = 5// infinite precisionBigInteger bi = 6 当使用def指明整数字面量时，变量的类型会根据数字的大小自动调整: 123456789101112131415161718def a = 1assert a instanceof Integer// Integer.MAX_VALUEdef b = 2147483647assert b instanceof Integer// Integer.MAX_VALUE + 1def c = 2147483648assert c instanceof Long// Long.MAX_VALUEdef d = 9223372036854775807assert d instanceof Long// Long.MAX_VALUE + 1def e = 9223372036854775808assert e instanceof BigInteger 对于负数也是如此： 123456789101112131415161718def na = -1assert na instanceof Integer// Integer.MIN_VALUEdef nb = -2147483648assert nb instanceof Integer// Integer.MIN_VALUE - 1def nc = -2147483649assert nc instanceof Long// Long.MIN_VALUEdef nd = -9223372036854775808assert nd instanceof Long// Long.MIN_VALUE - 1def ne = -9223372036854775809assert ne instanceof BigInteger 数字的非十进制表示数字可以用二进制、八进制、16进制以及小数表示。数字二进制表示如下，以ob开头： 1234567891011121314151617int xInt = 0b10101111assert xInt == 175short xShort = 0b11001001assert xShort == 201 as shortbyte xByte = 0b11assert xByte == 3 as bytelong xLong = 0b101101101101assert xLong == 2925lBigInteger xBigInteger = 0b111100100001assert xBigInteger == 3873gint xNegativeInt = -0b10101111assert xNegativeInt == -175 数字的八进制表示如下,以0开头： 1234567891011121314151617int xInt = 077assert xInt == 63short xShort = 011assert xShort == 9 as shortbyte xByte = 032assert xByte == 26 as bytelong xLong = 0246assert xLong == 166lBigInteger xBigInteger = 01111assert xBigInteger == 585gint xNegativeInt = -077assert xNegativeInt == -63 数字的16进制表示如下，以0x开头： 1234567891011121314151617181920int xInt = 0x77assert xInt == 119short xShort = 0xaaassert xShort == 170 as shortbyte xByte = 0x3aassert xByte == 58 as bytelong xLong = 0xffffassert xLong == 65535lBigInteger xBigInteger = 0xaaaaassert xBigInteger == 43690gDouble xDouble = new Double('0x1.0p0')assert xDouble == 1.0dint xNegativeInt = -0x77assert xNegativeInt == -119 小数字面量小数字面量也跟java是一样的： float double java.lang.BigDemical 如下所示： 123456// primitive typesfloat f = 1.234double d = 2.345// infinite precisionBigDecimal bd = 3.456 小数还支持科学计数法： 12345assert 1e3 == 1_000.0assert 2E4 == 20_000.0assert 3e+1 == 30.0assert 4E-2 == 0.04assert 5e-1 == 0.5 为了精确的计算小数，groovy选择java.lang.BigDecimal作为其小数类型。此外，float和double也是支持的小数类型，但是这俩类型需要一个显式类型声明、强制类型转换或后缀声明。 12def decimal = 123.456println decimal.getClass() // class java.lang.BigDecimal 字面中的下划线12345678long creditCardNumber = 1234_5678_9012_3456Llong socialSecurityNumbers = 999_99_9999Ldouble monetaryAmount = 12_345_132.12long hexBytes = 0xFF_EC_DE_5Elong hexWords = 0xFFEC_DE5Elong maxLong = 0x7fff_ffff_ffff_ffffLlong alsoMaxLong = 9_223_372_036_854_775_807Llong bytes = 0b11010010_01101001_10010100_10010010 数字类型后缀可以给一个数字加入后缀把其转换为指定类型，如下所示：Type|Suffix—|—BigInteger|G or gLong|L or lInteger|I or iBigDecimal|G or gDouble|D or dFloat|F or f 如下所示： 12345678910111213assert 42I == new Integer('42')assert 42i == new Integer('42') // lowercase i more readableassert 123L == new Long(\"123\") // uppercase L more readableassert 2147483648 == new Long('2147483648') // Long type used, value too large for an Integerassert 456G == new BigInteger('456')assert 456g == new BigInteger('456')assert 123.45 == new BigDecimal('123.45') // default BigDecimal type usedassert 1.200065D == new Double('1.200065')assert 1.234F == new Float('1.234')assert 1.23E23D == new Double('1.23E23')assert 0b1111L.class == Long // binaryassert 0xFFi.class == Integer // hexadecimalassert 034G.class == BigInteger // octal 数学运算以下是数学运算表（除法运算和指数运算例外）： 除法运算如果两个数中其中有一个是float或double类型，那么除法运算/或者/=得到的结果就是double类型，否则就是BigDemical类型。 指数运算运算表如下所示： 12345678910111213141516171819202122232425262728293031323334353637// base and exponent are ints and the result can be represented by an Integerassert 2 ** 3 instanceof Integer // 8assert 10 ** 9 instanceof Integer // 1_000_000_000// the base is a long, so fit the result in a Long// (although it could have fit in an Integer)assert 5L ** 2 instanceof Long // 25// the result can't be represented as an Integer or Long, so return a BigIntegerassert 100 ** 10 instanceof BigInteger // 10e20assert 1234 ** 123 instanceof BigInteger // 170515806212727042875...// the base is a BigDecimal and the exponent a negative int// but the result can be represented as an Integerassert 0.5 ** -2 instanceof Integer // 4// the base is an int, and the exponent a negative float// but again, the result can be represented as an Integerassert 1 ** -0.3f instanceof Integer // 1// the base is an int, and the exponent a negative int// but the result will be calculated as a Double// (both base and exponent are actually converted to doubles)assert 10 ** -1 instanceof Double // 0.1// the base is a BigDecimal, and the exponent is an int, so return a BigDecimalassert 1.2 ** 10 instanceof BigDecimal // 6.1917364224// the base is a float or double, and the exponent is an int// but the result can only be represented as a Double valueassert 3.4f ** 5 instanceof Double // 454.35430372146965assert 5.6d ** 2 instanceof Double // 31.359999999999996// the exponent is a decimal value// and the result can only be represented as a Double valueassert 7.8 ** 1.9 instanceof Double // 49.542708423868476assert 2 ** 0.1f instanceof Double // 1.0717734636432956 布尔型如下所示： 123def myBooleanVariable = trueboolean untypedBooleanVar = falseboolean Field = true true和false只是两个基础的布尔值，关于更复杂的boolean操作，参考：logical operators.special rules 列表ListGroovy列表就是java.util.List，默认的子类就是java.util.ArrayList，如下所示： 1234def numbers = [1, 2, 3] assert numbers instanceof List assert numbers.size() == 3 列表中可以支持各种类型： 1def heterogeneous = [1, \"a\", true] 还可以定义各种类型的List，默认是ArrayList: 12345678def arrayList = [1, 2, 3]assert arrayList instanceof java.util.ArrayListdef linkedList = [2, 3, 4] as LinkedList assert linkedList instanceof java.util.LinkedListLinkedList otherLinked = [3, 4, 5] assert otherLinked instanceof java.util.LinkedList 可以通过[]运算来获取列表的元素以及设置列表元素的值，下标可以是正数、负数、范围，还可以使用&lt;&lt;运算符来给list追加元素，如下所示： 1234567891011121314151617def letters = ['a', 'b', 'c', 'd']assert letters[0] == 'a' assert letters[1] == 'b'assert letters[-1] == 'd' //获取最后一个元素，-1是从数组末尾开始的第一个元素assert letters[-2] == 'c'letters[2] = 'C' //赋值 assert letters[2] == 'C'letters &lt;&lt; 'e' //在末尾追加一个元素 assert letters[ 4] == 'e'assert letters[-1] == 'e'assert letters[1, 3] == ['b', 'd'] // 一次性获取两个元素，返回一个新的List assert letters[2..4] == ['C', 'd', 'e'] //使用一个范围获取范围内的元素，返回一个新的List 还可以组成多维List： 12def multi = [[0, 1], [2, 3]] assert multi[1][0] == 2 数组数组需要显式定义数组的类型： 123456789String[] arrStr = ['Ananas', 'Banana', 'Kiwi'] assert arrStr instanceof String[] assert !(arrStr instanceof List)def numArr = [1, 2, 3] as int[] assert numArr instanceof int[] assert numArr.size() == 3 可以定义多维数组： 123456def matrix3 = new Integer[3][3] assert matrix3.size() == 3Integer[][] matrix2 matrix2 = [[1, 2], [3, 4]]assert matrix2 instanceof Integer[][] 获取数组元素的方式跟List一样： 12345String[] names = ['Cédric', 'Guillaume', 'Jochen', 'Paul']assert names[0] == 'Cédric' names[2] = 'Blackdrag' assert names[2] == 'Blackdrag' 映射表Maps如下所示： 123456789101112def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF'] assert colors['red'] == '#FF0000' assert colors.green == '#00FF00' colors['pink'] = '#FF00FF' colors.yellow = '#FFFF00' assert colors.pink == '#FF00FF'assert colors['yellow'] == '#FFFF00'assert colors instanceof java.util.LinkedHashMap //默认是LinkedHashMap类型 当获取一个map中不存在的key，会返回null: 1assert colors.unknown == null 除了使用string类型的key，还可以使用其他类型的key: 123def numbers = [1: 'one', 2: 'two']assert numbers[1] == 'one' 如果key是一个变量，如下所示： 12345def key = 'name'def person = [key: 'Guillaume'] //'Guilaume'对应的key为\"key\"，而不是变量key所关联的值 assert !person.containsKey('name') //不包含'name'这个keyassert person.containsKey('key') //包含'key'这个key 要想解决上述问题，可以如下所示： 12345def key = 'name'person = [(key): 'Guillaume'] //此时'Guilaume'对应的key就是变量key所对应的值 assert person.containsKey('name') assert !person.containsKey('key') 以上就是Groovy的基本语法，关于Groovy的语法特性，还包含一下几个方面，直接看官方文档即可，有兴趣的可以了解下。运算符 Operators程序结构 Program structureGroovy 面向对象语法 Object orientation 闭包 ClosuresGroovy 语义 Semantics","categories":[{"name":"Gradle相关","slug":"Gradle相关","permalink":"http://easyliu.com/categories/Gradle相关/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"SimpleSlidingMenu","slug":"android/SimpleSlidingMenu","date":"2017-05-14T03:26:19.000Z","updated":"2017-06-01T15:59:40.000Z","comments":true,"path":"2017/05/14/android/SimpleSlidingMenu/","link":"","permalink":"http://easyliu.com/2017/05/14/android/SimpleSlidingMenu/","excerpt":"","text":"概述一个简单的Android侧滑菜单，支持left, right,left_right三种菜单模式，支持edge,all两种滑动模式，支持设置菜单的宽度，支持滑动动画 效果如下每个Fragment里面是一个RecyclerView，解决了滑动冲突问题，包含滑动动画 使用方式12345678910111213141516171819202122232425private SlidingMenuLayout mSlideMenuLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSlideMenuLayout = new SlidingMenuLayout(this); setContentView(mSlideMenuLayout); initSlideMenuLayout(); &#125; private void initSlideMenuLayout() &#123; getSupportFragmentManager().beginTransaction() .replace(SlidingMenuLayout.LEFT_TAG, ItemFragment.newInstance(1)) .commit(); getSupportFragmentManager().beginTransaction() .replace(SlidingMenuLayout.MIDDLE_TAG, ItemFragment.newInstance(1)) .commit(); getSupportFragmentManager().beginTransaction() .replace(SlidingMenuLayout.RIGHT_TAG, ItemFragment.newInstance(1)) .commit(); mSlideMenuLayout.setBackgroundColor(Color.parseColor(\"#4876FF\")); mSlideMenuLayout.setMenuMode(SlidingMenuLayout.MenuMode.LEFT_RIGHT); mSlideMenuLayout.setSlidingMode(SlidingMenuLayout.SlidingMode.ALL); mSlideMenuLayout.setSlideEnable(true); mSlideMenuLayout.setMenuContentWidthRation(0.75f); &#125; 把SlidingMenuLayout作为根布局 左侧，中间，以及右侧菜单布局都会有一个tag，通过给每一个布局设置一个fragment即可！ 具体参考代码中的：MainActivity.java 关于滑动动画滑动动画主要是给SlideMenuLayout设置IOnMenuOpenListener接口，在接口里面对菜单以及中间视图进行一些缩放、透明度以及平移操作，从而达到动画效果，如下所示： 12345678910111213141516171819mSlideMenuLayout.setOnMenuOpenListener(new SlidingMenuLayout.IOnMenuOpenListener() &#123; @Override public void menuOpen(View menuView, View middleView, float openPercent, boolean isLeftMenu) &#123; float menuScale = (float) (0.8 + 0.2 * openPercent);//0.8到1 float contentScale = (float) (1 - 0.2 * openPercent);//1到0.8 float translationXScale = 0; if (isLeftMenu) &#123; translationXScale = (1 - openPercent) * 0.6f;//范围是0.6到0 &#125; else &#123; translationXScale = -(1 - openPercent) * 0.6f;//范围是-0.6到0 &#125; menuView.setScaleX(menuScale); menuView.setScaleY(menuScale); menuView.setAlpha(openPercent); menuView.setTranslationX(menuView.getWidth() * translationXScale); middleView.setScaleX(contentScale); middleView.setScaleY(contentScale); &#125; &#125;); 代码地址：https://github.com/EasyLiu-Ly/SimpleSlidingMenu.git","categories":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://easyliu.com/categories/Android自定义控件/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"SlideFinishActivity","slug":"android/SlideFinishActivity","date":"2017-05-14T03:07:05.000Z","updated":"2017-06-01T15:59:44.000Z","comments":true,"path":"2017/05/14/android/SlideFinishActivity/","link":"","permalink":"http://easyliu.com/2017/05/14/android/SlideFinishActivity/","excerpt":"","text":"概述让Activity跟随者手指的滑动而滑动，当向右滑动到一定距离或者往右滑动到达一定速度就finish，类似于微信滑动finish的效果。 效果如下 支持边界滑动和全屏滑动两种模式 解决了滑动冲突问题，例如上图中Activity当中就包含了ViewPager，解决了和ViewPager的滑动冲突问题 使用方式如下 自定义的Activity继承自BaseSlideFinishActivity 自定义的Activity的主题需要包含以下两个属性12&lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; 滑动动画在滑动的时候，可以实现滑动动画效果，如下所示，类似于酷狗播放界面滑动Finish的效果。具体实现查看SlideFinishRelativeLayout中的IOnSlideFinishChangeListener接口，在BaseSlideFinishActivity当中实现了这个接口，在这个接口里面对顶层视图进行rotation操作即可。 代码地址：https://github.com/EasyLiu-Ly/SlideFinishActivity.git","categories":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://easyliu.com/categories/Android自定义控件/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android应用层View触摸事件分发机制","slug":"android/ViewDispatchTouchEvent","date":"2017-04-24T14:39:11.000Z","updated":"2017-06-01T15:56:50.000Z","comments":true,"path":"2017/04/24/android/ViewDispatchTouchEvent/","link":"","permalink":"http://easyliu.com/2017/04/24/android/ViewDispatchTouchEvent/","excerpt":"","text":"概述前两篇博客从源码的角度对View绘制流程进行了分析，那么当用户需要跟View进行交互的时候，比如点击按钮的时候，按钮是如何得到点击事件的呢？当用户在屏幕上进行点击或触摸的时候，事件是如何传递到各个View的呢？这个就是本篇博客研究的点：View事件分发机制。只有同时掌握View事件分发机和View绘制流程，并辅以一定的练习，才能真正掌握自定义View。下面开始进入正题！注：源码基于API25。 触摸事件的来源及View事件分发入口还记得之前说过，在Activity的attach方法里面会新建一个PhoneWindow作为顶层Window，如下所示： 12345678910111213141516171819final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); .......... .......... &#125; 在上面的代码当中有一句：mWindow.setCallback(this),这句话给Window设置了一个Callback回调接口给Activity,来看一下这个回调接口： 1234567891011121314151617181920212223/** * API from a Window back to its caller. This allows the client to * intercept key dispatching, panels and menus, etc. */ public interface Callback &#123; public boolean dispatchKeyEvent(KeyEvent event); public boolean dispatchKeyShortcutEvent(KeyEvent event); /** * Called to process touch screen events. At the very least your * implementation must call * &#123;@link android.view.Window#superDispatchTouchEvent&#125; to do the * standard touch screen processing. * * @param event The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent event); ............. 可以发现这个回调接口里面有很多回调方法，前三个方法都是对事件进行分发，第三个方法dispatchTouchEvent就是触摸事件分发。当android系统发生触摸事件时，会把触摸事件发送给顶层Window（至于是怎么传递给Window的，这里暂时不深入研究，涉及到WindowManager,WindowManagerService等跨进程的调用过程，也涉及到Activity的启动过程分析）,这里是PhoneWindow,由于给PhoneWindow设置了回调接口，在Activity当中实现了这个接口，因此，我们查看Activity当中的dispatchTouchEvent方法，如下所示： 12345678910111213141516171819/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 可以看出，如果Action为ACTION_DOWN,首先会调用onUserInteraction方法，这个方法如下所示： 123456789101112131415161718192021/** * Called whenever a key, touch, or trackball event is dispatched to the * activity. Implement this method if you wish to know that the user has * interacted with the device in some way while your activity is running. * This callback and &#123;@link #onUserLeaveHint&#125; are intended to help * activities manage status bar notifications intelligently; specifically, * for helping activities determine the proper time to cancel a notfication. * * &lt;p&gt;All calls to your activity's &#123;@link #onUserLeaveHint&#125; callback will * be accompanied by calls to &#123;@link #onUserInteraction&#125;. This * ensures that your activity will be told of relevant user activity such * as pulling down the notification pane and touching an item there. * * &lt;p&gt;Note that this callback will be invoked for the touch down action * that begins a touch gesture, but may not be invoked for the touch-moved * and touch-up actions that follow. * * @see #onUserLeaveHint() */ public void onUserInteraction() &#123; &#125; 关于这个方法，注释已经说的很明白了，一般和onUserLeaveHint方法配对使用，主要是用来帮助Activity管理状态栏通知。 调用完onUserInteraction方法之后，就会调用getWindow.superDispatchTouchEvent方法，也就是调用PhoneWindow的superDispatchTouchEvent方法。如果这个方法返回true,就直接返回true,否则会调用Activity的onTouchEvent方法。 我们可以在Activity重写dispatchTouchEvent方法来对所有的触摸事件进行拦截，防止其分发至window。 当Activity的onTouchEvent被调用的时候，说明Window的superDispatchTouchEvent方法返回false,也就是没有消耗事件，事件最终交给Activity进行处理，因此我们也可以在Activity当中重写onTouchEvent方法来进行事件处理。 来看下PhoneWindow的superDispatchTouchEvent方法： 1234@Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125; 可以看出其调用的是顶层视图DecorView的superDispatchTouchEvent方法，如下所示： 123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; 可以看出，DecorView调用了其父类的dispatchTouchEvent方法，跳进去看发现调用的是ViewGroup的dispatchTouchEvent方法。这个也可以理解，因为DecorView是继承自FrameLayout，而FrameLayout是继承自ViewGroup。 通过以上分析可以看出，View触摸事件的入口是DecorView, 也就是ViewGroup。整个事触摸件的传递过程如下：**-&gt; 顶层PhoneWindow得到触摸事件，调用其dispatchTouchEvent方法-&gt; Activity当中收到dispatchTouchEvent回调方法，调用mWindow的superDispatchTouchEvent方法-&gt; 调用PhoneWindow的superDispatchTouchEvent方法-&gt; 调用DecorView的superDispatchTouchEvent方法-&gt; 最终调用ViewGroup的dispatchTouchEvent方法-&gt; View触摸事件分发入口** ViewGroup事件分发机制既然View触摸事件的入口是ViewGroup的dispatchTouchEvent方法，说明这个方法至关重要，接下来看下这个dispatchTouchEvent方法,这个方法比较长，我会在代码中加入注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224public boolean dispatchTouchEvent(MotionEvent ev) &#123; ................ boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; //ACTION_DOWN的话就恢复初始状态，清除TouchTarget if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // 检测事件拦截 final boolean intercepted;//这个标志用于是否拦截事件，如果拦截的话，就交给自身的这个ViewGroup进行处理 //如果是ACTION_DOWN或者mFirstTouchTarget不为空（说明已经有了TouchTarget），就开始判断是否拦截事件 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //是否不允许拦截，在ViewGroup当中有一个requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法 //这个函数可以用来设置是否拦截，一般用在子View当中，通过调用父View的这个方法来阻止父View拦截事件 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; //允许拦截的话，就调用onInterceptTouchEvent方法，一般我们需要重写这个方法，来根据需求来进行事件拦截 if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; //不允许拦截 intercepted = false; &#125; &#125; else &#123; //如果没有TouchTarget且当前action不是初始的ACTION_DOWN,就拦截 //如果当前ViewGroup拦截了ACTION_DOWN,那么剩下的ACTION_UP,ACTION_MOVE事件都是交给它处理，且onInterceptTouchEvent方法 // 不会再次调用，因为此时mFirstTouchTarget==null且action!=ACTION_DOWN // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //如果事件没有取消且没有拦截事件 if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; //发现没有，这里只是对ACTION_DOWN进行处理，那么ACTION_UP和ACTION_MOVE呢？ if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. //开始遍历子View，找到能够接收事件的子View final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; //判断子view是否能接收pointer事件或者当前的触摸点在子view的边界内， //如果这两个没有一个满足，就continue，跳到循环的下一步，也就是下一个子view if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); // 如果child已经接收了触摸事件 if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // 这个函数内部调用了child.dispatchTouchEvent方法 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // 有子View接收这个事件 // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //把child的TouchTarget加入到链表的开头且返回child的TouchTarget newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; //这里有三种情况：一种是当前ViewGroup拦截了事件，一种是没有子View，还有一种是子View的dispatchTouchEvent方法返回了false //这三种情况下就交给当前ViewGroup进行处理 // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // 我们发现前面只是对ACTION_DOWN进行了分发,当某个子当某个子View返回true时，会中止Down事件的分发， // 同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理,如下所示。 // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 以上对ViewGroup的dispatchTouchEvent方法进行了分析，总结如下： 1、每次当触摸事件为ACTION_DOWN的时候就会清除之前的状态，开始一次新的事件分发2、如果当前ViewGroup拦截了ACTION_DOWN,那么剩下的ACTION_UP,ACTION_MOVE事件都是交给它处理3、在自定义继承自ViewGroup的View的时候，通过重写onInterceptTouchEvent对事件进行拦截，事件拦截仅仅是针对于ViewGroup，对于View来说不存在事件拦截的说法4、ViewGroup当中有一个requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法，可以用来设置是否拦截，一般用在子View当中，通过调用父View的这个方法来阻止父View进行事件拦截5、有三种情况，触摸事件会交给当前的ViewGroup进行处理，此时就把ViewGroup当成普通的View,走的是View事件分发逻辑，调用的是View的dispatchTouchEvent方法： 一种是当前ViewGroup拦截了事件 一种是没有子View， 还有一种是子View的dispatchTouchEvent方法返回了false 6、事件分发只是针对ACTION_DOWN进行了分发,当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理！这个就有点类似于：一旦一个活交给你干了，你就得干到底的意思！ View事件分发机制之dispatchTouchEvent方法以上讲的是ViewGroup的事件分发机制，对于View来说，触摸事件都是由父ViewGroup分发而来，调用的是View的dispatchTouchEvent方法，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; // 如果满足：mOnTouchListener!=null、View是ENABLED的、mOnTouchListener的onTouch方法返回true,那么result为true if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; //如果上面的result为true，那么就不会调用下面的onTouchEvent方法 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 可以看出： 如果View是使能的、设置了TouchListener接口、接口中的onTouch方法返回true的话，这三个条件同时满足的话就不会调用下面的onTouchEvent方法！ 比如对于一个Button, 如果它是使能的，且给它设置一个TouchListener，在onTouch方法里面返回true，那么就无法响应点击事件（这个大家可以验证一下）， 按钮的点击事件以及长按事件是在onTouchEvent方法里面响应的 当View不使能的时候，是可以继续调用onTouchEvent方法的 如果onTouchEvent返回true,那么整个dispatchTouchEvent也就返回true，代表当前View消耗了事件。 View事件分发机制之onTouchEvent方法来看下onTouchEvent方法，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); // view不使能 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; //ACTION_UP事件，设置按下状态为false if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; //一个不使能的view,如果是可点击的依然会消耗这个事件，比如button,即使是不使能的，也会返回true消耗事件，只是不对事件作出响应而已。 //因为button默认是可点击的，除非手动设置为不可点击 // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; // 如果设置了触摸代理，调用触摸代理的onTouchEvent方法，如果返回true,就消耗事件。 // 这个触摸代理常常用在扩大View的点击区域，比如一个图标太小，就可以扩大其点击区域 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; // 如果是可点击的 if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // 如果View还没有获得焦点的话就主动获得焦点 // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; // 如果长按的动作没有发生且没有忽略下一个ACTION_UP事件 if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // 移除长按检测 // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. //这个PerformClick是一个Runnable对象 if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; //把mPerformClick给post到消息队列 if (!post(mPerformClick)) &#123; // 如果上述Runnable执行失败，就直接调用performClick方法，在这个方法里面调用 // OnClickListener回调接口 performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away // 设置为按下状态 setPressed(true, x, y); // 检测长按，如果长按下成功，会把mHasPerformedLongPress置为true，这样点击事件就得不到响应 // 也就是说长按事件会屏蔽点击事件 checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: //复位 setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false; &#125; 从以上代码可以看出： 一个不使能的view,如果是可点击的依然会消耗这个事件，比如button,即使是不使能的，也会返回true消耗事件，只是不对事件作出响应而已。因为button默认是可点击的，除非手动设置为不可点击 这要这个View是可点击的，不管是否使能，都会消耗事件 如果长按检测成功，会把mHasPerformedLongPress置为true，这样点击事件就得不到响应，也就是说长按事件会屏蔽点击事件 还有一点，像ImageView这种控件默认是不可点击的，但是如果给它设置OnClickListener或者onLongClickListener的话，就会主动把其设置为可点击 以上从源码的角度对触摸事件的来源、ViewGroup事件分发机制、View事件分发机制进行了解读。在自定义View的时候，当需要对触摸事件进行处理的时候，一般是重写onTouchEvent方法，拥有子类的View一般还需要重写onInterceptTouchEvent方法进行事件拦截，要想让这两个方法很好的配合使用，就需要熟悉并且理解触摸事件分发机制，再配合之前的View绘制流程，就能自定义出各式各样的View啦！ 感谢大家的阅读！有啥问题，欢迎指出，谢谢！","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android应用层View绘制流程之measure,layout,draw三步曲","slug":"android/ViewInvalidteProcessTwo","date":"2017-04-22T13:20:18.000Z","updated":"2017-06-01T15:57:10.000Z","comments":true,"path":"2017/04/22/android/ViewInvalidteProcessTwo/","link":"","permalink":"http://easyliu.com/2017/04/22/android/ViewInvalidteProcessTwo/","excerpt":"","text":"概述上一篇博文对DecorView和ViewRootImpl的关系进行了剖析，这篇文章主要是来剖析View绘制的三个基本流程:measure,layout,draw，只有把这三个基本流程搞清楚了，平时在自定义View的时候才会有清晰的思路！开始进入正题。 View的measure过程三个流程均是从ViewRootImpl的performTraversals方法开始的，如下所示： 123456789101112private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ...... mView.draw(canvas); ...... &#125; 首先看下getRootMeasureSpec方法,如下所示： 1234567891011121314151617181920212223242526272829303132/** * Figures out the measure spec for the root view in a window based on it's * layout params. * * @param windowSize * The available width or height of the window * * @param rootDimension * The layout params for one dimension (width or height) of the * window. * * @return The measure spec to use to measure the root view. */ private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec; &#125; 从上面的注释可以看出这个getRootMeasureSpec是为了根据根视图的LayoutParams计算根视图的MeasureSpec，这个根视图就是上篇博客讲的DecorView。 关于MeasureSpec关于MeasureSpec来做一个简单的说明：通过MeasureSpec.makeMeasureSpec来得到一个32位的整数，高两位代码测量模式mode,低30位代表测量大小size，如下所示： 12345678public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; 然后再通过getMode和getSize这两个方法来得到对应的测试模式mode和测量尺寸size，如下所示： 1234567891011121314151617181920212223/** * Extracts the mode from the supplied measure specification. * * @param measureSpec the measure specification to extract the mode from * @return &#123;@link android.view.View.MeasureSpec#UNSPECIFIED&#125;, * &#123;@link android.view.View.MeasureSpec#AT_MOST&#125; or * &#123;@link android.view.View.MeasureSpec#EXACTLY&#125; */ @MeasureSpecMode public static int getMode(int measureSpec) &#123; //noinspection ResourceType return (measureSpec &amp; MODE_MASK); &#125; /** * Extracts the size from the supplied measure specification. * * @param measureSpec the measure specification to extract the size from * @return the size in pixels defined in the supplied measure specification */ public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; View的measure和onMeasure方法通过getRootMeasureSpec来得到DecorView的widthMeasureSpec和heightMeasureSpec之后，就需要来设置DecorView的大小了，也就是调用： 1mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); 发现这个measure是View的方法，如下所示： 12345678910111213141516171819202122232425/** * &lt;p&gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * &lt;/p&gt; * * &lt;p&gt; * The actual measurement work of a view is performed in * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses. * &lt;/p&gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */ public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ........... onMeasure(widthMeasureSpec, heightMeasureSpec); ........... &#125; 通过注释可以看出，这个方法是用来计算当前View应该为多大，也就是实际的宽高。widthMeasureSpec和heightMeasureSpec是由父View传入的约束信息，代表了父View给当前View的测量规格，当前View的宽高是由父View和自身一起决定的。measure方法是final的，不可重载，实际的测量过程是在onMeasure方法里面完成了，因此子类必须且只能重载onMeasure方法来实现自身的测量逻辑。 接下来看onMeasure方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * &lt;p&gt; * Measure the view and its content to determine the measured width and the * measured height. This method is invoked by &#123;@link #measure(int, int)&#125; and * should be overridden by subclasses to provide accurate and efficient * measurement of their contents. * &lt;/p&gt; * * &lt;p&gt; * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you * &lt;em&gt;must&lt;/em&gt; call &#123;@link #setMeasuredDimension(int, int)&#125; to store the * measured width and height of this view. Failure to do so will trigger an * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by * &#123;@link #measure(int, int)&#125;. Calling the superclass' * &#123;@link #onMeasure(int, int)&#125; is a valid use. * &lt;/p&gt; * * &lt;p&gt; * The base class implementation of measure defaults to the background size, * unless a larger size is allowed by the MeasureSpec. Subclasses should * override &#123;@link #onMeasure(int, int)&#125; to provide better measurements of * their content. * &lt;/p&gt; * * &lt;p&gt; * If this method is overridden, it is the subclass's responsibility to make * sure the measured height and width are at least the view's minimum height * and width (&#123;@link #getSuggestedMinimumHeight()&#125; and * &#123;@link #getSuggestedMinimumWidth()&#125;). * &lt;/p&gt; * * @param widthMeasureSpec horizontal space requirements as imposed by the parent. * The requirements are encoded with * &#123;@link android.view.View.MeasureSpec&#125;. * @param heightMeasureSpec vertical space requirements as imposed by the parent. * The requirements are encoded with * &#123;@link android.view.View.MeasureSpec&#125;. * * @see #getMeasuredWidth() * @see #getMeasuredHeight() * @see #setMeasuredDimension(int, int) * @see #getSuggestedMinimumHeight() * @see #getSuggestedMinimumWidth() * @see android.view.View.MeasureSpec#getMode(int) * @see android.view.View.MeasureSpec#getSize(int) */ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 注释已经写的非常明白了，子类必须复写onMeasure方法，且最终通过调用setMeasuredDimension方法来存储当前View测量得到的宽和高。这个宽和高是通过getDefaultSize方法得来的，如下所示： 12345678910111213141516171819202122232425/** * Utility to return a default size. Uses the supplied size if the * MeasureSpec imposed no constraints. Will get larger if allowed * by the MeasureSpec. * * @param size Default size for this view * @param measureSpec Constraints imposed by the parent * @return The size this view should be. */ public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; 可以看出，如果specMode等于AT_MOST或者EXACTLY就返回specSize，也就是父类指定的specSize，否则返回通过getSuggestedMinimumWidth和getSuggestedMinimumHeight得到的size，从名字可以看出是建议的最小宽度和高度，代码如下所示： 1234567protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125;protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125; 可以看出，建议的最小宽度和高度是由view的background以及其mMinWidth、mMinHeight共同决定的。 setMeasuredDimension方法如下所示： 12345678910111213141516171819protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; &#125; setMeasuredDimensionRaw(measuredWidth, measuredHeight);&#125;private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123; mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;&#125; 可以看出这个方法就是给mMeasuredHeight和mMeasuredWidth进行赋值。进行了赋值之后调用View 的getMeasuredWidth和getMeasuredHeight方法才能得到其正确的测量宽高！ ViewGroup的measure过程上面提到View的measure方法传入的widthMeasureSpec和heightMeasureSpec是由父View传入的约束信息，那么这些信息是何时传入的呢？由于View是嵌套的，因此measure过程也是递归传递的，子View的measure是由父类调用的，然后子View根据传入的父类约束来设置自身的测量规格。 ** 继承自ViewGroup的视图均需要实现onMeasure方法，在这个方法里面对其子View进行测量，同时也对自身进行测量，比如LinearLayout的onMeasure方法如下：** 12345678@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125; &#125; 根据布局的方向分别调用measureHorizontal和measureVertical方法。 在ViewGroup中定义了measureChildren, measureChild, measureChildWithMargins方法来对子视图进行测量。measureChildren内部循环调用了measureChild。measureChild和measureChildWithMargins的区别在于measureChildWithMargins把child的margin也考虑在内。下面来对measureChildWithMargins方法来分析： 12345678910111213141516171819202122232425262728/** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding * and margins. The child must have MarginLayoutParams The heavy lifting is * done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param widthUsed Extra space that has been used up by the parent * horizontally (possibly by other children of the parent) * @param parentHeightMeasureSpec The height requirements for this view * @param heightUsed Extra space that has been used up by the parent * vertically (possibly by other children of the parent) */ protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //子视图的测量规格是由父视图的测量测量规格以及子视图的LayoutParams来共同决定的 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //调用子视图的measure方法来设置子视图的测量规格 child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 从以上代码可以看出：子视图的测量规格是由父视图的测量测量规格以及子视图的LayoutParams来共同决定的，因此关键函数是getChildMeasureSpec函数，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * Does the hard part of measureChildren: figuring out the MeasureSpec to * pass to a particular child. This method figures out the right MeasureSpec * for one dimension (height or width) of one child view. * * The goal is to combine information from our MeasureSpec with the * LayoutParams of the child to get the best possible results. For example, * if the this view knows its size (because its MeasureSpec has a mode of * EXACTLY), and the child has indicated in its LayoutParams that it wants * to be the same size as the parent, the parent should ask the child to * layout given an exact size. * * @param spec The requirements for this view * @param padding The padding of this view for the current dimension and * margins, if applicable * @param childDimension How big the child wants to be in the current * dimension * @return a MeasureSpec integer for the child */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec);//得到父视图的mode int specSize = MeasureSpec.getSize(spec);//得到父视图的size //得到Parent视图剩余的大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; //根据Parent视图的specMode来进行分支判断 switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY://父类是精确模式 if (childDimension &gt;= 0) &#123; //子视图是精确模式，直接设置了精确的大小（在xml当中设置了layout_width=\"xxx\"或者在代码中设置了具体的数值),子视图的size就是精确值,子视图的mode就是EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; //如果子视图的layout_width或者layout_height为MATCH_PARENT,也就是为父视图的大小，那么子视图的size就是Parent视图剩余的大小，且mode与父类相同，也为EXACTLY // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; //如果子视图的layout_width或者layout_height为WRAP_CONTENT,也就是不超过父视图的大小，那么子视图的size为size，且mode为AT_MOST。 // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; //子视图是精确模式，直接设置了精确的大小（在xml当中设置了layout_width=\"xxx\"或者在代码中设置了具体的数值),子视图的size就是精确值,子视图的mode就是EXACTLY // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; //如果子视图的layout_width或者layout_height为MATCH_PARENT,也就是为父视图的大小，那么子视图的size就是Parent视图剩余的大小，且mode与父类相同，也是AT_MOST。 // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; //如果子视图的layout_width或者layout_height为WRAP_CONTENT,也就是不超过父视图的大小，那么子视图的size为size，且mode为AT_MOST。 // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; // 将resultSize和resultMode进行组装为32为整数返回 //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 可以看到，getChildMeasureSpec就是根据父视图的specSize和specMode以及child视图的LayoutParams来确定子视图的resultSize和resultMode，然后把resultSize和resultMode进行组装成32位的整数，作为child.measure的参数来对子视图进行测量。 ** 有一个需要特别注意的地方：** 当childDimension == LayoutParams.WRAP_CONTENT的时候，其specSize和specMode分别为父视图的size和MeasureSpec.AT_MOST。 再回到上面的View测量过程当中的getDefaultSize方法，如下所示。我们发现当View的specMode为AT_MOST的时候，其size默认就是parent视图的size! 因此，在我们自定义View的时候，需要考虑当specMode为AT_MOST的时候（也就是在xml布局当中设置为WRAP_CONTENT的时候）给当前View的宽高设置一个具体的值，大家可以去看看比如TextView的源代码，均对WRAP_CONTENT的情况进行了特殊的处理！ 123456789101112public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); ...... case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 以上就是View和ViewGroup的measure过程,在ViewGroup的实现视图当中递归调用子视图的的measure方法来实现整个View树的测量。在自定义View的时候，当我们需要对View的尺寸进行更改的时候，需要实现onMeasure方法，在里面根据父视图给的specSize和specMode来设置当前View的specMode和specSize,需要注意的是当父视图给的specMode==AT_MOST的时候，需要给当前View的宽高设置一个具体的值。 View的layout过程讲完了View的measure过程，接下来就是layout过程。那么这个layout过程是干什么的呢？在measure过程当中设置了view的宽高，那么设置了宽高之后，具体view是显示在屏幕的哪个位置呢？这个就是layout过程干的事。 layout跟measure一样，也是递归结构，来看下View的layout方法： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Assign a size and position to a view and all of its * descendants * * &lt;p&gt;This is the second phase of the layout mechanism. * (The first is measuring). In this phase, each parent calls * layout on all of its children to position them. * This is typically done using the child measurements * that were stored in the measure pass().&lt;/p&gt; * * &lt;p&gt;Derived classes should not override this method. * Derived classes with children should override * onLayout. In that method, they should * call layout on each of their children.&lt;/p&gt; * * @param l Left position, relative to parent * @param t Top position, relative to parent * @param r Right position, relative to parent * @param b Bottom position, relative to parent */ @SuppressWarnings(&#123;\"unchecked\"&#125;) public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //setFrame方法把参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量 //判断布局是否发生改变 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); ........ &#125; ...... &#125; 在layout方法里面首先通过setFrame来设置自身的位置，然后调用了onLayout方法，是不是跟measure方法里面调用onMeasure方法类似！来看下onLayout方法： 123456789101112131415/** * Called from layout when this view should * assign a size and position to each of its children. * * Derived classes with children should override * this method and call layout on each of * their children. * @param changed This is a new size or position for this view * @param left Left position, relative to parent * @param top Top position, relative to parent * @param right Right position, relative to parent * @param bottom Bottom position, relative to parent */ protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; &#125; 发现onLayout是一个空方法，通过注释可以看出：具有子视图的子类需要重写这个onLayout方法并且调用其每一个子视图的layout方法。这就完全明白了：也就是说直接或者间接继承自ViewGroup的视图需要重写onLayout方法，然后调用其每个子视图的layout方法来设置子视图的位置！我们可以查看LinearLayout，其肯定是实现了onLayout方法，在这个方法里面来一一设置子视图的位置！LinearLayout的onLayout方法如下所示： 12345678@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125; &#125; 来看下layoutVertical方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Position the children during a layout pass if the orientation of this * LinearLayout is set to &#123;@link #VERTICAL&#125;. * * @see #getOrientation() * @see #setOrientation(int) * @see #onLayout(boolean, int, int, int, int) * @param left * @param top * @param right * @param bottom */ void layoutVertical(int left, int top, int right, int bottom) &#123; final int paddingLeft = mPaddingLeft; int childTop; int childLeft; // Where right end of child should go final int width = right - left; int childRight = width - mPaddingRight; //child可以使用的空间 // Space available for child int childSpace = width - paddingLeft - mPaddingRight; //得到 child的个数 final int count = getVirtualChildCount(); final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK; final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK; //根据majorGravity计算childTop的位置 switch (majorGravity) &#123; case Gravity.BOTTOM: // mTotalLength contains the padding already childTop = mPaddingTop + bottom - top - mTotalLength; break; // mTotalLength contains the padding already case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; &#125; // 开始进行遍历child视图 for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123;//child不为GONE,因为GONE是不占空间的 final int childWidth = child.getMeasuredWidth();// 得到onMeasure之后的测量宽度 final int childHeight = child.getMeasuredHeight();// 得到onMeasure之后的测量高度 final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); // 根据absoluteGravity计算childLeft的值 switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; &#125; if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; //通过setChildFrame函数来设置child的位置， setChildFrame函数如下所示 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125; &#125; private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height); &#125; 上面这个方法还是比较易懂的，主要就是调用child的layout方法来设置child的位置，当我们给一个View设置好位置之后，其内部的四个变量mLeft、mTop、mRight和mBottom也就确定了，不过要注意这些值都是相对父视图而言的，而不是相对整个屏幕而言的。这个四个变量是通过以下方式获取的。 1234567891011121314151617181920212223public final int getWidth() &#123; return mRight - mLeft; &#125; public final int getHeight() &#123; return mBottom - mTop; &#125; public final int getLeft() &#123; return mLeft; &#125; public final int getRight() &#123; return mRight; &#125; public final int getTop() &#123; return mTop; &#125; public final int getBottom() &#123; return mBottom; &#125; 在View当中还有下面两个函数，这也解释了为什么有时候getWidth()和getMeasuredWidth()以及getHeight()和getMeasuredHeight()会得到不同的值的原因。 1234567public final int getMeasuredWidth() &#123; return mMeasuredWidth &amp; MEASURED_SIZE_MASK; &#125; public final int getMeasuredHeight() &#123; return mMeasuredHeight &amp; MEASURED_SIZE_MASK; &#125; 以上就是View的layout过程，layout相对measure过程来说还是算比较简单的。 ** 总结起来就是：直接或者间接继承自ViewGroup的视图需要重写onLayout方法，然后调用其每个子视图的layout方法来设置子视图的位置。** View的draw过程讲完了View的layout流程，接下来就是draw流程，draw负责对view进行绘制。在ViewRootImpl的drawSoftware方法当中： 123456789101112131415161718192021/** * @return true if drawing was successful, false if an error occurred */ private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; final int left = dirty.left; final int top = dirty.top; final int right = dirty.right; final int bottom = dirty.bottom; canvas = mSurface.lockCanvas(dirty); ................ mView.draw(canvas); ......... return true; &#125; 在上述方法当中调用了mView的draw方法，来看View的draw方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * &#123;@link #onDraw(android.graphics.Canvas)&#125; instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered. */ @CallSuper public void draw(Canvas canvas) &#123; ............... /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; ........ // skip step 2 &amp; 5 if possible (common case) ....... // Step 2, save the canvas' layers if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; ........ // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); &#125; ............... // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); &#125; 通过注释可以看出整个绘制过程分为6部分，在大多数情况下第2步和第5步可以跳过，在自定义View的时候需要实现onDraw方法而不是实现draw方法。接下来对剩下的四步进行分析： 第一步：绘制背景 通过调用drawBackground方法实现123456789101112131415161718private void drawBackground(Canvas canvas) &#123; final Drawable background = mBackground; if (background == null) &#123; return; &#125; setBackgroundBounds(); ............... final int scrollX = mScrollX; final int scrollY = mScrollY; if ((scrollX | scrollY) == 0) &#123; background.draw(canvas); &#125; else &#123; canvas.translate(scrollX, scrollY); background.draw(canvas); canvas.translate(-scrollX, -scrollY); &#125;&#125; 如上所示，调用了background的draw方法，也就是Drawable的draw方法。 第三步：绘制内容 通过调用onDraw方法实现1234567/** * Implement this to do your drawing. * * @param canvas the canvas on which the background will be drawn */ protected void onDraw(Canvas canvas) &#123; &#125; 我们发现onDraw是一个空的方法，需要子类去实现，一般我们在自定义View的时候都会重写onDraw方法来进行绘制。 第四步：绘制子类 通过调用dispatchDraw实现123456789/** * Called by draw to draw the child views. This may be overridden * by derived classes to gain control just before its children are drawn * (but after its own view has been drawn). * @param canvas the canvas on which to draw the view */ protected void dispatchDraw(Canvas canvas) &#123; &#125; 发现dispatchDraw为空，根据注释：如果View包含子类就需要重写这个方法，那么说明下ViewGroup应该重写了这个方法，看下ViewGroup的dispatchDraw方法，如下所示： 123456789101112131415161718192021222324@Override protected void dispatchDraw(Canvas canvas) &#123; ............. for (int i = 0; i &lt; childrenCount; i++) &#123; while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123; final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; transientIndex++; if (transientIndex &gt;= transientCount) &#123; transientIndex = -1; &#125; &#125; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; ............. &#125; 从上述方法看出主要是遍历child,然后调用child的drawChild方法，来看下drawChild方法： 123protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 可以看出，在drawChild方法当中调用了child.draw方法来实现子视图的绘制。 第六步：绘制装饰，比如前景色，滚动条等 通过onDrawForeground方法实现1234567891011121314151617/** * Draw any foreground content for this view. * * &lt;p&gt;Foreground content may consist of scroll bars, a &#123;@link #setForeground foreground&#125; * drawable or other view-specific decorations. The foreground is drawn on top of the * primary view content.&lt;/p&gt; * * @param canvas canvas to draw into */ public void onDrawForeground(Canvas canvas) &#123; onDrawScrollIndicators(canvas); onDrawScrollBars(canvas); ........ final Drawable foreground = mForegroundInfo != null ? mForegroundInfo.mDrawable : null; ........ foreground.draw(canvas); &#125; 可以看出主要是对滚动条和前景色进行绘制。 到此，View绘制的三个基本流程：measure,layout,draw就讲完了，measure过程应该是三个流程里面最为复杂的。希望通过本次对源码的剖析，能够对View的绘制流程有一个清楚的认识，在以后自定义View的时候能够少走弯路～～ View树的重绘还记得在上一篇博客中我们讲ViewGroup#addView方法会导致View树的重新绘制，代码如下所示： 1234567891011121314public void addView(View child, int index, LayoutParams params) &#123; if (DBG) &#123; System.out.println(this + \" addView\"); &#125; if (child == null) &#123; throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\"); &#125; // addViewInner() will call child.requestLayout() when setting the new LayoutParams // therefore, we call requestLayout() on ourselves before, so that the child's request // will be blocked at our level requestLayout(); invalidate(true); addViewInner(child, index, params, false);&#125; 其实归根结底是调用了requestLayout和invalidate方法的原因，导致View进行重新绘制，下面来对这两个方法进行分析： View的requestLayout方法：requestLayout是view的方法，如下所示： 12345678@CallSuper public void requestLayout() &#123; ............ if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123; mParent.requestLayout(); &#125; ......... &#125; 核心代码是mParent.requestLayout，这个方法就会一层层的往上递归，一直到ViewRootImpl的requestLayout。ViewRootImpl的requestLayout方法在上一篇博客中已经分析过，这个方法会导致整个View树的重绘。 View的invalidate方法：12345678910111213141516171819202122public void invalidate() &#123; invalidate(true);&#125;void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);&#125;void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) &#123; ........... // Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage); &#125; ...........&#125; 我们发现最终调用了当前view父视图的invalidateChid方法，于是查看ViewGroup的invalidateChid方法： 12345678910111213141516171819202122232425262728293031/** * Don't call or override this method. It is used for the implementation of * the view hierarchy. */ @Override public final void invalidateChild(View child, final Rect dirty) &#123; ViewParent parent = this; ............. do &#123; View view = null; if (parent instanceof View) &#123; view = (View) parent; &#125; .......... parent = parent.invalidateChildInParent(location, dirty); if (view != null) &#123; // Account for transform on current parent Matrix m = view.getMatrix(); if (!m.isIdentity()) &#123; RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); m.mapRect(boundingRect); dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom)); &#125; &#125; &#125; while (parent != null); &#125; &#125; 我们发现invalidateChild方法里面有一个do-while循环，在这个循环里面循环调用invalidateChildInParent方法，到这里我们自然就可以想到最终会调用ViewRootImpl的invalidateChildInParent方法，ViewRootImpl的invalidateChildInParent方法如下所示： 1234567891011121314@Override public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; checkThread(); if (DEBUG_DRAW) Log.v(mTag, \"Invalidate child: \" + dirty); if (dirty == null) &#123; invalidate(); return null; &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123; return null; &#125; ............ return null; &#125; 可以看到在这个方法里面调用了invalidate方法，如下所示： 123456void invalidate() &#123; mDirty.set(0, 0, mWidth, mHeight); if (!mWillDrawSoon) &#123; scheduleTraversals(); &#125; &#125; 看到这里是否有一种很熟悉的赶脚（如果看了上一篇博客的话），这个scheduleTraversals方法最终会调用View的三个基本绘制流程来实现整个View树的绘制。 View的postInvalidate方法：当我们想在非ui线程当中刷新View的时候一般都是调用postInvalidate方法，View的postInvalidate方法如下所示： 123456789101112public void postInvalidate() &#123; postInvalidateDelayed(0); &#125;public void postInvalidateDelayed(long delayMilliseconds) &#123; // We try only with the AttachInfo because there's no point in invalidating // if we are not attached to our window final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds); &#125; &#125; 可以看出是调用了ViewRootImpl的dispatchInvalidateDelayed方法： 1234public void dispatchInvalidateDelayed(View view, long delayMilliseconds) &#123; Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view); mHandler.sendMessageDelayed(msg, delayMilliseconds); &#125; 这个方法就是发送一个MSG_INVALIDATE消息到消息队列当中，那肯定是在Handler的handleMessage方法里面对消息进行了处理： 123456@Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_INVALIDATE: ((View) msg.obj).invalidate(); break; 在handleMessage方法里面调用了View的invalidate方法,而关于invalidate方法，在上面进行了详细的分析。 到此为止，对View绘制的三个基本流程从源码的角度进行了详细的剖析，谢谢各位的阅读，不足之处欢迎指出。","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android应用层View绘制流程之DecorView与ViewRootImpl","slug":"android/ViewInvalidteProcessOne","date":"2017-04-22T09:22:24.000Z","updated":"2017-06-01T15:57:00.000Z","comments":true,"path":"2017/04/22/android/ViewInvalidteProcessOne/","link":"","permalink":"http://easyliu.com/2017/04/22/android/ViewInvalidteProcessOne/","excerpt":"","text":"概述一直对Android中View的整个绘制流程不是很了解，View是怎么添加到Activity当中去的？当View中的内容发生改变的时候是怎样执行界面的刷新的？因此，今天准备从源码的角度来对View的整个绘制流程来进行分析，源码基于API25。由于篇幅限制，这篇文章只分析顶层视图DecorView的显示逻辑，具体的View树绘制三部曲:measure,layout,draw将在下篇博文进行深入剖析。 从Activity的setContentView方法说起我们都知道给Activity设置布局通常就是调用其setContentView方法，这个方法有几个重载的方法，如下所示： 1234567891011121314public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125; public void setContentView(View view) &#123; getWindow().setContentView(view); initWindowDecorActionBar(); &#125;public void setContentView(View view, ViewGroup.LayoutParams params) &#123; getWindow().setContentView(view, params); initWindowDecorActionBar();&#125; 从上面的三个方法可以看出其均调用了getWindow()的相对应的方法，我们来看getWindow()方法： 123public Window getWindow() &#123; return mWindow; &#125; 可以看出这个方法返回的是一个Window类型的变量mWindow，那么这个mWindow肯定是在Activity某个地方进行初始化,如下所示在attach方法里面进行了初始化： 12345678910111213141516171819final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); .......... .......... &#125; mWindow是一个PhoneWindow类型的变量，其实我们通过查看抽象类Window最开始的简介可以知道，PhoneWindow是Window的唯一子类！ 1234567891011/** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */public abstract class Window &#123; 接下来查看PhoneWindow的setContentView方法，跟Activity对应，也有三个重载的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 @Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125;@Overridepublic void setContentView(View view) &#123; setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));&#125;@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; mContentParent.addView(view, params); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 对setContentView(View view,ViewGroup.LayoutParams)方法进行分析： 首先判断mContentParent是否为null，如果为null的话就执行方法installDecor，这个mContentParent是一个ViewGroup类型，这个方法如下所示： 1234567891011121314151617 private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); ........ .......&#125; generateDecor用于产生mDecor,mDecor是DecorView类型，是整个Activity的顶层视图，DecorView是FrameLayout的子类，有兴趣的可以看看DecorView源码，这里只是给个结论。然后是generateLayout方法，这个方法很长，看关键代码： 123456 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(\"Window couldn't find content container view\"); &#125;....return contentParent; 从上述代码可以看出，上面讲到的mContentParent是顶层视图mDecor中的一个子View，这个子View的id为： 1234/** * The ID that the main layout in the XML layout file should have. */ public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; 因此，执行了installDecor方法之后就得到了mDecor和mContentParent，然后是一句很关键的代码，如下所示：1mContentParent.addView(view, params); 通过这句代码就把我们在Activity当中设置的布局视图加入了mContentParent里面。** 层次关系为：DecorView &gt; contentParent &gt; Activity中的布局。**由于mContentParent是ViewGroup类型，查看ViewGroup#addView方法，如下所示： 123456789101112131415161718192021222324252627/** * Adds a child view with the specified layout parameters. * * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; do not invoke this method from * &#123;@link #draw(android.graphics.Canvas)&#125;, &#123;@link #onDraw(android.graphics.Canvas)&#125;, * &#123;@link #dispatchDraw(android.graphics.Canvas)&#125; or any related method.&lt;/p&gt; * * @param child the child view to add * @param index the position at which to add the child or -1 to add last * @param params the layout parameters to set on the child */ public void addView(View child, int index, LayoutParams params) &#123; if (DBG) &#123; System.out.println(this + \" addView\"); &#125; if (child == null) &#123; throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\"); &#125; // addViewInner() will call child.requestLayout() when setting the new LayoutParams // therefore, we call requestLayout() on ourselves before, so that the child's request // will be blocked at our level requestLayout(); invalidate(true); addViewInner(child, index, params, false); &#125; 这个addView方法最后会调用requestLayout()和invalidate()方法，这两个方法会导致整个View树进行重新绘制，这样就把我们在Activity当中自定义的布局文件给显示出来了！ 整个过程总结如下：Activity.setContentView -&gt; PhoneWindow.setContentView -&gt;初始化PhoneWindow中的mDecor和mContentParent -&gt; 把Activity当中的布局视图加入mContentParent -&gt; 导致整个View树进行重新绘制，从而把布局文件显示出来！ DecorView是怎么显示出来的前面说了DecorView是整个Activity的顶层视图，那么这个DecorView是怎么显示出来了的呢？主要实现过程在ActivityThread的handleResumeActivity方法里面，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); if (!checkAndUpdateLifecycleSeq(seq, r, \"resumeActivity\")) &#123; return; &#125; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration r = performResumeActivity(token, clearHide, reason); if (r != null) &#123; final Activity a = r.activity; if (localLOGV) Slog.v( TAG, \"Resume \" + r + \" started activity: \" + a.mStartedActivity + \", hideForNow: \" + r.hideForNow + \", finished: \" + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; ................................ &#125;&#125; 如上述方法所示，首先从ActivityThread保存的mActivities列表里面得到一个ActivityClientRecord对象，这个对象保存了Activity的一些信息。 得到Activity之后调用View decor = r.window.getDecorView();方法得到顶层视图DecorView，这个视图前面说过是保存在PhoneWindow里面，也就是一个Activity对应一个 PhoneWindow，从而对应一个DecorView。 然后是调用ViewManager wm = a.getWindowManager();方法得到Activity当中的WindowManager对象，那为什么返回的是ViewManager对象呢？查看WindowManager接口，如下所示，发现WindowManager是继承自ViewManager接口的。 1public interface WindowManager extends ViewManager &#123; ViewManager接口如下所示，从注释可以看出这个接口主要是用来往Activity当中添加或者移除View。 12345678910111213141516171819/** Interface to let you add and remove child views to an Activity. To get an instance * of this class, call &#123;@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()&#125;. */public interface ViewManager&#123; /** * Assign the passed LayoutParams to the passed View and add the view to the window. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.BadTokenException&#125; for certain programming * errors, such as adding a second view to a window without removing the first view. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.InvalidDisplayException&#125; if the window is on a * secondary &#123;@link Display&#125; and the specified display can't be found * (see &#123;@link android.app.Presentation&#125;). * @param view The view to be added to this window. * @param params The LayoutParams to assign to view. */ public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 得到Activity当中的WindowManager之后，调用wm.addView(decor, l);方法，就把DecorView加入了WindowManager。我们知道WindowManager只是一个接口，具体的实现类是WindowManagerImpl,看下其addView方法： 12345@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; 发现这个addView方法其实是调用了成员变量mGlobal的addVeiw方法，mGlobal是WindowManagerGlobal类型，我们来看下其addView方法，如下所示： 123456789101112131415161718192021222324252627282930public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ........................ ViewRootImpl root; View panelParentView = null; ......................... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); ........................... // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125; &#125; 通过上述代码可以发现顶层视图DecorView最终被加入到了ViewRootImpl里面，且应该是在其setView方法里面执行了某些操作，导致DecorView被显示出来。这个方法比较长，大家可以自行查看，在里面有一句关键的代码： 1234// Schedule the first layout -before- adding to the window// manager, to make sure we do the relayout before receiving// any other events from the system.requestLayout(); requestLayout方法如下： 12345678@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; 在这个方法当中调用了scheduleTraversals方法，如下所示： 12345678910111213void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125; &#125; 在这个方法当中把mTraversalRunnable给post到了消息队列里面，来看看这个Runnable里面执行了什么操作： 1234567final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125; &#125; final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); 从上面可以看出在TraversalRunnable里面执行了doTraversal方法： 1234567891011121314151617void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(\"ViewAncestor\"); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125; &#125; 在这个方法当中又执行了performTraversals方法，这个方法最终负责整个View树的绘制流程，因此这个方法比较关键。这个方法比较长，其负责绘制的View树的核心语句如下，其中mView就是顶层视图DecorView。 123456789101112private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ...... mView.draw(canvas); ...... &#125; 上面对顶层视图DecorView的显示机制进行了深入剖析，通过一层层分析，最终得出ViewRootImpl负责整个View树的绘制。measure,layout,draw是View树绘制三个主要流程，只有理解了这三个基本流程的原理，在自定义View的时候才能做到游刃有余（当然还有View事件分发机制也很关键）！关于这三个流程的具体细节剖析将在下一篇博客中进行讲解。感谢大家的阅读！","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-18T06:51:26.000Z","updated":"2017-03-18T06:51:26.000Z","comments":true,"path":"2017/03/18/hello-world/","link":"","permalink":"http://easyliu.com/2017/03/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"杂项","slug":"杂项","permalink":"http://easyliu.com/categories/杂项/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://easyliu.com/tags/其他/"}]},{"title":"自定义圆形进度条的实现","slug":"android/CustomizeProgressBar","date":"2017-03-16T11:09:47.000Z","updated":"2017-06-01T15:59:36.000Z","comments":true,"path":"2017/03/16/android/CustomizeProgressBar/","link":"","permalink":"http://easyliu.com/2017/03/16/android/CustomizeProgressBar/","excerpt":"","text":"概述Android中自带有进度条，但是有的时候自带的进度条不能满足我们的需求，这时候就需要自定义进度条了，今天带来的就是一个自定义的圆形进度条首先来看效果，效果如下所示。 实现从上面的效果可以看出，主要有以下几个自定义属性： 背景颜色 进度扇形颜色 半径 起始角度 因此，在attrs.xml中定义如下属性： 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"SimpleRoundProgressBar\"&gt; &lt;attr format=\"color\" name=\"roundColor\"/&gt; &lt;attr format=\"color\" name=\"roundProgressColor\"/&gt; &lt;attr format=\"dimension\" name=\"circleRadius\"/&gt; &lt;attr format=\"integer\" name=\"startAngle\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 下面是SimpleRoundProgressBar代码，在onMeasure当中确定view的大小，在onDraw来进行绘制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.easyliu.demo.customizeview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.util.AttributeSet;import android.view.View;/*** Created by easyliu on 2017/2/24.*/public class SimpleRoundProgressBar extends View &#123; private Paint mPaint;//画笔 private RectF mRectF;//扇形绘制的矩形范围 private int mRoundColor;//圆环的颜色 private int mRoundProgressColor; //进度条的颜色 private float mRadius;//半径 private int mWidth; //宽度 private int mHeight; //高度 private int mCenterX; //中心X坐标 private int mCenterY; //中心Y坐标 private int mStartAngle; //初始角度 private int mSweepAngle; //扫过的角度 private static final int DEFAULT_INIT_ANGLE = 0;//默认的初始化角度 private static final int DEFAULT_RADIUS = 10;//默认的半径 public SimpleRoundProgressBar(Context context) &#123; this(context, null); &#125; public SimpleRoundProgressBar(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SimpleRoundProgressBar(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mPaint = new Paint(); mRectF = new RectF(); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.SimpleRoundProgressBar); mRoundColor = typedArray.getColor(R.styleable.SimpleRoundProgressBar_roundColor, Color.GRAY); mRoundProgressColor = typedArray.getColor(R.styleable.SimpleRoundProgressBar_roundProgressColor, Color.RED); mRadius = typedArray.getDimension(R.styleable.SimpleRoundProgressBar_circleRadius, DEFAULT_RADIUS); mStartAngle = typedArray.getInteger(R.styleable.SimpleRoundProgressBar_startAngle, DEFAULT_INIT_ANGLE); typedArray.recycle(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //获取测量模式 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); //获取测量大小 int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); //如果为确定值 if (heightMode == MeasureSpec.EXACTLY) &#123; mHeight = heightSize; &#125; else &#123; //如果为wrap_content，高度为半径大小乘以2，注意padding mHeight = (int) (mRadius * 2) + getPaddingTop() + getPaddingBottom(); &#125; //如果为确定值 if (widthMode == MeasureSpec.EXACTLY) &#123; mWidth = widthSize; mHeight=mWidth;//宽和高相等 &#125; else &#123; //如果为wrap_content，宽度为半径大小乘以2,注意padding mWidth = (int) (mRadius * 2) + getPaddingLeft() + getPaddingRight(); &#125; //设置视图的大小 setMeasuredDimension(mWidth, mHeight); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setColor(mRoundColor); mPaint.setAntiAlias(true); mCenterX = mWidth / 2; mCenterY = mHeight / 2; //注意处理padding mRadius = (mWidth - getPaddingLeft() - getPaddingRight()) / 2; //画圆 canvas.drawCircle(mCenterX, mCenterY, mRadius, mPaint); mPaint.setColor(mRoundProgressColor); //注意处理padding mRectF.left = getPaddingLeft(); mRectF.right = mWidth - getPaddingRight(); mRectF.top = getPaddingTop(); mRectF.bottom = mHeight - getPaddingBottom(); //画扇形 canvas.drawArc(mRectF, (float) mStartAngle, mSweepAngle, true, mPaint); &#125; public int getRoundColor() &#123; return mRoundColor; &#125; public void setRoundColor(int roundColor) &#123; this.mRoundColor = roundColor; &#125; /** * 得到初始角度 */ public synchronized int getStartAngle() &#123; return mStartAngle; &#125; /** * 设置初始角度 */ public synchronized void setStartAngle(int startAngle) &#123; if (startAngle &lt; -360) &#123; throw new IllegalArgumentException(\"the angle can not less than -360\"); &#125; if (startAngle &gt; 360) &#123; throw new IllegalArgumentException(\"the angle can not larger than 360\"); &#125; this.mStartAngle = startAngle; &#125; /** * 得到扫过的角度 */ public synchronized int getSweepAngle() &#123; return mSweepAngle; &#125; /** * 设置扫过的角度,相对于起始点 * * @param sweepAngle 0~360 */ public synchronized void setSweepAngle(int sweepAngle) &#123; if (sweepAngle &lt; 0) &#123; throw new IllegalArgumentException(\"the angle can not less than 0\"); &#125; if (sweepAngle &gt; 360) &#123; throw new IllegalArgumentException(\"the angle can not larger than 360\"); &#125; this.mSweepAngle = sweepAngle; postInvalidate(); &#125;&#125; 定义好了之后就可以使用了，首先是xml文件： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:easyliu=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.easyliu.demo.customizeview.RoundProgressBarActivity\" &gt; &lt;com.easyliu.demo.customizeview.SimpleRoundProgressBar android:id=\"@+id/progress_demo\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:padding=\"10dp\" easyliu:circleRadius=\"50dp\" easyliu:roundColor=\"#5F000000\" easyliu:roundProgressColor=\"#ff8d33\" /&gt; &lt;com.easyliu.demo.customizeview.SimpleRoundProgressBar android:id=\"@+id/progress_demo2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/progress_demo\" android:layout_centerHorizontal=\"true\" android:padding=\"10dp\" easyliu:circleRadius=\"60dp\" easyliu:roundColor=\"@color/colorPrimary\" easyliu:roundProgressColor=\"@color/colorAccent\" /&gt;&lt;/RelativeLayout&gt; 然后是Activity代码，在代码中使用定时器来定时更新进度即可。 123456789101112131415161718192021222324252627282930313233343536package com.easyliu.demo.customizeview;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import java.util.Timer;import java.util.TimerTask;public class RoundProgressBarActivity extends AppCompatActivity &#123; private int mCurrentAngle = 0; private SimpleRoundProgressBar mRoundProgressBar1; private SimpleRoundProgressBar mRoundProgressBar2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_progress_bar); initViews(); Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; mCurrentAngle++; mRoundProgressBar1.setSweepAngle(mCurrentAngle); mRoundProgressBar2.setSweepAngle(mCurrentAngle); if (mCurrentAngle &gt;= 360) &#123; mCurrentAngle = 0; &#125; &#125; &#125;, 0, 20); &#125; private void initViews()&#123; mRoundProgressBar1 = (SimpleRoundProgressBar) findViewById(R.id.progress_demo); mRoundProgressBar1.setStartAngle(-90); mRoundProgressBar2= (SimpleRoundProgressBar) findViewById(R.id.progress_demo2); mRoundProgressBar2.setStartAngle(0); &#125;&#125; 这样就完成了一个简单的圆形进度条的自定义。","categories":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://easyliu.com/categories/Android自定义控件/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Hexo搭建个人博客","slug":"first","date":"2017-03-15T15:28:55.000Z","updated":"2020-05-17T11:23:11.785Z","comments":true,"path":"2017/03/15/first/","link":"","permalink":"http://easyliu.com/2017/03/15/first/","excerpt":"","text":"您好，欢迎来到easyliu的技术博客！ 相关链接： 在 hexo 中无痛使用本地图片 程序猿修炼之道(4)-技能篇之Markdown（附：工具推荐） hexo官网 大道至简——Hexo简洁主题推荐 npm install reports error “npm ERR! Unexpected end of JSON input while parsing near hueman-theme 相关笔记： 代码块高亮的方式为三个```之后加上语言，记得之间的空格，不然无效 对于引用图片，在同一目录下面新建asset文件夹，把图片放入其中，然后引用即可 在_post下面的ios目录下面新建xcode_shortcut.md文件：hexo new –path ios/xcode_shortcut “xcode_shortcut”","categories":[{"name":"hexo","slug":"hexo","permalink":"http://easyliu.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://easyliu.com/tags/hexo/"}]},{"title":"Hexo搭建个人博客","slug":"algorithm/findFirstOneTimeChar/first","date":"2017-03-15T15:28:55.000Z","updated":"2020-06-18T11:13:38.268Z","comments":true,"path":"2017/03/15/algorithm/findFirstOneTimeChar/first/","link":"","permalink":"http://easyliu.com/2017/03/15/algorithm/findFirstOneTimeChar/first/","excerpt":"","text":"您好，欢迎来到easyliu的技术博客！ 相关链接： 在 hexo 中无痛使用本地图片 程序猿修炼之道(4)-技能篇之Markdown（附：工具推荐） hexo官网 大道至简——Hexo简洁主题推荐 npm install reports error “npm ERR! Unexpected end of JSON input while parsing near hueman-theme 关于hexo中使用连续{报错的解决方案:把括号进行隔开即可 相关笔记： 代码块高亮的方式为三个```之后加上语言，记得之间的空格，不然无效 对于引用图片，在同一目录下面新建asset文件夹，把图片放入其中，然后引用即可 在_post下面的ios目录下面新建xcode_shortcut.md文件：hexo new –path ios/xcode_shortcut “xcode_shortcut”","categories":[{"name":"hexo","slug":"hexo","permalink":"http://easyliu.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://easyliu.com/tags/hexo/"}]}]}