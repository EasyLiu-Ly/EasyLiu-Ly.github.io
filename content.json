{"meta":{"title":"EasyLiu","subtitle":"welcome to easyliu's blog","description":"欢迎来到我的博客","author":"EasyLiu","url":"http://easyliu.com"},"pages":[{"title":"关于","date":"2017-03-17T16:00:00.000Z","updated":"2020-05-17T10:42:56.681Z","comments":true,"path":"about/index.html","permalink":"http://easyliu.com/about/index.html","excerpt":"","text":"程序员一枚,专注移动端开发 Nickname: EasyLiu Email: ly_eyl@163.com Github: EasyLiu-Ly"}],"posts":[{"title":"种植小番茄","slug":"life/grow_tomato","date":"2022-06-02T08:15:07.000Z","updated":"2022-07-10T15:18:53.603Z","comments":true,"path":"2022/06/02/life/grow_tomato/","link":"","permalink":"http://easyliu.com/2022/06/02/life/grow_tomato/","excerpt":"","text":"阳台种植小番茄，记录番茄的生长过程，5.5号开始种植种子： 6.2 号第17天，幼苗已经长出来了： 6.17 号第34天，长势还不错，进行了移栽，保证每个盆只保留1到2棵： 6.25 号第42天，可以看到一周不见，这俩盆里面的小番茄已经长高一大截了 上面这一盆里面有两棵，考虑土壤可能不够，番茄根系比较发达，因此移栽到了下面的大盆里面，对这俩棵寄予了殷切的希望～～，快快长大吧 最后是整体的效果，暂时应该不会进行大幅度的移栽调整了，基本上保证了每个盆只保留一棵了，继续观察吧～～ 7.10 号第57天，可以看到下面这俩盆里面的小番茄又长高了一大截了，开始需要使用棍子进行固定才行了 这一棵也长高了，感觉拍摄角度还不错～～ 这是总体效果，除了上面提到的三棵，其他的长得就比较慢了，有几棵小的叶子都黄了然后掉了，应该还是肥料养分不足导致，再观察一周看下情况吧，如果还不行就只能舍弃了～～","categories":[{"name":"园艺","slug":"园艺","permalink":"http://easyliu.com/categories/园艺/"}],"tags":[{"name":"日常生活","slug":"日常生活","permalink":"http://easyliu.com/tags/日常生活/"}]},{"title":"种辣椒","slug":"life/grow_pepper","date":"2022-05-22T08:01:07.000Z","updated":"2022-06-19T14:08:29.336Z","comments":true,"path":"2022/05/22/life/grow_pepper/","link":"","permalink":"http://easyliu.com/2022/05/22/life/grow_pepper/","excerpt":"","text":"阳台种植辣椒，记录辣椒的生长过程 6.19 update:由于种植过程不理想，辣椒苗一直长不大，就放弃了辣椒种植，专心小番茄的种植：种植小番茄","categories":[{"name":"园艺","slug":"园艺","permalink":"http://easyliu.com/categories/园艺/"}],"tags":[{"name":"日常生活","slug":"日常生活","permalink":"http://easyliu.com/tags/日常生活/"}]},{"title":"深圳大鹏7娘山——2021.8.22","slug":"life/2021_8_22_seven_mother_moutain","date":"2021-09-07T01:49:51.000Z","updated":"2021-09-08T02:14:37.602Z","comments":true,"path":"2021/09/07/life/2021_8_22_seven_mother_moutain/","link":"","permalink":"http://easyliu.com/2021/09/07/life/2021_8_22_seven_mother_moutain/","excerpt":"","text":"风景无敌(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer1\"),\"autoplay\":true,\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"/resources/video/seven_mom_moutain_one.mp4\",\"pic\":\"/resources/image/seven_mom_moutain_poster.jpeg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()","categories":[{"name":"周末活动","slug":"周末活动","permalink":"http://easyliu.com/categories/周末活动/"}],"tags":[{"name":"日常活动","slug":"日常活动","permalink":"http://easyliu.com/tags/日常活动/"}]},{"title":"（一）通过浏览器访问摄像头","slug":"live_study/visit_camare_through_browser","date":"2021-06-08T02:22:02.000Z","updated":"2022-02-17T07:19:14.899Z","comments":true,"path":"2021/06/08/live_study/visit_camare_through_browser/","link":"","permalink":"http://easyliu.com/2021/06/08/live_study/visit_camare_through_browser/","excerpt":"","text":"index.html123456789101112131415&lt;html&gt; &lt;head&gt; &lt;title&gt;WebRTC capture video and audio&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./css/client.css\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;video autoplay playsinline id=\"player\"&gt;&lt;/video&gt; &lt;script src=\"https://webrtc.github.io/adapter/adapter-latest.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js\"&gt;&lt;/script&gt; &lt;script src=\"./js/client.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; client.js123456789101112131415161718192021222324252627282930313233343536373839404142'use strict'var videoplay = document.querySelector('video#player');const mediaStreamContrains = &#123; video: &#123; frameRate: &#123; min: 20 &#125;, width: &#123; min: 640, ideal: 1280 &#125;, height: &#123; min: 360, ideal: 720 &#125;, aspectRatio: 16 / 9, facingMode: 'user', resizeMode: true &#125;, audio: &#123; echoCancellation: true, noiseSuppression: true, autoGainControl: true &#125;&#125;;function gotMediaStream(stream) &#123; window.stream = stream; videoplay.srcObject = stream;&#125;function handleError(err) &#123; console.log('getUserMedia error:', err);&#125;function start() &#123; if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) &#123; console.log('getUserMedia is not supported!'); return; &#125; else &#123; navigator.mediaDevices.getUserMedia(mediaStreamContrains) .then(gotMediaStream) .catch(handleError); &#125;&#125;start(); 效果使用浏览器打开index.html就可以在浏览器里面看到前置摄像头影像了","categories":[{"name":"从0打造音视频直播系统","slug":"从0打造音视频直播系统","permalink":"http://easyliu.com/categories/从0打造音视频直播系统/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://easyliu.com/tags/学习笔记/"}]},{"title":"WebViewFactory.getProvider耗时问题的一种解决思路","slug":"android_performance/webViewFactory_getProvider","date":"2021-05-10T02:11:49.000Z","updated":"2022-02-17T07:17:10.746Z","comments":true,"path":"2021/05/10/android_performance/webViewFactory_getProvider/","link":"","permalink":"http://easyliu.com/2021/05/10/android_performance/webViewFactory_getProvider/","excerpt":"","text":"背景最近在做外部拉起视频底层页整个链路上的一个耗时优化，发现在这个过程中有一个地方挺耗时的，如下所示： 可以看到这个WebViewFactory.getProvider()方法耗时了240ms！ 找到WebViewFactory的源码如下所示: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354static WebViewFactoryProvider getProvider() &#123; synchronized (sProviderLock) &#123; // For now the main purpose of this function (and the factory abstraction) is to keep // us honest and minimize usage of WebView internals when binding the proxy. if (sProviderInstance != null) return sProviderInstance; final int uid = android.os.Process.myUid(); if (uid == android.os.Process.ROOT_UID || uid == android.os.Process.SYSTEM_UID || uid == android.os.Process.PHONE_UID || uid == android.os.Process.NFC_UID || uid == android.os.Process.BLUETOOTH_UID) &#123; throw new UnsupportedOperationException( \"For security reasons, WebView is not allowed in privileged processes\"); &#125; if (!isWebViewSupported()) &#123; // Device doesn't support WebView; don't try to load it, just throw. throw new UnsupportedOperationException(); &#125; if (sWebViewDisabled) &#123; throw new IllegalStateException( \"WebView.disableWebView() was called: WebView is disabled\"); &#125; Trace.traceBegin(Trace.TRACE_TAG_WEBVIEW, \"WebViewFactory.getProvider()\"); try &#123; Class&lt;WebViewFactoryProvider&gt; providerClass = getProviderClass(); Method staticFactory = null; try &#123; staticFactory = providerClass.getMethod( CHROMIUM_WEBVIEW_FACTORY_METHOD, WebViewDelegate.class); &#125; catch (Exception e) &#123; if (DEBUG) &#123; Log.w(LOGTAG, \"error instantiating provider with static factory method\", e); &#125; &#125; Trace.traceBegin(Trace.TRACE_TAG_WEBVIEW, \"WebViewFactoryProvider invocation\"); try &#123; sProviderInstance = (WebViewFactoryProvider) staticFactory.invoke(null, new WebViewDelegate()); if (DEBUG) Log.v(LOGTAG, \"Loaded provider: \" + sProviderInstance); return sProviderInstance; &#125; catch (Exception e) &#123; Log.e(LOGTAG, \"error instantiating provider\", e); throw new AndroidRuntimeException(e); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_WEBVIEW); &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_WEBVIEW); &#125; &#125; &#125; 从代码可以看到这个getProvider里面有做处理：如果已经获取到了WebViewFactoryProvider就直接返回，也就是说只有第一次才会往下走，才会耗时。并且从WebViewFactory注释来看： 1Top level factory, used creating all the main WebView implementation classes. 这个WebViewFactory应该是跟WebView相关的，WebView的相关操作最终都会走到这个WebViewFactroy里面来。如果是这样的话，那我们能不能在App启动的时候在子线程提前调用这个getProvider方法来初始化一下这个WebViewFactoryProvider，并且这个getProvider是线程安全的方法。这样UI线程真正使用WebView的时候，这个getProvider方法就能直接返回了？答案是可以的，但是这个getProvider并不是一个public方法，只能通过反射调用了，代码如下所示： 解决方案12345678910111213141516171819202122232425public class WebViewHookManager &#123; private static final String TAG = \"WebViewHookManager\"; /** * 提前在子线程里面调用WebViewFactory.getProvider方法，解决第一次调用耗时问题 * * @param isMainProcess 是否是主进程 */ public static void initWebViewGetProvider(boolean isMainProcess) &#123; if (isMainProcess) &#123; ThreadManager.getInstance().post(() -&gt; &#123; try &#123; @SuppressLint(\"PrivateApi\") Class&lt;?&gt; webViewFactoryClass = Class.forName(\"android.webkit.WebViewFactory\"); @SuppressLint(\"DiscouragedPrivateApi\") Method method = webViewFactoryClass.getDeclaredMethod(\"getProvider\"); method.setAccessible(true); method.invoke(webViewFactoryClass); &#125; catch (Exception e) &#123; QQLiveLog.e(TAG, e, \"WebViewFactory.getProvider\"); &#125; &#125;); &#125; &#125;&#125; 遇到的问题理论上我们在App启动的时候调用一下上述initWebViewGetProvider方法就可以了，但是实际上并不是如此。这个方法调用时机是有讲究的，不能放在Application.attachBaseContext方法里面调用，原因我们得从源码来查找答案。 在getProvider方法里面调用了一个方法isWebViewSupported： 123456789private static boolean isWebViewSupported() &#123; // No lock; this is a benign race as Boolean's state is final and the PackageManager call // will always return the same value. if (sWebViewSupported == null) &#123; sWebViewSupported = AppGlobals.getInitialApplication().getPackageManager() .hasSystemFeature(PackageManager.FEATURE_WEBVIEW); &#125; return sWebViewSupported;&#125; 在这个方法里面会通过AppGlobals.getInitialApplication()来获取到一个Application，全局搜索AppGlobals这个类来看下这个方法实现： 1234567/** * Return the first Application object made in the process. * NOTE: Only works on the main thread. */public static Application getInitialApplication() &#123; return ActivityThread.currentApplication();&#125; 可以看到这个方法调用了 ActivityThread.currentApplication()方法，继续来看下这个方法： 1234567Application mInitialApplication;public static Application currentApplication() &#123; ActivityThread am = currentActivityThread(); return am != null ? am.mInitialApplication : null;&#125; 可以看到这个currentApplication返回的是ActivityThread里面的成员变量mInitialApplication，继续来看下这个mInitialApplication成员变量赋值的地方，在ActivityThread的handleBindApplication方法里面有如下代码片段： 1234567891011121314151617181920212223242526272829303132333435363738394041try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. app = data.info.makeApplication(data.restrictedBackupMode, null); // Propagate autofill compat state app.setAutofillCompatibilityEnabled(data.autofillCompatibilityEnabled); mInitialApplication = app; // don't bring up providers in restricted mode; they may depend on the // app's custom Application class if (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; installContentProviders(app, data.providers); // For process that contains content providers, we want to // ensure that the JIT is enabled \"at some point\". mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000); &#125; &#125; // Do this after providers, since instrumentation tests generally start their // test thread at this point, and we don't want that racing. try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Exception thrown in onCreate() of \" + data.instrumentationName + \": \" + e.toString(), e); &#125; try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( \"Unable to create application \" + app.getClass().getName() + \": \" + e.toString(), e); &#125; &#125; &#125; 这段代码主要分为3部分：1、app = data.info.makeApplication(data.restrictedBackupMode, null)这句代码里面就会去创建一个Application，并且在里面会调用Application的attachBaseContext方法。执行完这个makeApplication方法之后，这个mInitialApplication才会进行赋值，因此不能在attachBaseContext就去调用WebViewFactory.getProvider方法，因为这个时候ActivityThread里面的mInitialApplication还没有初始化2、installContentProviders方法会挨个执行ContentProvider的onCreate方法3、最后mInstrumentation.callApplicationOnCreate(app)会执行Application的onCreate方法，因此我们可以在Application的onCreate方法里面调用WebViewFactory.getProvider方法 从上述代码可以看出这三步的一个执行顺序如下：Application.attachBaseContext -&gt; ContentProvider.onCreate -&gt; Application.onCreate 效果通过日志观察WebViewFactory的日志打印，可以看到代码已经执行成功了： 但是目前这个getProvider接口已经被列入了greylist里面了，在后续的版本不敢保证还能继续生效，这里只是提供一种解决问题的思路 优化之后的效果如下所示，可以看到UI线程WebViewFactory.getProvider()方法耗时已经没有了：","categories":[{"name":"Android性能优化","slug":"Android性能优化","permalink":"http://easyliu.com/categories/Android性能优化/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android SystemTrace实战","slug":"android_performance/system_trace_use","date":"2021-04-27T01:44:05.000Z","updated":"2022-02-17T07:17:03.154Z","comments":true,"path":"2021/04/27/android_performance/system_trace_use/","link":"","permalink":"http://easyliu.com/2021/04/27/android_performance/system_trace_use/","excerpt":"","text":"SystemTrace使用在命令行输入如下命令： python /Users/easyliu/Library/Android/sdk/platform-tools/systrace/systrace.py –time=10 -o mynewtrace.html 然后启动App，10s之后会在当前目录下面生成一个文件mynewtrace.html文件，这个文件只有使用chrome浏览器才能打开，如果使用chrome浏览器打不开，可以在chrome浏览器里面输入网址：https://ui.perfetto.dev/#!/viewer，在这个界面里面也可以打开这个trace文件 关于systrace更复杂的命令使用方式，参考：https://developer.android.com/topic/performance/tracing/custom-events?hl=zh-cn 在很多情况下，我们需要加入一些自己的event，比如我们想统计自定义Activity的onCreate方法的耗时，可以使用如下方式添加自定义的event： 123Trace.beginSection(\"SplashVideoDetailActivity#onCreate\");super.onCreate(savedInstanceState);Trace.endSection(); 要想自定义的event能够在trace文件里面展示出来，还需要在运行systrace命令的时候通过-a指定包名： 1python systrace.py -a com.example.myapp --time=10 -o mynewtrace.html 还有一点，默认情况下，只有debug才支持自定义的event，原因是在ActivityThread的handleBindApplication方法里面有如下代码： 12boolean isAppDebuggable = (data.appInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0;Trace.setAppTracingAllowed(isAppDebuggable); 为了让release包也支持自定义的event，可以使用反射的方式修改： 12ReflectUtil.invokeMethod(Trace.class, \"setAppTracingAllowed\", null, new Class[]&#123;boolean.class&#125;, new Object[]&#123;true&#125;); SystemTrace锁耗时分析抓取到trace之后，一般情况下我们都是直接分析UI线程的执行情况,如下所示：通过这个图可以很清晰的看到整个app启动过程的一个耗时情况，包括各个阶段的具体耗时情况，比如从上面的图我们发现在SplashVideoDetailActivity#onCreate方法里面两段很耗时的操作，我看来看一下第一段的耗时情况：选中这个区域，底部会展示出这段时间主线程耗时的具体的信息： Name monitor contention with owner init-thread (32284) waiters=2 blocking from void java.lang.Runtime.load0(java.lang.Class, java.lang.String)(Runtime.java:-1) 从这个信息可以很明确，这里UI卡住是因为调用了java.lang.Runtime.load0方法，这个方法在等待线程init-thread (32284)释放锁，那说明这个方法有锁？我们来看下源码： 12345678910111213synchronized void load0(Class&lt;?&gt; fromClass, String filename) &#123; if (!(new File(filename).isAbsolute())) &#123; throw new UnsatisfiedLinkError( \"Expecting an absolute path of the library: \" + filename); &#125; if (filename == null) &#123; throw new NullPointerException(\"filename == null\"); &#125; String error = nativeLoad(filename, fromClass.getClassLoader()); if (error != null) &#123; throw new UnsatisfiedLinkError(error); &#125;&#125; 可以看到这个方法确实是有加锁的。既然是这样的话，我们应该可以在工程代码里面找到这个名字叫做init-thread的线程。通过全局查找，找到了这个线程就是启动Task线程池里面的，说明启动task里面有一个子线程的task有loadLibrary的动作，导致主线程去loadLibrary的时候就卡住了。然后再根据UI线程卡住的时间点，就可以缩小范围，最终就能找到loadLibrary的是哪个task，然后就可以再进一步分析了","categories":[{"name":"Android性能优化","slug":"Android性能优化","permalink":"http://easyliu.com/categories/Android性能优化/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"ActivityManagerService.reportSizeConfigurations异常问题规避方案","slug":"android_source_analysis/reportSizeConfigurations_exception","date":"2021-04-27T01:34:59.000Z","updated":"2022-02-17T07:18:01.933Z","comments":true,"path":"2021/04/27/android_source_analysis/reportSizeConfigurations_exception/","link":"","permalink":"http://easyliu.com/2021/04/27/android_source_analysis/reportSizeConfigurations_exception/","excerpt":"","text":"背景在crash平台上上报了以下crash，量还不少： 12345678910111213141516android.os.RemoteException: Remote stack trace:com.android.server.am.ActivityManagerService.reportSizeConfigurations(ActivityManagerService.java:9443)android.app.IActivityManager$Stub.onTransact(IActivityManager.java:2837)com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:3654)com.android.server.am.HwActivityManagerService.onTransact(HwActivityManagerService.java:609)android.os.Binder.execTransact(Binder.java:739)java.lang.IllegalArgumentException:reportSizeConfigurations: ActivityRecord not found for: Token&#123;f7b56df ActivityRecord&#123;a06a17e u0 com.tencent.qqlive/.ona.activity.SplashVideoDetailActivity t-1 f&#125;&#125;android.os.Parcel.createException(Parcel.java:1957)......android.os.RemoteException:Remote stack trace:com.android.server.am.ActivityManagerService.reportSizeConfigurations(ActivityManagerService.java:9443)android.app.IActivityManager$Stub.onTransact(IActivityManager.java:2837)com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:3654)com.android.server.am.HwActivityManagerService.onTransact(HwActivityManagerService.java:609)android.os.Binder.execTransact(Binder.java:739) 并且看crash机型都是出现了Android 9.0手机上。因此，我们就从Android 9.0源码下手开始分析： 分析过程找到ActivityManagerService.reportSizeConfigurations方法源码： 123456789101112131415@Overridepublic void reportSizeConfigurations(IBinder token, int[] horizontalSizeConfiguration, int[] verticalSizeConfigurations, int[] smallestSizeConfigurations) &#123; if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Report configuration: \" + token + \" \" + horizontalSizeConfiguration + \" \" + verticalSizeConfigurations); synchronized (this) &#123; ActivityRecord record = ActivityRecord.isInStackLocked(token); if (record == null) &#123; throw new IllegalArgumentException(\"reportSizeConfigurations: ActivityRecord not \" + \"found for: \" + token); &#125; record.setSizeConfigurations(horizontalSizeConfiguration, verticalSizeConfigurations, smallestSizeConfigurations); &#125;&#125; 结合crash堆栈： 1java.lang.IllegalArgumentException:reportSizeConfigurations: ActivityRecord not found for: Token&#123;f7b56df ActivityRecord&#123;a06a17e u0 com.tencent.qqlive/.ona.activity.SplashVideoDetailActivity t-1 f&#125;&#125; 可以看出应该是从通过token从Activity堆栈里面找不到了ActivityRecord，导致抛出了crash，并且看了下只有9.0源码里面有这一段代码，其他版本没有这个代码。 既然是从堆栈里面找不到ActivityRecord，那说明Activity被finish掉了，导致从栈里面移除掉了？ 由于Activity相关操作都是跨进程的，ActivityManagerService对应的Client为ActivityManager,找到Client端调用reportSizeConfigurations方法的地方，在ActivityThread的reportSizeConfigurations方法里面： 12345678910111213141516171819202122232425262728private void reportSizeConfigurations(ActivityClientRecord r) &#123; Configuration[] configurations = r.activity.getResources().getSizeConfigurations(); if (configurations == null) &#123; return; &#125; SparseIntArray horizontal = new SparseIntArray(); SparseIntArray vertical = new SparseIntArray(); SparseIntArray smallest = new SparseIntArray(); for (int i = configurations.length - 1; i &gt;= 0; i--) &#123; Configuration config = configurations[i]; if (config.screenHeightDp != Configuration.SCREEN_HEIGHT_DP_UNDEFINED) &#123; vertical.put(config.screenHeightDp, 0); &#125; if (config.screenWidthDp != Configuration.SCREEN_WIDTH_DP_UNDEFINED) &#123; horizontal.put(config.screenWidthDp, 0); &#125; if (config.smallestScreenWidthDp != Configuration.SMALLEST_SCREEN_WIDTH_DP_UNDEFINED) &#123; smallest.put(config.smallestScreenWidthDp, 0); &#125; &#125; try &#123; ActivityManager.getService().reportSizeConfigurations(r.token, horizontal.copyKeys(), vertical.copyKeys(), smallest.copyKeys()); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125;&#125; 然后来看下这个reportSizeConfigurations方法调用的地方: 12345678public Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; //........... final Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); 可以发现，在ActivityThread的handleLaunchActivity方法里面会先调用performLaunchActivity方法来启动一个Activity，这里面也是涉及到跨进程操作的。如果performLaunchActivity里面跨进程操作执行比较慢，在这个过程中杀死App，然后结合前面的分析，应该就能复现这个crash？ 为了验证这个猜想，执行复现路径：找到crash列表中的某一个机型，启动App的时候，马上切后台杀死App。果然就复现了这个crash，crash现象是：杀死app之后过一会app又回自动起来白屏，然后就crash了，看堆栈也可以完全对应上! 那既然是异常case，那怎么规避这个crash问题呢？ 规避方案使用Hook方案，针对9.0的机型进行特殊处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class HookActivityManager &#123; private static final String TAG = \"HookActivityManager\"; public static void hook() &#123; if (Build.VERSION.SDK_INT != Build.VERSION_CODES.P) &#123; Log.i(TAG, \"hook return, not match version\"); return; &#125; try &#123; Field am = ActivityManager.class.getDeclaredField(\"IActivityManagerSingleton\"); am.setAccessible(true); Object iActivityManagerSingleton = am.get(null); if (iActivityManagerSingleton == null) &#123; return; &#125; Class&lt;?&gt; singletonCls = iActivityManagerSingleton.getClass().getSuperclass(); if (singletonCls == null) &#123; return; &#125; Field instance = singletonCls.getDeclaredField(\"mInstance\"); instance.setAccessible(true); Object iActivityManager = instance.get(iActivityManagerSingleton); Class&lt;?&gt; iActivityManagerCls = Class.forName(\"android.app.IActivityManager\"); Class&lt;?&gt;[] classes = &#123;iActivityManagerCls&#125;; Object iActivityManageProxy = Proxy.newProxyInstance( iActivityManagerCls.getClassLoader(), classes, new IActivityManagerProxy(iActivityManager)); instance.set(iActivityManagerSingleton, iActivityManageProxy); Log.i(TAG, \"hook success!\"); &#125; catch (Exception e) &#123; Log.w(TAG, \"\" + e); &#125; &#125; private static class IActivityManagerProxy implements InvocationHandler &#123; private final Object mActivityManager; public IActivityManagerProxy(Object iActivityManager) &#123; mActivityManager = iActivityManager; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (\"reportSizeConfigurations\".equals(method.getName())) &#123; try &#123; Log.w(TAG, \"reportSizeConfigurations invoke execute \"); return method.invoke(mActivityManager, args); &#125; catch (Exception e) &#123; Log.w(TAG, \"reportSizeConfigurations exception: \" + e.getMessage()); return null; &#125; &#125; return method.invoke(mActivityManager, args); &#125; &#125;&#125; 通过动态代理的方式对这个ActivityManagerService.reportSizeConfigurations方法加上try_catch处理，然后在Application的attachBaseContext方法里面执行hook： 12345 public void attachBaseContext(Context base) &#123; if (ApplicationProcessUtils.getInstance().isMainProcess()) &#123; HookActivityManager.hook(); &#125;&#125; 问题得以解决！","categories":[{"name":"Android疑难杂症","slug":"Android疑难杂症","permalink":"http://easyliu.com/categories/Android疑难杂症/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"ValueAnimator属性动画深入解析","slug":"android_source_analysis/ValueAnimator","date":"2021-03-16T01:30:31.000Z","updated":"2022-02-17T07:18:07.957Z","comments":true,"path":"2021/03/16/android_source_analysis/ValueAnimator/","link":"","permalink":"http://easyliu.com/2021/03/16/android_source_analysis/ValueAnimator/","excerpt":"","text":"前言在上一篇博文Handler消息机制深入解析当中，在最后面说到： ViewAnimation底层也是通过调用invalidate来实现的，无限循环动画就会导致无限调用invalidate，就会导致idle得不到执行。属性动画的实现原理不同于View动画。View动画的每一帧都是通过invalidate方法来触发重绘，而属性动画每一帧的绘制都是通过Choreographer的回调实现。因此，本质上来说，属性动画少了一个很重要的步骤，就是post一个同步屏障。在属性动画中，没有同步屏障，那么后续的任务能够继续执行，当队列中没有任务时，自然就会回调IdleHandler了。 那么事实真的如此的么？今天我们就从源码的角度来对属性动画进行一个深入解析，源码基于API30 实践使用过属性动画的同学应该都清楚，一般情况下我们会和两个类打交道：ValueAnimator以及ObjectAnimator 123ValueAnimator extends Animator implements AnimationHandler.AnimationFrameCallbackObjectAnimator extends ValueAnimator 可以看出ObjectAnimator是继承自ValueAnimator的，对应的常见使用方式如下所示： 1234567891011121314151617//ValueAnimator使用方式ValueAnimator valueAnimator = ValueAnimator.ofFloat(0.0f, (float) (view.getHeight() * 3));valueAnimator.setDuration(500);valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; float animatedValue = (float) valueAnimator.getAnimatedValue(); view.setTranslationY(animatedValue); view.setTranslationX(animatedValue); &#125;&#125;);valueAnimator.start();//ObjectAnimator使用方式ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(view, \"alpha\", 0.0f, 1f);objectAnimator.setDuration(500);objectAnimator.start(); 可以看出对于ValueAnimator来说，是通过监听onAnimationUpdate回调，在回调里面根据当前的animatedValue来动态改变View的属性来实现动画效果；对于ObjectAnimator来说，通过一系列静态方法比如ofFloat来创建ObjectAnimator的时候，就会传入View对象以及传入一个View的属性，然后调用start方法，属性动画就会通过动画自动改变传入View的属性值。 这里有一个需要注意的点，传入的这个View属性必须要有set方法，比如针对”alpha”属性，就必须要有setAlpha方法，为啥必须要有set方法？稍后会进行讲解 从上面的使用可以看出，要想使用属性动画来实现改变View属性的功能，那么属性动画框架就需要解决2个问题： 1、属性动画每一帧绘制onAnimationUpdate回调实现2、对于ObjectAnimator来说，怎么做到根据传入的View属性来自动改变其对应的值 基于以上问题，我们先从ValueAnimator的start方法做为切入点开始分析 ValueAnimator#start首先来看下start方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void start() &#123; start(false);&#125;private void start(boolean playBackwards) &#123; if (Looper.myLooper() == null) &#123; throw new AndroidRuntimeException(\"Animators may only be run on Looper threads\"); &#125; mReversing = playBackwards; mSelfPulse = !mSuppressSelfPulseRequested; // Special case: reversing from seek-to-0 should act as if not seeked at all. if (playBackwards &amp;&amp; mSeekFraction != -1 &amp;&amp; mSeekFraction != 0) &#123; if (mRepeatCount == INFINITE) &#123; // Calculate the fraction of the current iteration. float fraction = (float) (mSeekFraction - Math.floor(mSeekFraction)); mSeekFraction = 1 - fraction; &#125; else &#123; mSeekFraction = 1 + mRepeatCount - mSeekFraction; &#125; &#125; mStarted = true; mPaused = false; mRunning = false; mAnimationEndRequested = false; // Resets mLastFrameTime when start() is called, so that if the animation was running, // calling start() would put the animation in the // started-but-not-yet-reached-the-first-frame phase. mLastFrameTime = -1; mFirstFrameTime = -1; mStartTime = -1; addAnimationCallback(0); if (mStartDelay == 0 || mSeekFraction &gt;= 0 || mReversing) &#123; // If there's no start delay, init the animation and notify start listeners right away // to be consistent with the previous behavior. Otherwise, postpone this until the first // frame after the start delay. startAnimation(); if (mSeekFraction == -1) &#123; // No seek, start at play time 0. Note that the reason we are not using fraction 0 // is because for animations with 0 duration, we want to be consistent with pre-N // behavior: skip to the final value immediately. setCurrentPlayTime(0); &#125; else &#123; setCurrentFraction(mSeekFraction); &#125; &#125;&#125; 可以看到，start方法里面主要做了以下事情： 1、设置一些标记位，比如mStarted、mPaused、mRunning等2、调用addAnimationCallback方法，看这个名字像是添加动画回调，还记得最开始说属性动画每一帧的绘制都是通过Choreographer的回调实现，难道就是这里面的逻辑？3、满足一定条件之后，开始startAnimation启动动画 我们接下来看下addAnimationCallback方法： ValueAnimator#addAnimationCallback12345678910private void addAnimationCallback(long delay) &#123; if (!mSelfPulse) &#123; return; &#125; getAnimationHandler().addAnimationFrameCallback(this, delay);&#125;public AnimationHandler getAnimationHandler() &#123; return mAnimationHandler != null ? mAnimationHandler : AnimationHandler.getInstance();&#125; 可以看出addAnimationCallback方法里面调用了AnimationHandler的addAnimationFrameCallback方法，这个AnimationHandler是一个单例，调用addAnimationFrameCallback的时候传入了this，从VauleAnimator的实现来看，是一个AnimationHandler.AnimationFrameCallback接口。 接下来进一步看下AnimationHandler.addAnimationFrameCallback方法： 1234567891011121314151617181920212223242526272829303132private final Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() &#123; @Override public void doFrame(long frameTimeNanos) &#123; doAnimationFrame(getProvider().getFrameTime()); if (mAnimationCallbacks.size() &gt; 0) &#123; getProvider().postFrameCallback(this); &#125; &#125;&#125;;/** * Register to get a callback on the next frame after the delay. */public void addAnimationFrameCallback(final AnimationFrameCallback callback, long delay) &#123; if (mAnimationCallbacks.size() == 0) &#123; getProvider().postFrameCallback(mFrameCallback); &#125; if (!mAnimationCallbacks.contains(callback)) &#123; mAnimationCallbacks.add(callback); &#125; if (delay &gt; 0) &#123; mDelayedCallbackStartTime.put(callback, (SystemClock.uptimeMillis() + delay)); &#125;&#125;private AnimationFrameCallbackProvider getProvider() &#123; if (mProvider == null) &#123; mProvider = new MyFrameCallbackProvider(); &#125; return mProvider;&#125; 从这个方法的注释可以看出，就是注册一个下一帧的回调，在这个方法里面，调用了getProvider().postFrameCallback方法，传入了一个Choreographer.FrameCallback回调，getProvider返回的是一个MyFrameCallbackProvider对象，然后会把传入的AnimationFrameCallback保存在一个mAnimationCallbacks列表里面 来看下MyFrameCallbackProvider.postFrameCallback方法： 1234567891011121314151617181920212223242526272829303132/** * Default provider of timing pulse that uses Choreographer for frame callbacks. */private class MyFrameCallbackProvider implements AnimationFrameCallbackProvider &#123; final Choreographer mChoreographer = Choreographer.getInstance(); @Override public void postFrameCallback(Choreographer.FrameCallback callback) &#123; mChoreographer.postFrameCallback(callback); &#125; @Override public void postCommitCallback(Runnable runnable) &#123; mChoreographer.postCallback(Choreographer.CALLBACK_COMMIT, runnable, null); &#125; @Override public long getFrameTime() &#123; return mChoreographer.getFrameTime(); &#125; @Override public long getFrameDelay() &#123; return Choreographer.getFrameDelay(); &#125; @Override public void setFrameDelay(long delay) &#123; Choreographer.setFrameDelay(delay); &#125;&#125; 可以看出，postFrameCallback方法里面调用了Choreographer的postFrameCallback方法，如果看过我上一篇博文：Handler消息机制深入解析同学看到这里应该就明白了，这个postFrameCallback里面就会去向底层注册一个Vsync信号，在收到Vsync信号之后就会执行传入的Choreographer.FrameCallback回调，感兴趣的同学可以继续深入看下，这里就不展开讲了。 当收到收到Choreographer.FrameCallback回调之后，回到AnimationHandler里面的mFrameCallback： 123456789private final Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() &#123; @Override public void doFrame(long frameTimeNanos) &#123; doAnimationFrame(getProvider().getFrameTime()); if (mAnimationCallbacks.size() &gt; 0) &#123; getProvider().postFrameCallback(this); &#125; &#125;&#125;; 可以看到，收到Choreographer.FrameCallback回调之后，会先调用doAnimationFrame方法，然后接着又会调用getProvider().postFrameCallback(this)方法开启新一轮的注册Vsync信号流程，这样就形成了一个循环，除非mAnimationCallbacks为空。当动画结束的时候就会移除mAnimationCallbacks里面对应的callback，这样就不再继续监听Choreographer的FrameCallback回调了 其实到这里我们就可以回答最开始提出的问题了：属性动画是通过监听Choreographer.FrameCallback来实现的，与View动画原理是不一样的 收到Choreographer.FrameCallback回调之后，我们进一步来看下是怎么作用到ValueAnimator上面去的，来看下doAnimationFrame方法： 123456789101112131415private void doAnimationFrame(long frameTime) &#123; long currentTime = SystemClock.uptimeMillis(); final int size = mAnimationCallbacks.size(); for (int i = 0; i &lt; size; i++) &#123; final AnimationFrameCallback callback = mAnimationCallbacks.get(i); if (callback == null) &#123; continue; &#125; if (isCallbackDue(callback, currentTime)) &#123; callback.doAnimationFrame(frameTime); //........ &#125; &#125; cleanUpList();&#125; 在doAnimationFrame方法里面会遍历之前保存的AnimationFrameCallback列表，调用其doAnimationFrame方法，前面我们说了ValueAnimator实现了AnimationFrameCallback接口，那么来看下ValueAnimator里面的doAnimationFrame方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public final boolean doAnimationFrame(long frameTime) &#123; if (mStartTime &lt; 0) &#123; // First frame. If there is start delay, start delay count down will happen *after* this // frame. mStartTime = mReversing ? frameTime : frameTime + (long) (mStartDelay * resolveDurationScale()); &#125; // Handle pause/resume if (mPaused) &#123; mPauseTime = frameTime; removeAnimationCallback(); return false; &#125; else if (mResumed) &#123; mResumed = false; if (mPauseTime &gt; 0) &#123; // Offset by the duration that the animation was paused mStartTime += (frameTime - mPauseTime); &#125; &#125; if (!mRunning) &#123; // If not running, that means the animation is in the start delay phase of a forward // running animation. In the case of reversing, we want to run start delay in the end. if (mStartTime &gt; frameTime &amp;&amp; mSeekFraction == -1) &#123; // This is when no seek fraction is set during start delay. If developers change the // seek fraction during the delay, animation will start from the seeked position // right away. return false; &#125; else &#123; // If mRunning is not set by now, that means non-zero start delay, // no seeking, not reversing. At this point, start delay has passed. mRunning = true; startAnimation(); &#125; &#125; if (mLastFrameTime &lt; 0) &#123; if (mSeekFraction &gt;= 0) &#123; long seekTime = (long) (getScaledDuration() * mSeekFraction); mStartTime = frameTime - seekTime; mSeekFraction = -1; &#125; mStartTimeCommitted = false; // allow start time to be compensated for jank &#125; mLastFrameTime = frameTime; // The frame time might be before the start time during the first frame of // an animation. The \"current time\" must always be on or after the start // time to avoid animating frames at negative time intervals. In practice, this // is very rare and only happens when seeking backwards. final long currentTime = Math.max(frameTime, mStartTime); boolean finished = animateBasedOnTime(currentTime); if (finished) &#123; endAnimation(); &#125; return finished; &#125; 在这个方法里面最后会调用animateBasedOnTime方法： 12345678910111213141516171819202122232425262728293031boolean animateBasedOnTime(long currentTime) &#123; boolean done = false; if (mRunning) &#123; final long scaledDuration = getScaledDuration(); final float fraction = scaledDuration &gt; 0 ? (float)(currentTime - mStartTime) / scaledDuration : 1f; final float lastFraction = mOverallFraction; final boolean newIteration = (int) fraction &gt; (int) lastFraction; final boolean lastIterationFinished = (fraction &gt;= mRepeatCount + 1) &amp;&amp; (mRepeatCount != INFINITE); if (scaledDuration == 0) &#123; // 0 duration animator, ignore the repeat count and skip to the end done = true; &#125; else if (newIteration &amp;&amp; !lastIterationFinished) &#123; // Time to repeat if (mListeners != null) &#123; int numListeners = mListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; mListeners.get(i).onAnimationRepeat(this); &#125; &#125; &#125; else if (lastIterationFinished) &#123; done = true; &#125; mOverallFraction = clampFraction(fraction); float currentIterationFraction = getCurrentIterationFraction( mOverallFraction, mReversing); animateValue(currentIterationFraction); &#125; return done;&#125; 可以看出这个方法最后会调用animateValue方法： 12345678910111213141516@CallSuper@UnsupportedAppUsagevoid animateValue(float fraction) &#123; fraction = mInterpolator.getInterpolation(fraction); mCurrentFraction = fraction; int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].calculateValue(fraction); &#125; if (mUpdateListeners != null) &#123; int numListeners = mUpdateListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; mUpdateListeners.get(i).onAnimationUpdate(this); &#125; &#125;&#125; 在这个方法里面会做两件事情： 1、mValues数组是一个PropertyValuesHolder[]，代表属性数组，调用PropertyValuesHolder的calculateValue方法之后，里面会更新PropertyValuesHolder里面属性对应的mAnimatedValue。那这个PropertyValuesHolder数组是什么时候生成的呢？来看ValueAnimator里面相应的代码: 12345678910111213141516171819202122232425262728293031public static ValueAnimator ofInt(int... values) &#123; ValueAnimator anim = new ValueAnimator(); anim.setIntValues(values); return anim;&#125;public void setIntValues(int... values) &#123; if (values == null || values.length == 0) &#123; return; &#125; if (mValues == null || mValues.length == 0) &#123; setValues(PropertyValuesHolder.ofInt(\"\", values)); &#125; else &#123; PropertyValuesHolder valuesHolder = mValues[0]; valuesHolder.setIntValues(values); &#125; // New property/values/target should cause re-initialization prior to starting mInitialized = false;&#125;public void setValues(PropertyValuesHolder... values) &#123; int numValues = values.length; mValues = values; mValuesMap = new HashMap&lt;String, PropertyValuesHolder&gt;(numValues); for (int i = 0; i &lt; numValues; ++i) &#123; PropertyValuesHolder valuesHolder = values[i]; mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder); &#125; // New property/values/target should cause re-initialization prior to starting mInitialized = false;&#125; 可以看出在ValueAnimator的一系列of方法里面，就会去初始化这个PropertyValuesHolder数组 2、通过AnimatorUpdateListener通知给外部调用方 至此，我们已经分析出了属性动画每一帧绘制onAnimationUpdate回调实现方案：通过在start方法里面监听Choreographer的frameCallback来实现的 接下来看下第2个问题： 对于ObjectAnimator来说，怎么做到根据传入的View属性来自动改变其对应的值 对于这个问题，我们从ObjectAnimator.ofFloat做为切入点来分析： ObjectAnimator#ofFloat12345678910111213141516171819202122232425262728293031323334353637public static ObjectAnimator ofFloat(Object target, String propertyName, float... values) &#123; ObjectAnimator anim = new ObjectAnimator(target, propertyName); anim.setFloatValues(values); return anim;&#125;private ObjectAnimator(Object target, String propertyName) &#123; setTarget(target); setPropertyName(propertyName);&#125;public void setTarget(@Nullable Object target) &#123; final Object oldTarget = getTarget(); if (oldTarget != target) &#123; if (isStarted()) &#123; cancel(); &#125; mTarget = target == null ? null : new WeakReference&lt;Object&gt;(target); // New target should cause re-initialization prior to starting mInitialized = false; &#125;&#125; public void setPropertyName(@NonNull String propertyName) &#123; // mValues could be null if this is being constructed piecemeal. Just record the // propertyName to be used later when setValues() is called if so. if (mValues != null) &#123; PropertyValuesHolder valuesHolder = mValues[0]; String oldName = valuesHolder.getPropertyName(); valuesHolder.setPropertyName(propertyName); mValuesMap.remove(oldName); mValuesMap.put(propertyName, valuesHolder); &#125; mPropertyName = propertyName; // New property/values/target should cause re-initialization prior to starting mInitialized = false;&#125; 从以上代码可以看出，ofFloat方法里面首先会根据传入的target以及propertyName构造一个ObjectAnimator对象，在构造方法里面会调用setTarget保存传入的View对象，调用setPropertyName方法会把propertyName保存起来，然后调用ObjectAnimator的setFloatValues方法： 1234567891011121314@Overridepublic void setFloatValues(float... values) &#123; if (mValues == null || mValues.length == 0) &#123; // No values yet - this animator is being constructed piecemeal. Init the values with // whatever the current propertyName is if (mProperty != null) &#123; setValues(PropertyValuesHolder.ofFloat(mProperty, values)); &#125; else &#123; setValues(PropertyValuesHolder.ofFloat(mPropertyName, values)); &#125; &#125; else &#123; super.setFloatValues(values); &#125;&#125; 因为这个时候mValues还没有赋值，并且也没有对mProperty字段进行赋值，那么就走到了setValues(PropertyValuesHolder.ofFloat(mPropertyName, values))这一行，这里通过调用PropertyValuesHolder.ofFloat(mPropertyName, values)生成一个PropertyValuesHolder对象，然后调用setValues方法给前面提到的ValueAnimator里面的mValues属性数组进行赋值。 前面说到了ValueAnimator最终会调用到animateValue方法，在这个方法里面会先计算当前的属性值，然后通过AnimatorUpdateListener接口通知给外部： 12345678910111213141516@CallSuper@UnsupportedAppUsagevoid animateValue(float fraction) &#123; fraction = mInterpolator.getInterpolation(fraction); mCurrentFraction = fraction; int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].calculateValue(fraction); &#125; if (mUpdateListeners != null) &#123; int numListeners = mUpdateListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; mUpdateListeners.get(i).onAnimationUpdate(this); &#125; &#125;&#125; ObjectAnimator覆写了这个方法： 123456789101112131415 void animateValue(float fraction) &#123; final Object target = getTarget(); if (mTarget != null &amp;&amp; target == null) &#123; // We lost the target reference, cancel and clean up. Note: we allow null target if the /// target has never been set. cancel(); return; &#125; super.animateValue(fraction); int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].setAnimatedValue(target); &#125;&#125; 在ObjectAnimator的animateValue方法里面会先调用ValueAnimator的animateValue方法计算好当前的属性值，然后会调用mValues数组里面每个PropertyValuesHolder的setAnimatedValue方法，传入target。到这里大家应该大概就可以猜到这个PropertyValuesHolder的setAnimatedValue方法里面肯定就是修改属性的地方了： 123456789101112131415161718192021222324 Method mSetter = null; /** * Internal function to set the value on the target object, using the setter set up * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator * to handle turning the value calculated by ValueAnimator into a value set on the object * according to the name of the property. * @param target The target object on which the value is set */void setAnimatedValue(Object target) &#123; if (mProperty != null) &#123; mProperty.set(target, getAnimatedValue()); &#125; if (mSetter != null) &#123; try &#123; mTmpValueArray[0] = getAnimatedValue(); mSetter.invoke(target, mTmpValueArray); &#125; catch (InvocationTargetException e) &#123; Log.e(\"PropertyValuesHolder\", e.toString()); &#125; catch (IllegalAccessException e) &#123; Log.e(\"PropertyValuesHolder\", e.toString()); &#125; &#125;&#125; 从这个方法可以看出，mSetter是一个Method对象，然后会通过invoke反射调用这个方法来修改属性的值。到这里，大家应该就比较明白了，ObjectAnimator里面最终是通过反射调用的方式来修改对应属性的值的。还记着在最开始说了传入的属性必须要有set方法么？说明属性只有具有set方法才能生成这个Method对象，那么这个Method是啥时候生成的呢？ ObjectAnimator#Method通过追踪代码，最终发现在ObjectAnimation的initAnimation里面有如下代码： 12345678910111213141516@CallSuper@Overridevoid initAnimation() &#123; if (!mInitialized) &#123; // mValueType may change due to setter/getter setup; do this before calling super.init(), // which uses mValueType to set up the default type evaluator. final Object target = getTarget(); if (target != null) &#123; final int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].setupSetterAndGetter(target); &#125; &#125; super.initAnimation(); &#125;&#125; 这个initAnimation是在ValueAnimator的startAnimation方法里面调用的，在这个initAnimation方法里面会调用PropertyValuesHolder的setupSetterAndGetter方法： 123456789101112131415161718192021222324252627282930313233void setupSetterAndGetter(Object target) &#123; //............... // We can't just say 'else' here because the catch statement sets mProperty to null. if (mProperty == null) &#123; Class targetClass = target.getClass(); if (mSetter == null) &#123; setupSetter(targetClass); &#125; List&lt;Keyframe&gt; keyframes = mKeyframes.getKeyframes(); int keyframeCount = keyframes == null ? 0 : keyframes.size(); for (int i = 0; i &lt; keyframeCount; i++) &#123; Keyframe kf = keyframes.get(i); if (!kf.hasValue() || kf.valueWasSetOnStart()) &#123; if (mGetter == null) &#123; setupGetter(targetClass); if (mGetter == null) &#123; // Already logged the error - just return to avoid NPE return; &#125; &#125; try &#123; Object value = convertBack(mGetter.invoke(target)); kf.setValue(value); kf.setValueWasSetOnStart(true); &#125; catch (InvocationTargetException e) &#123; Log.e(\"PropertyValuesHolder\", e.toString()); &#125; catch (IllegalAccessException e) &#123; Log.e(\"PropertyValuesHolder\", e.toString()); &#125; &#125; &#125; &#125; &#125; 在上面代码当中会调用一个setupSetter方法，传入target的Class类型： 1234567891011121314151617181920212223242526272829303132void setupSetter(Class targetClass) &#123; Class&lt;?&gt; propertyType = mConverter == null ? mValueType : mConverter.getTargetType(); mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, \"set\", propertyType);&#125;private Method setupSetterOrGetter(Class targetClass, HashMap&lt;Class, HashMap&lt;String, Method&gt;&gt; propertyMapMap, String prefix, Class valueType) &#123; Method setterOrGetter = null; synchronized(propertyMapMap) &#123; // Have to lock property map prior to reading it, to guard against // another thread putting something in there after we've checked it // but before we've added an entry to it HashMap&lt;String, Method&gt; propertyMap = propertyMapMap.get(targetClass); boolean wasInMap = false; if (propertyMap != null) &#123; wasInMap = propertyMap.containsKey(mPropertyName); if (wasInMap) &#123; setterOrGetter = propertyMap.get(mPropertyName); &#125; &#125; if (!wasInMap) &#123; setterOrGetter = getPropertyFunction(targetClass, prefix, valueType); if (propertyMap == null) &#123; propertyMap = new HashMap&lt;String, Method&gt;(); propertyMapMap.put(targetClass, propertyMap); &#125; propertyMap.put(mPropertyName, setterOrGetter); &#125; &#125; return setterOrGetter;&#125; 可以看出在setupSetter方法当中会调用setupSetterOrGetter方法，并且会传入一个前缀：”set”。在这个setupSetterOrGetter其实就是把：target、propertyName以及setterMethod三者映射起来，其中setterMethod是通过getPropertyFunction方法生成的： 12345678910111213141516171819202122232425private Method getPropertyFunction(Class targetClass, String prefix, Class valueType) &#123; // TODO: faster implementation... Method returnVal = null; String methodName = getMethodName(prefix, mPropertyName); Class args[] = null; if (valueType == null) &#123; try &#123; returnVal = targetClass.getMethod(methodName, args); &#125; catch (NoSuchMethodException e) &#123; // Swallow the error, log it later &#125; &#125; //................. return returnVal; &#125;static String getMethodName(String prefix, String propertyName) &#123; if (propertyName == null || propertyName.length() == 0) &#123; // shouldn't get here return prefix; &#125; char firstLetter = Character.toUpperCase(propertyName.charAt(0)); String theRest = propertyName.substring(1); return prefix + firstLetter + theRest; &#125; 可以看出这个getMethodName的作用就是通过前缀和属性名字生成对应的方法。举个例子： 比如传入getMethodName(“set”,”alpha”)，那么就会返回字符串:”setAlpha”，然后再通过targetClass.getMethod(methodName, args)就可以得到具体的Method对象了，这个Method对象就会作用于前面说的PropertyValuesHolder的setAnimatedValue方法，用于改变target对应的属性值！ 因此，这里就解释了为什么传给ObjectAnimator的属性一定要有对应的set方法了。 那么问题来了，如果传入的target的属性没有set方法，能不能使用属性动画呢？比如我们想通过动画来修改一个View宽度，那根据属性动画的原理的话，View就必须得有一个”setWidth”方法，但是实际上View并没有这个”setWidth”方法，那么还有没有其他办法呢？ 答案是肯定的，因为这个set方法对应Method是通过反射自动生成的，因此，我们可以通过写一个Wrapper类，在这个Wrapper类里面定义一些set和get方法，然后这些set和get方法里面会去修改真正target的一些属性，然后做属性动画的时候传入这个Wrapper类即可，如下所示： 12345678910111213141516171819202122232425262728293031323334public class ViewWrapper &#123; private View mTarget; public ViewWrapper(View target) &#123; mTarget = target; &#125; public int getWidth() &#123; return mTarget.getLayoutParams().width; &#125; public void setWidth(int width) &#123; android.view.ViewGroup.LayoutParams layoutParams = mTarget.getLayoutParams(); if (layoutParams != null) &#123; layoutParams.width = width; mTarget.requestLayout(); &#125; &#125; public int getHeight() &#123; return mTarget.getLayoutParams().height; &#125; public void setHeight(int height) &#123; android.view.ViewGroup.LayoutParams layoutParams = mTarget.getLayoutParams(); if (layoutParams != null &amp;&amp; layoutParams.height != height) &#123; layoutParams.height = height; mTarget.requestLayout(); &#125; &#125;&#125;zoomInAnimator = ObjectAnimatorUtils.ofInt(viewWrapper, \"height\", originalHeight, TITLE_BAR_HEIGHT); 通过这种方式，我们就可以通过动画来修改View的宽度和高度了，这样子是不是对属性动画的理解又深入了一层～～ 总结至此，属性动画源码分析就结束了，希望通过这篇文章能够让读者对属性动画能有一个更加深刻的认识～～","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Handler消息机制深入解析","slug":"android_source_analysis/handler","date":"2021-03-06T15:32:32.000Z","updated":"2022-02-17T07:17:42.486Z","comments":true,"path":"2021/03/06/android_source_analysis/handler/","link":"","permalink":"http://easyliu.com/2021/03/06/android_source_analysis/handler/","excerpt":"","text":"前言大家在日常开发中肯定用过Handler，常用的API主要有: 1234post(@NonNull Runnable r) postDelayed(@NonNull Runnable r, long delayMillis)postAtFrontOfQueue(@NonNull Runnable r) .......... 在主线程中可以通过这些API可以进行延时操作，在子线程中可以通过这些API可以进行线程切换，把消息发送到Handler对应的线程当中去执行 关于Handler底层实现原理的话，可能大家都能脱口而出，说出以下内容： 1、每个Handler里面关联一个Looper,每个Looper里面又关联一个MessageQueue2、当调用Handler的一些API比如post，就会往Looper.MessageQueue里面放入一个Message3、Looper.loop()是一个死循环，循环的从MessageQueue里面取出Message执行4、Looper里面通过ThreadLocal来保证每个Thread里面都有一个Looper副本5、当MessageQueue空闲的时候，就会执行IdleHandler 当你回答出以上问题的时候，可能面试官并不满足此，其接着会问如下问题： 1、主线程的Looper.loop()方法是啥时候执行的？2、Looper、MessageQueue以及Message三者交互的底层实现原理3、Looper死循环为什么不会导致应用卡死？4、ANR产生的原因5、同步屏障SyncBarrier6、onDraw里面调用invalidate为啥会导致IdleHandler得不到执行？7、ViewAnimation循环执行为啥会导致IdleHandler得不到执行,而使用属性动画就没有这个问题？ 针对以上问题，我们通过源码的方式来一一进行解答，源码基于API30版本 主线程的Looper.loop()方法是啥时候执行的？我们都知道，每一个应用都存在于自己的虚拟机中，那么每一个应用都有自己的一个main函数，这个main函数就是ActivityThread.java的main()函数： 123456789101112131415161718192021222324public static void main(String[] args) &#123; ........... Looper.prepareMainLooper(); ........... ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 可以看出在main函数里面会通过Looper.prepareMainLooper()创建主线程的Looper，然后开始通过Looper.loop方法开启主线程的Looper循环。开启循环之后，主线程所有的代码都是运行在这个Looper里面的。 接下来进一步剖析整个\bHandler消息机制底层具体的一个执行过程 Looper、MessageQueue以及Message三者交互的底层实现原理我们以Handler.post方法为入口进行讲解： 1234567891011121314151617181920212223242526272829303132public final boolean post(@NonNull Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 可以看出post方法最终会走到MessageQueue.enqueueMessage(msg, uptimeMillis)方法，深入看一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; synchronized (this) &#123; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 在分析这段代码之前，需要明确几个点： 1、Message结构体是一个链表结构，里面会有一个next指针指向下一个Message节点，每个Message在链表中的先后顺序是根据Message.when来决定的，每次来一个Message的时候会根据其when把Message插入到链表中合适的位置2、MessageQueue里面有一个字段mBlocked,代表当前队列是否处于阻塞状态 从上面的代码可以看出，enqueueMessage方法主要分为这几步： 1、MessageQueue里面有一个mMessages变量，代表是链表的head2、这个needWake代表是否需要进行唤醒，关于这个字段的含义，待会会结合Looper.loop方法一起讲解3、如果现在链表是空的，或者传入的Message需要插入到队首（根据when来进行判断），那么就把链表的head设置为传入的Message，同时如果现在MessageQueue是阻塞状态，那么就需要立即唤醒4、当不满足第3步的条件，就会把Message插入到链表合适的位置。如果现在是阻塞的情况下，队首Msg是一个同步屏障（通过p.target == null判断出是一个同步屏障）并且Msg是一个异步消息，才需要立即唤醒，相当于如果有同步屏障，那么其后续的消息都没法执行，只允许异步消息执行。关于同步屏障以及异步消息的使用场景，稍后会专门讲解，现在只需要知道有这个概念就行 把Message放入队列里面之后，那肯定是有一个地方会把Message从队列里面取出来执行，类似于生产者消费者模式，这个取消息的逻辑就是Looper.loop()，这个方法里面会循环从队列里面取出Message来执行： 1234567891011121314151617181920212223/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); .................. me.mInLoop = true; final MessageQueue queue = me.mQueue; .................. for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; .............. msg.recycleUnchecked(); &#125;&#125; 可以看出，这个loop方法里面有一个for循环，里面会调用MessageQueue的next方法，这个方法是有可能阻塞的,来看下这个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; //只有最开始设置为-1 int pendingIdleHandlerCount = -1; // -1 only during first iteration //下一次poll超时时间 int nextPollTimeoutMillis = 0; //这里也是一个for循环 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //会阻塞调用native层的nativePollOnce方法来获取消息队列中的消息 //这个nextPollTimeoutMillis有以下3种取值： //0，立即返回，没有阻塞 //负数，一直阻塞，直到事件发生 //正数，表示最多等待多久时间 //因此next方法最开始nextPollTimeoutMillis设置为0，马上返回，没有阻塞 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; //这个msg.target==null代表是一个同步屏障，找到下一个可异步消息 if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. //下一个消息的时间还没到，那么就计算出一个新的nextPollTimeoutMillis nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. //获得一个msg，把这个msg从队列里面移除掉，同时返回msg，打破这个for循环 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. //没有找到消息，设置为-1,下次轮询就一直阻塞 nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. //由于这个pendingIdleHandlerCount只有最开始设置为-1，代表在当前for循环里面idleHandler只会执行一次 //如果队列里面没有消息或者消息还没有到执行的时间，那么就考虑idleHandler if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; //如果没有idleHandler可执行，就阻塞，开始执行下一个轮询 if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; //最多执行4个idleHandler if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; //这个返回值代表是否需要一直保存这个idleHandler，如果不需要保存就从列表里面移除掉 if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. //设置0，下一个循环就不会再次执行了，只执行一次 pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. //当执行完idleHandler之后，队列里面可能已经有新消息了，那么就设置nextPollTimeoutMillis为0代表立即 //获取消息，无需等待 nextPollTimeoutMillis = 0; &#125; &#125; 上面的注释比较详细，我们大体来看一下：next方法里面也是一个for循环，在这个循环的开头会调用一个native方法nativePollOnce，这个方法可能会阻塞，根据传入的nextPollTimeoutMillis值，有3种执行情况：1、如果传入0，那么就立即返回没有阻塞2、如果传入负数，一直阻塞，直到有事件发生，这个有事件发生其实就我们前面在enqueue方法里面看到的nativeWake方法，当调用这个nativeWake方法的话，这个nativePollOnce就会返回继续往下面执行3、如果传入正数，表示最多等待多久时间，如果超过这个时间，这个nativePollOnce就会返回继续往下面执行 由于next方法刚开始传入的nextPollTimeoutMillis为0，因此第一次循环nativePollOnce方法就会马上返回，接着往下面走，如果获取到了msg就会返回（如果遇到了同步屏障，依然只能返回异步msg），打破这个for循环，回到looper的循环里面去。如果没有获取到msg,就会重新计算这个nextPollTimeoutMillis。然后接着往下走的话，就是执行IdleHandler的相关逻辑了，如果队列里面没有消息或者消息还没有到执行的时间，那么就考虑idleHandler，idleHandler执行完成之后继续从头开始下一轮循环 以上就是Handler消息机制的底层实现原理，涉及到Looper、MessageQueue以及Message三者之间的一个交互关系 Looper死循环为什么不会导致应用卡死？上面说了，消息能够源源不断的执行，靠的时候Looper.loop()以及MessageQueue.next()方法里面的for循环来保证的，之所以使用循环是为了保证当前线程一直存活不退出，这个其实可以理解，毕竟主线程肯定不能说运行一段时间就自动退出的，那么主线程的死循环一直运行会不会特别消耗CPU资源导致应用卡死呢？ 注意到，通过前面的分析，我们发现这里涉及到两个native方法： 12private native void nativePollOnce(long ptr, int timeoutMillis); /*non-static for callbacks*/private native static void nativeWake(long ptr); 这两个方法其实涉及到Linux pipe/epoll机制，在主线程的MessageQueue没有消息时，便阻塞在nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，然后通过调用nativeWake()方法，通过往pipe管道写端写入数据来唤醒主线程工作。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。 ANR产生的原因因此，真正卡死主线程操作的是在回调方法onCreate或者TouchEvent处理等操作时间过长，5s超时导致ANR，Looper.loop()本身不会导致应用卡死 同步屏障SyncBarrier在前面讲解MessageQueue.next()方法的时候我们说过如果队首的Message是一个同步屏障，那么后续的消息都得不到执行，那么这个同步屏障是用来干嘛的呢？这个同步屏障涉及到MessageQueue的以下方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@UnsupportedAppUsage@TestApipublic int postSyncBarrier() &#123; return postSyncBarrier(SystemClock.uptimeMillis());&#125;private int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don't need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125;/** * Removes a synchronization barrier. * * @param token The synchronization barrier token that was returned by * &#123;@link #postSyncBarrier&#125;. * * @throws IllegalStateException if the barrier was not found. * * @hide */@UnsupportedAppUsage@TestApipublic void removeSyncBarrier(int token) &#123; // Remove a sync barrier token from the queue. // If the queue is no longer stalled by a barrier then wake it. synchronized (this) &#123; Message prev = null; Message p = mMessages; while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123; prev = p; p = p.next; &#125; if (p == null) &#123; throw new IllegalStateException(\"The specified message queue synchronization \" + \" barrier token has not been posted or has already been removed.\"); &#125; final boolean needWake; if (prev != null) &#123; prev.next = p.next; needWake = false; &#125; else &#123; mMessages = p.next; needWake = mMessages == null || mMessages.target != null; &#125; p.recycleUnchecked(); // If the loop is quitting then it is already awake. // We can assume mPtr != 0 when mQuitting is false. if (needWake &amp;&amp; !mQuitting) &#123; nativeWake(mPtr); &#125; &#125;&#125; 通过postSyncBarrier方法来建立一个同步屏障，插入到Message链表合适的位置，然后通过removeSyncBarrier来移除一个同步屏障，那么这两个方法啥时候会调用呢？通过全局搜索系统源码，发现ViewRootImpl里面有如下代码： 123456789101112131415161718192021222324252627282930313233343536@UnsupportedAppUsagevoid scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125;void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(\"ViewAncestor\"); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125;final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125; 可以看出，在调用scheduleTraversals的时候，会post一个SyncBarrier建立屏障，然后调用mChoreographer.postCallback方法post一个runnable，在这个runnable里面会执行doTraversal方法，然后在这个doTraversal方法里面会removeSyncBarrier移除屏障。看到这个performTraversals大家应该比较熟悉了，这里面就就会递归进行整个界面View树的绘制 那么问题来了，这里为啥要使用同步屏障呢？post到Choreographer的runnable啥时候执行呢？为了一探究竟，我们继续深入看下： 12345678910111213141516171819202122232425262728293031323334353637383940414243@UnsupportedAppUsage@TestApipublic void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125;@UnsupportedAppUsage@TestApipublic void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; if (action == null) &#123; throw new IllegalArgumentException(\"action must not be null\"); &#125; if (callbackType &lt; 0 || callbackType &gt; CALLBACK_LAST) &#123; throw new IllegalArgumentException(\"callbackType is invalid\"); &#125; postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125;private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, \"PostCallback: type=\" + callbackType + \", action=\" + action + \", token=\" + token + \", delayMillis=\" + delayMillis); &#125; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; 可以发现传入的action会先放入到mCallbackQueues保存起来，然后进入到了scheduleFrameLocked方法： 123456789101112131415161718192021222324252627282930private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123; if (DEBUG_FRAMES) &#123; Log.d(TAG, \"Scheduling next frame on vsync.\"); &#125; // If running on the Looper thread, then schedule the vsync immediately, // otherwise post a message to schedule the vsync from the UI thread // as soon as possible. if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); if (DEBUG_FRAMES) &#123; Log.d(TAG, \"Scheduling next frame in \" + (nextFrameTime - now) + \" ms.\"); &#125; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; 这个USE_VSYNC指的是垂直同步，关于什么是垂直同步，这里不做深入讲解，只需要知道是一种屏幕刷新机制就行。如果使用垂直同步的话，就可以发现进入到了scheduleVsyncLocked方法： 1234567/** * Schedules a single vertical sync pulse to be delivered when the next * display frame begins. */private void scheduleVsyncLocked() &#123; mDisplayEventReceiver.scheduleVsync();&#125; 根据注释，这个方法其实就是在下一帧开始的时候安排一个垂直同步脉冲，然后会在FrameDisplayEventReceiver.onVsync收到回调： 12345678910111213141516171819202122232425262728293031323334353637/** * Called when a vertical sync pulse is received. * The recipient should render a frame and then call &#123;@link #scheduleVsync&#125; * to schedule the next vertical sync pulse. * * @param timestampNanos The timestamp of the pulse, in the &#123;@link System#nanoTime()&#125; * timebase. * @param physicalDisplayId Stable display ID that uniquely describes a (display, port) pair. * @param frame The frame number. Increases by one for each vertical sync interval. */ public void onVsync(long timestampNanos, long physicalDisplayId, int frame) &#123; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, \"Frame time is \" + ((timestampNanos - now) * 0.000001f) + \" ms in the future! Check that graphics HAL is generating vsync \" + \"timestamps using the correct timebase.\"); timestampNanos = now; &#125; if (mHavePendingVsync) &#123; Log.w(TAG, \"Already have a pending vsync event. There should only be \" + \"one at a time.\"); &#125; else &#123; mHavePendingVsync = true; &#125; mTimestampNanos = timestampNanos; mFrame = frame; Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); &#125; 从方法的注释可以看出，当一个垂直同步脉冲达到的时候就会回调这个方法，在这个方法里面会render frame，然后调用scheduleVsync开始安排下一个垂直同步脉冲。 从上面代码可以看出，在onVsync这个方法里面， 会发送一个异步的Message，前面我们说过，设置了同步屏障之后，只允许异步的Message得到执行，我们来看下这个Message的callBack执行代码： 12345@Overridepublic void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame);&#125; 在这里会执行doFrame方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void doFrame(long frameTimeNanos, int frame) &#123; final long startNanos; synchronized (mLock) &#123; if (!mFrameScheduled) &#123; return; // no work to do &#125; ............ long intendedFrameTimeNanos = frameTimeNanos; startNanos = System.nanoTime(); final long jitterNanos = startNanos - frameTimeNanos; if (jitterNanos &gt;= mFrameIntervalNanos) &#123; final long skippedFrames = jitterNanos / mFrameIntervalNanos; if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123; Log.i(TAG, \"Skipped \" + skippedFrames + \" frames! \" + \"The application may be doing too much work on its main thread.\"); &#125; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos; if (DEBUG_JANK) &#123; Log.d(TAG, \"Missed vsync by \" + (jitterNanos * 0.000001f) + \" ms \" + \"which is more than the frame interval of \" + (mFrameIntervalNanos * 0.000001f) + \" ms! \" + \"Skipping \" + skippedFrames + \" frames and setting frame \" + \"time to \" + (lastFrameOffset * 0.000001f) + \" ms in the past.\"); &#125; frameTimeNanos = startNanos - lastFrameOffset; &#125; if (frameTimeNanos &lt; mLastFrameTimeNanos) &#123; if (DEBUG_JANK) &#123; Log.d(TAG, \"Frame time appears to be going backwards. May be due to a \" + \"previously skipped frame. Waiting for next vsync.\"); &#125; scheduleVsyncLocked(); return; &#125; if (mFPSDivisor &gt; 1) &#123; long timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos; if (timeSinceVsync &lt; (mFrameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; 0) &#123; scheduleVsyncLocked(); return; &#125; &#125; mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos); mFrameScheduled = false; mLastFrameTimeNanos = frameTimeNanos; &#125; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"Choreographer#doFrame\"); AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); mFrameInfo.markInputHandlingStart(); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); mFrameInfo.markAnimationsStart(); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_INSETS_ANIMATION, frameTimeNanos); mFrameInfo.markPerformTraversalsStart(); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125; finally &#123; AnimationUtils.unlockAnimationClock(); Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; 可以看出，在这个doFrame方法里面，会先判断如果出现了丢帧现象就会调用scheduleVsyncLocked方法开始安排下一个垂直同步脉冲，否则就会把mFrameScheduled设置为false，停止监听这个Vsync信号。虽然系统会每隔16.6ms执行一次屏幕刷新，但是app上层不一定会监听这个Vsync事件，只有是调用了scheduleFrameLocked方法才会开始监听这个Vsync信号，app上层才会收到回调。比如界面需要进行刷新了，才会调用scheduleFrameLocked方法来监听屏幕刷新信号，遍历绘制View树来重新计算屏幕数据。如果界面一直不需要进行刷新，那么app上层就不会去接收每隔16.6ms回调的屏幕刷新信号了。 然后继续往下走的话会执行doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos)代码，这个代码里面最终会执行最开始说的TraversalRunnable来进行UI刷新，然后会调用removeSyncBarrier解除屏障。 同时，我们再来回顾一下前面分析的MessageQueue.next方法里面的一段代码： 123456789101112// If first time idle, then get the number of idlers to run.// Idle handles only run if the queue is empty or if the first message// in the queue (possibly a barrier) is due to be handled in the future.if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size();&#125;if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue;&#125; 有同步屏障的情况下，这个mMessage就是这个同步屏障Message ,这个now肯定是要大于mMessages.when的，因为同步屏障是在scheduleTraversals方法里面就加入了，因此如果屏障不解除，那么idle就永远得不到执行！ 总结一下： 1、从以上的分析过程来看，使用同步屏障主要是与Vsync配合使用来做屏幕刷新的，开始安排一个Vsync的时候设置一个同步屏障，只有当收到Vsync回调的时候才会解除屏障。2、这里使用同步屏障的目的主要是为了保证收到Vsync信号的时候能够第一时间响应遍历绘制View树的工作，不然就会造成丢帧现象3、从以上分析可以进一步看出：当我们调用invalidate等刷新界面的时候，并不是马上就会执行UI刷新操作的，而是先通过ViewRootImpl的scheduleTraversals方法向底层注册监听下一个垂直同步信号，等这个垂直同步信号来了之后，才会通过performTraversals方法来刷新界面4、其实以上分析就是Android的屏幕刷新机制 onDraw里面调用invalidate为啥会导致IdleHandler得不到执行？当我们在onDraw方法里面调用invalidate方法的时候，会调用到ViewRootImpl的scheduleTraversals方法，里面会发送一个同步屏障，然后收到onVsync回调最终执行到TraversalRunnable的时候会解除屏障，同时调用performTraversals方法，这个方法里面又会调用onDraw方法，从而形成死循环，导致屏障刚被解除马上又发送了一个新的屏障，这样idle一直得不到执行。 因此为了避免这种case，尽量不要在onDraw方法里面调用invalidate方法！ ViewAnimation循环执行为啥会导致IdleHandler得不到执行,而使用属性动画就没有这个问题？ViewAnimation底层也是通过调用invalidate来实现的，无限循环动画就会导致无限调用invalidate，就会导致idle得不到执行。 属性动画的实现原理不同于View动画。View动画的每一帧都是通过invalidate方法来触发重绘，而属性动画每一帧的绘制都是通过Choreographer的回调实现。因此，本质上来说，属性动画少了一个很重要的步骤，就是post一个同步屏障。在属性动画中，没有同步屏障，那么后续的任务能够继续执行，当队列中没有任务时，自然就会回调IdleHandler了。 关于属性动画的底层实现原理，后续有机会会进行分析 总结本篇文章主要是从源码的角度分析了Handler消息机制的底层实现原理，包括阻塞与同步、同步屏障、android屏幕刷新机制、idleHandler得不到执行的问题等，希望通过阅读本篇文章，能够对Handler消息机制有一个全新的认识，能够达到知其然且知其所以然","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"hexo博客添加评论、字数、阅读时间以及访问量","slug":"hexo/hexo_comment","date":"2021-02-18T11:24:38.000Z","updated":"2022-02-17T07:18:27.839Z","comments":true,"path":"2021/02/18/hexo/hexo_comment/","link":"","permalink":"http://easyliu.com/2021/02/18/hexo/hexo_comment/","excerpt":"","text":"hexo添加评论及访问量这里我们使用valine评论系统，大部分的hexo主题已经集成了valine评论系统了，关于valine的更多细节，参考：https://valine.js.org/quickstart.html 1、首先去https://www.leancloud.cn注册一个账户，注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key ,获取你的 appid 和 appkey 2、 打开主题配置文件 搜索valine，填入appid 和 appkey，这里我使用的是hueman主题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Commentcomment: //对于hueman主题来说，特别注意这里需要去掉disqus后面的字符串，不然会默认使用disqus评论系统的 disqus: # enter disqus shortname here duoshuo: # enter duoshuo shortname here youyan: # enter youyan uid here facebook: # enter true to enable isso: # options for isso. All fields below are OPTIONAL (except for site). See https://posativ.org/isso/docs/configuration/client/ for more information. on: # enter true to enable isso site: # enter the domain name of your own comment isso server, eg. comments.example.com lang: # two letter language code, eg. en reply-to-self: # true when your server spam guard has this value set require-author: # true when your server spam guard has this value set require-email: # true when your server spam guard has this value set max-comments-top: # number of top level comments to show, specify \"inf\" for all max-comments-nested: # number of nested comments to show. reveal-on-click: # number of comments to reveal when clicking \"hidden\" link avatar: # true|false, setting to enable avatar generation avatar-bg: # background color of avatar, i.e. \"#f0f0f0\" avatar-fg: # set pallet of foreground colors (up to 8) i.e. \"#9abf88 #5698c4 #e279a3 #9163b6\" vote: # true|false, setting to enable voting feature on client side. vote-levels: # levels to customize appearance of comments, eg. \"[-5, 5, 15]\" or \"0,5,10\" changyan: appId: # enter the changyan appId here appKey: # enter the changyan appKey here on: # enter true to enable //valine配置开始 valine: # Valine Comment System https://github.com/xCss/Valine on: true # true设置为开启valine评论系统 appId: HTT9HtdG3ACsrMQEd8X7aSD5-gzGzoHsz appKey: gEf913xnOAwiO8lVEWztLOQC notify: false # enter true to enable &lt;Mail notifier&gt;, default: false; https://github.com/xCss/Valine/wiki/Valine-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%E8%AE%BE%E7%BD%AE verify: false # enter true to enable &lt;Validation code&gt;, default: false placeholder: Just Do It # enter the comment box placeholder avatar: mm # (''/mm/identicon/monsterid/wavatar/retro/hide), more to see https://valine.js.org/avatar.html avatar_cdn: https://gravatar.loli.net/avatar/ # avatar CDN address, default gravatar.cat.net pageSize: 10 # comments of one page // 开启文章访问量 visitor: true # count reading numbers; If true, the numbers will also show below the title of every post recordip: true #false # If true, record commenter's ip, which is shown in LeanCloud pannel //valine配置结束 gitalk: on: # enter true to enable gitalk owner: # GitHub user name repo: # GitHub repository name client_id: # OAuth application client id client_secret: # OAuth application client secret admin: # GitHub repo owner and collaborators who can initialize github issues # Can either be a string or an array. 这样评论系统以及访问量就弄好了。 自定义表情包valine还支持自定义头像https://valine.js.org/avatar.html以及自定义表情包https://valine.js.org/emoji.html等高级功能。 这里我们以hueman主题为例来实践一下自定义表情包功能。 首先找到hueman主题下的valine.ejs，路径如下所示：/Users/easyliu/Documents/hexoBlog/themes/hueman/layout/comment/valine.ejs 打开之后如下所示： 12345678910111213141516171819202122232425&lt;% if (typeof(script) !== 'undefined' &amp;&amp; script) &#123; %&gt; &lt;script src=\"//unpkg.com/valine/dist/Valine.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var GUEST = ['nick','mail','link']; var meta = '&lt;%= theme.comment.valine.meta %&gt;'; meta = meta.split(',').filter(function (item) &#123; return GUEST.indexOf(item)&gt;-1; &#125;); var avatarcdn = '&lt;%= theme.comment.valine.avatar_cdn %&gt;' == true; new Valine(&#123; el: '.vcomments', notify: \"&lt;%= theme.comment.valine.notify %&gt;\", verify: \"&lt;%= theme.comment.valine.verify %&gt;\", appId: \"&lt;%= theme.comment.valine.appId %&gt;\", appKey: \"&lt;%= theme.comment.valine.appKey %&gt;\", placeholder: \"&lt;%= theme.comment.valine.placeholder %&gt;\", avatar:\"&lt;%= theme.comment.valine.avatar %&gt;\", recordIP:\"&lt;%= theme.comment.valine.recordip %&gt;\", visitor: \"&lt;%= theme.comment.valine.visitor %&gt;\" &#125;); &lt;/script&gt;&lt;% &#125; else &#123; %&gt; &lt;!-- Valine --&gt; &lt;div class=\"vcomments\"&gt;&lt;/div&gt;&lt;% &#125; %&gt; 我们可以编辑这个valine.ejs，添加表情包： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;% if (typeof(script) !== 'undefined' &amp;&amp; script) &#123; %&gt; &lt;script src=\"//unpkg.com/valine/dist/Valine.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var GUEST = ['nick','mail','link']; var meta = '&lt;%= theme.comment.valine.meta %&gt;'; meta = meta.split(',').filter(function (item) &#123; return GUEST.indexOf(item)&gt;-1; &#125;); var avatarcdn = '&lt;%= theme.comment.valine.avatar_cdn %&gt;' == true; new Valine(&#123; el: '.vcomments', notify: \"&lt;%= theme.comment.valine.notify %&gt;\", verify: \"&lt;%= theme.comment.valine.verify %&gt;\", appId: \"&lt;%= theme.comment.valine.appId %&gt;\", appKey: \"&lt;%= theme.comment.valine.appKey %&gt;\", placeholder: \"&lt;%= theme.comment.valine.placeholder %&gt;\", avatar:\"&lt;%= theme.comment.valine.avatar %&gt;\", recordIP:\"&lt;%= theme.comment.valine.recordip %&gt;\", visitor: \"&lt;%= theme.comment.valine.visitor %&gt;\", // 设置Bilibili表情包地址 emojiCDN: '//i0.hdslb.com/bfs/emote/', // 表情title和图片映射 emojiMaps: &#123; \"doge\": \"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png\", \"亲亲\": \"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png\", \"偷笑\": \"bb690d4107620f1c15cff29509db529a73aee261.png\", \"再见\": \"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png\", \"冷漠\": \"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png\", \"发怒\": \"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png\", \"发财\": \"34db290afd2963723c6eb3c4560667db7253a21a.png\", \"可爱\": \"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png\", \"吐血\": \"09dd16a7aa59b77baa1155d47484409624470c77.png\", \"呆\": \"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png\", \"呕吐\": \"9f996894a39e282ccf5e66856af49483f81870f3.png\", \"困\": \"241ee304e44c0af029adceb294399391e4737ef2.png\", \"坏笑\": \"1f0b87f731a671079842116e0991c91c2c88645a.png\", \"大佬\": \"093c1e2c490161aca397afc45573c877cdead616.png\", \"大哭\": \"23269aeb35f99daee28dda129676f6e9ea87934f.png\", \"委屈\": \"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png\", \"害羞\": \"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png\", \"尴尬\": \"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png\", \"微笑\": \"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png\", \"思考\": \"90cf159733e558137ed20aa04d09964436f618a1.png\", \"惊吓\": \"0d15c7e2ee58e935adc6a7193ee042388adc22af.png\", // ... 更多表情 &#125; &#125;); &lt;/script&gt;&lt;% &#125; else &#123; %&gt; &lt;!-- Valine --&gt; &lt;div class=\"vcomments\"&gt;&lt;/div&gt;&lt;% &#125; %&gt; 表情包效果可以在评论区查看 字数及阅读时间展示安装如下插件即可： npm install –save hexo-wordcount","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://easyliu.com/categories/开发工具/"}],"tags":[{"name":"hexo进阶","slug":"hexo进阶","permalink":"http://easyliu.com/tags/hexo进阶/"}]},{"title":"Glide系列之——Glide对象创建及功能扩展","slug":"android_source_analysis/glide_new","date":"2021-02-07T01:51:51.000Z","updated":"2022-02-17T07:17:28.173Z","comments":true,"path":"2021/02/07/android_source_analysis/glide_new/","link":"","permalink":"http://easyliu.com/2021/02/07/android_source_analysis/glide_new/","excerpt":"","text":"前言Glide是一个优秀的开源图片加载组件，广泛应用在各大App当中，并且也是Google官方强力推荐的一个图片加载库，根据官方文档介绍： Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。 可以看出，Glide功能是非常强大的。这么优秀的开源组件，肯定是非常值得学习的。 本系列主要是分为以下几个部分： 1、Glide系列之——初识Glide 2、Glide系列之——Glide对象创建及功能扩展 3、Glide系列之——Glide的Request执行流程及回调 4、Glide系列之——Glide缓存机制 5、Glide系列之——图片变换功能Transformation 这篇文章为第二篇：Glide系列之——Glide对象创建及功能扩展 Glide功能扩展首先来看下Glide的功能扩展 @GlideModule通过Glide的使用方式就可以发现Glide是一个全局的对象，在上一篇文章当中，讲到了RequestManagerRetriever对象的获取方式： 1234567891011@NonNullprivate static RequestManagerRetriever getRetriever(@Nullable Context context) &#123; // Context could be null for other reasons (ie the user passes in null), but in practice it will // only occur due to errors with the Fragment lifecycle. Preconditions.checkNotNull( context, \"You cannot start a load on a not yet attached View or a Fragment where getActivity() \" + \"returns null (which usually occurs when getActivity() is called before the Fragment \" + \"is attached or after the Fragment is destroyed).\"); return Glide.get(context).getRequestManagerRetriever();&#125; 可以看出Glide对象的获取方式是通过Glide.get(context)方法来获取的，来看下这个get方法： 123456789101112131415161718192021private static volatile Glide glide; /** * Get the singleton. * * @return the singleton */ @NonNull public static Glide get(@NonNull Context context) &#123; if (glide == null) &#123; GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules(context.getApplicationContext()); synchronized (Glide.class) &#123; if (glide == null) &#123; checkAndInitializeGlide(context, annotationGeneratedModule); &#125; &#125; &#125; return glide; &#125; 可以看出是使用double-check的单例方式来获取Glide对象的。在对象创建的时候，首先会通过getAnnotationGeneratedGlideModules方法获取到一个GeneratedAppGlideModule对象，我们先来看下这个getAnnotationGeneratedGlideModules方法： 1234567891011121314151617181920212223242526272829private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules(Context context) &#123; GeneratedAppGlideModule result = null; try &#123; Class&lt;GeneratedAppGlideModule&gt; clazz = (Class&lt;GeneratedAppGlideModule&gt;) Class.forName(\"com.bumptech.glide.GeneratedAppGlideModuleImpl\"); result = clazz.getDeclaredConstructor(Context.class).newInstance(context.getApplicationContext()); &#125; catch (ClassNotFoundException e) &#123; if (Log.isLoggable(TAG, Log.WARN)) &#123; Log.w( TAG, \"Failed to find GeneratedAppGlideModule. You should include an\" + \" annotationProcessor compile dependency on com.github.bumptech.glide:compiler\" + \" in your application and a @GlideModule annotated AppGlideModule implementation\" + \" or LibraryGlideModules will be silently ignored\"); &#125; // These exceptions can't be squashed across all versions of Android. &#125; catch (InstantiationException e) &#123; throwIncorrectGlideModule(e); &#125; catch (IllegalAccessException e) &#123; throwIncorrectGlideModule(e); &#125; catch (NoSuchMethodException e) &#123; throwIncorrectGlideModule(e); &#125; catch (InvocationTargetException e) &#123; throwIncorrectGlideModule(e); &#125; return result;&#125; 以上代码就非常简单了，就是通过反射创建一个GeneratedAppGlideModuleImpl对象，然后强转为GeneratedAppGlideModule类型，说明这个GeneratedAppGlideModuleImpl肯定是继承自GeneratedAppGlideModule的。到这里，很自然的我们就会去看下这个GeneratedAppGlideModuleImpl到底是个什么东东。你会发现，根本找不到GeneratedAppGlideModuleImpl这个类！那么这个类是什么时候才会生成呢？ 有一定经验的同学肯定会猜想应该是使用了编译时注解或者自定义plugin在编译的时候自动生成的。没错，就是使用编译时注解自动生成的，生成方式如下： 123456789101112131415161718192021222324@GlideModulepublic class MyGlideModule extends AppGlideModule &#123; @Override public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) &#123; super.applyOptions(context, builder); //内存缓存相关,默认是24m int memoryCacheSizeBytes = 1024 * 1024 * 20; // 20mb builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes)); &#125; @Override public boolean isManifestParsingEnabled() &#123; return false; &#125; @Override public void registerComponents(@NonNull @NotNull Context context, @NonNull @NotNull Glide glide, @NonNull @NotNull Registry registry) &#123; super.registerComponents(context, glide, registry); &#125;&#125; 自定义MyGlideModule继承自AppGlideModule，并且给MyGlideModule打上@GlideModule注解，这样在编译的时候就会自动生成GeneratedAppGlideModuleImpl：来看下GeneratedAppGlideModuleImpl这个类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.bumptech.glide;import android.content.Context;import android.util.Log;import androidx.annotation.NonNull;import com.easyliu.demo.glide_demo.MyGlideModule;import java.util.Collections;import java.util.Set;@SuppressWarnings(\"deprecation\")final class GeneratedAppGlideModuleImpl extends GeneratedAppGlideModule &#123; private final MyGlideModule appGlideModule; public GeneratedAppGlideModuleImpl(Context context) &#123; appGlideModule = new MyGlideModule(); if (Log.isLoggable(\"Glide\", Log.DEBUG)) &#123; Log.d(\"Glide\", \"Discovered AppGlideModule from annotation: com.easyliu.demo.glide_demo.MyGlideModule\"); &#125; &#125; @Override public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) &#123; appGlideModule.applyOptions(context, builder); &#125; @Override public void registerComponents(@NonNull Context context, @NonNull Glide glide, @NonNull Registry registry) &#123; appGlideModule.registerComponents(context, glide, registry); &#125; @Override public boolean isManifestParsingEnabled() &#123; return appGlideModule.isManifestParsingEnabled(); &#125; @Override @NonNull public Set&lt;Class&lt;?&gt;&gt; getExcludedModuleClasses() &#123; return Collections.emptySet(); &#125; @Override @NonNull GeneratedRequestManagerFactory getRequestManagerFactory() &#123; return new GeneratedRequestManagerFactory(); &#125;&#125; 可以看出这个类里面就是使用代理的方式调用了我们自定义的类MyGlideModule的相应的方法。 通过自定义AppGlideModule，我们可以通过GlideBuilder做很多定制化的操作，比如在MyGlideModule里面我们就把内存缓存设置为了20MB，默认是24MB的。 在MyGlideModule里面我们还覆写了isManifestParsingEnabled方法，返回false。这个方法是用来干嘛的呢？ 目前我们分析的Glide源码是基于v4版本的，在Glide的v3版本的时候，并不是使用编译时注解来扩展Glide功能的，而是通过在Manifest里面添加meta-data来实现的： 12345678910111213141516171819@Deprecatedpublic interface GlideModule extends RegistersComponents, AppliesOptions &#123;&#125;//自定义类继承自GlideModulepublic class FlickrGlideModule implements GlideModule &#123; &#123;@literal @&#125;Override public void applyOptions(Context context, GlideBuilder builder) &#123; builder.setDecodeFormat(DecodeFormat.ALWAYS_ARGB_8888); &#125; &#123;@literal @&#125;Override public void registerComponents(Context context, Glide glide) &#123; glide.register(Model.class, Data.class, new MyModelLoader()); &#125;&#125;//Manifest：&lt;meta-data android:name=\"com.bumptech.glide.samples.flickr.FlickrGlideModule\" android:value=\"GlideModule\" /&gt; 因此这个isManifestParsingEnabled是V4版本为了兼容v3版本做的处理，后续Glide继续更新的话，对应这些兼容逻辑估计会去掉的。 GlideExtension我们发现编译时注解在自动生成GeneratedAppGlideModuleImpl的同时，也自动生成了一些其他的类，比如GlideApp、GlideOptions等，如下所示： 生成这些类是干嘛的呢？根据官方文档使用-generated-api说明，这个GlideApp其实就是Generated API，用于扩展Glide的功能，为啥叫GlideApp这个名字呢？这个名字其实就是注解GlideModule里面的默认值，自定义的时候可以自行修改即可： 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface GlideModule &#123; /** * Returns the name of the class that will be used as a replacement for &#123;@code * com.bumptech.glide.Glide&#125; in Applications that depend on Glide's generated code. */ String glideName() default \"GlideApp\";&#125; GlideApp使用方式如下： 12345GlideApp.with(fragment) .load(myUrl) .placeholder(R.drawable.placeholder) .fitCenter() .into(imageView); 到这里大家肯定心想，这个跟直接使用Glide.with有啥区别啊？为啥要来这一出呢？ 刚刚我们也说了，这个GlideApp是用于扩展Glide的功能的，那么具体怎么扩展呢？来看下如下代码： 12345678910111213141516@GlideExtensionpublic class MyAppGlideExtension &#123; // Size of mini thumb in pixels. private static final int MINI_THUMB_SIZE = 100; private MyAppGlideExtension() &#123; &#125; @NonNull @GlideOption public static BaseRequestOptions&lt;?&gt; miniThumb(BaseRequestOptions&lt;?&gt; options) &#123; return options .fitCenter() .override(MINI_THUMB_SIZE); &#125;&#125; 自定义一个类MyAppGlideExtension,打上GlideExtension注解，给里面的静态方法miniThumb打上一个GlideOption注解，然后我们来编译一下代码，就会发现GlideOptions类里面多了如下代码: 1234567891011121314151617/** * @see MyAppGlideExtension#miniThumb(BaseRequestOptions) */@SuppressWarnings(\"unchecked\")@CheckResult@NonNullpublic GlideOptions miniThumb() &#123; return (GlideOptions) MyAppGlideExtension.miniThumb(this);&#125;/** * @see MyAppGlideExtension#miniThumb(BaseRequestOptions) */@CheckResultpublic static GlideOptions miniThumbOf() &#123; return new GlideOptions().miniThumb();&#125; 使用方式如下： 1234GlideApp.with(fragment) .load(url) .miniThumb(thumbnailSize) .into(imageView); 到这里大家就明白是怎么回事了： 1、@GlideExtension注解用于标识一个扩展Glide API的类。注意：被 @GlideExtension 注解的类应以工具类的思维编写。这种类应该有一个私有的、空的构造方法，应为 final 类型，并且仅包含静态方法。被注解的类可以含有静态变量，可以引用其他的类或对象 2、使用@GlideOption注解为RequestOptions添加一个自定义的选项 3、通过自动生成的GlideApp来使用自定义的RequestOptions，从而达到扩展Glide功能的目的 4、还支持使用@GlideType注解添加对新的资源类型的支持(GIF，SVG 等等)，使用方式参考：使用-generated-api 以上就是Glide v4 功能扩展的实现原理，使用编译时注解的方式实现的。关于Processor的具体实现，参考github上Glide的源代码。 Glide对象创建回到最开始，得到annotationGeneratedModule之后，就会调用checkAndInitializeGlide方法： 12345synchronized (Glide.class) &#123; if (glide == null) &#123; checkAndInitializeGlide(context, annotationGeneratedModule); &#125; &#125; 在这个方法会对Glide对象进行初始化,来看下这个方法： 1234567891011121314@GuardedBy(\"Glide.class\")private static void checkAndInitializeGlide( @NonNull Context context, @Nullable GeneratedAppGlideModule generatedAppGlideModule) &#123; // In the thread running initGlide(), one or more classes may call Glide.get(context). // Without this check, those calls could trigger infinite recursion. if (isInitializing) &#123; throw new IllegalStateException( \"You cannot call Glide.get() in registerComponents(),\" + \" use the provided Glide instance instead\"); &#125; isInitializing = true; initializeGlide(context, generatedAppGlideModule); isInitializing = false;&#125; 这个方法里面会进一步调用initializeGlide方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@GuardedBy(\"Glide.class\") @SuppressWarnings(\"deprecation\") private static void initializeGlide( @NonNull Context context, @NonNull GlideBuilder builder, @Nullable GeneratedAppGlideModule annotationGeneratedModule) &#123; Context applicationContext = context.getApplicationContext(); List&lt;com.bumptech.glide.module.GlideModule&gt; manifestModules = Collections.emptyList(); //没有读取到annotationGeneratedModule或者允许解析Manifest if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) &#123; //解析manifest，获取到GlideModule列表 manifestModules = new ManifestParser(applicationContext).parse(); &#125; //以下逻辑主要是从manifestModules里面剔除不包括在内的GlideModule对象 if (annotationGeneratedModule != null &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) &#123; Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses(); Iterator&lt;com.bumptech.glide.module.GlideModule&gt; iterator = manifestModules.iterator(); while (iterator.hasNext()) &#123; com.bumptech.glide.module.GlideModule current = iterator.next(); if (!excludedModuleClasses.contains(current.getClass())) &#123; continue; &#125; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"AppGlideModule excludes manifest GlideModule: \" + current); &#125; iterator.remove(); &#125; &#125; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) &#123; Log.d(TAG, \"Discovered GlideModule from manifest: \" + glideModule.getClass()); &#125; &#125; RequestManagerRetriever.RequestManagerFactory factory = annotationGeneratedModule != null ? annotationGeneratedModule.getRequestManagerFactory() : null; builder.setRequestManagerFactory(factory); // 调用GlideModule的applyOptions方法给GlideBuilder设置相关参数 for (com.bumptech.glide.module.GlideModule module : manifestModules) &#123; module.applyOptions(applicationContext, builder); &#125; // 调用annotationGeneratedModule的applyOptions方法给GlideBuilder设置相关参数 if (annotationGeneratedModule != null) &#123; annotationGeneratedModule.applyOptions(applicationContext, builder); &#125; //调用GlideBuilder.build方法创建Glide对象 Glide glide = builder.build(applicationContext); for (com.bumptech.glide.module.GlideModule module : manifestModules) &#123; try &#123; module.registerComponents(applicationContext, glide, glide.registry); &#125; catch (AbstractMethodError e) &#123; throw new IllegalStateException( \"Attempting to register a Glide v3 module. If you see this, you or one of your\" + \" dependencies may be including Glide v3 even though you're using Glide v4.\" + \" You'll need to find and remove (or update) the offending dependency.\" + \" The v3 module name is: \" + module.getClass().getName(), e); &#125; &#125; if (annotationGeneratedModule != null) &#123; annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry); &#125; //注册Application的ComponentCallback回调 applicationContext.registerComponentCallbacks(glide); //最终给单例对象进行赋值 Glide.glide = glide; &#125; 可以看出，Glide对象创建过程主要是传入GlideBuilder以及GeneratedAppGlideModule，通过调用GeneratedAppGlideModule的相关方法进行Glide功能扩展，在中间也对v3版本进行了兼容性处理，在最后还注册了Application的ComponentCallback回调，注册这个回调是用来干嘛的呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Glide implements ComponentCallbacks2 &#123; @Override public void onTrimMemory(int level) &#123; trimMemory(level); &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; // Do nothing. &#125; @Override public void onLowMemory() &#123; clearMemory(); &#125; /** * Clears as much memory as possible. * * @see android.content.ComponentCallbacks#onLowMemory() * @see android.content.ComponentCallbacks2#onLowMemory() */ public void clearMemory() &#123; // Engine asserts this anyway when removing resources, fail faster and consistently Util.assertMainThread(); // memory cache needs to be cleared before bitmap pool to clear re-pooled Bitmaps too. See #687. memoryCache.clearMemory(); bitmapPool.clearMemory(); arrayPool.clearMemory(); &#125; /** * Clears some memory with the exact amount depending on the given level. * * @see android.content.ComponentCallbacks2#onTrimMemory(int) */ public void trimMemory(int level) &#123; // Engine asserts this anyway when removing resources, fail faster and consistently Util.assertMainThread(); // Request managers need to be trimmed before the caches and pools, in order for the latter to // have the most benefit. for (RequestManager manager : managers) &#123; manager.onTrimMemory(level); &#125; // memory cache needs to be trimmed before bitmap pool to trim re-pooled Bitmaps too. See #687. memoryCache.trimMemory(level); bitmapPool.trimMemory(level); arrayPool.trimMemory(level); &#125; 可以看出，Glide在接收到TriMemory以及lowMemory回调的时候会做一些内存清理操作，降低内存的消耗，这个思想是值得借鉴的。 总结这篇文章主要对Glide功能扩展及Glide对象创建进行了简要分析。通过这篇文章相信大家对Glide的扩展功能以及对其对象创建过程有了一定的了解，欢迎继续学习：Glide系列之——Glide的Request执行流程及回调 本篇文章到此就结束了，感谢耐心阅读，不对之处，敬请指出～","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Glide系列之——初识Glide","slug":"android_source_analysis/glide_use","date":"2021-01-16T07:02:12.000Z","updated":"2022-02-17T07:17:37.465Z","comments":true,"path":"2021/01/16/android_source_analysis/glide_use/","link":"","permalink":"http://easyliu.com/2021/01/16/android_source_analysis/glide_use/","excerpt":"","text":"前言Glide是一个优秀的开源图片加载组件，广泛应用在各大App当中，并且也是Google官方强力推荐的一个图片加载库，根据官方文档介绍： Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。Glide 支持拉取，解码和展示视频快照，图片，和GIF动画。Glide的Api是如此的灵活，开发者甚至可以插入和替换成自己喜爱的任何网络栈。默认情况下，Glide使用的是一个定制化的基于HttpUrlConnection的栈，但同时也提供了与Google Volley和Square OkHttp快速集成的工具库。虽然Glide 的主要目标是让任何形式的图片列表的滚动尽可能地变得更快、更平滑，但实际上，Glide几乎能满足你对远程图片的拉取/缩放/显示的一切需求。 可以看出，Glide功能是非常强大的。这么优秀的开源组件，肯定是非常值得学习的。 本系列主要是分为以下几个部分： 1、Glide系列之——初识Glide 2、Glide系列之——Glide对象创建及功能扩展 3、Glide系列之——Glide的Request执行流程及回调 4、Glide系列之——Glide缓存机制 5、Glide系列之——图片变换功能Transformation 这篇文章为第一篇：Glide系列之——初识Glide 接入及使用首先我们来看下Glide的接入以及使用方式，接入方式也比较简单，通过gradle引入即可： 123456789repositories &#123; google() jcenter()&#125;dependencies &#123; implementation 'com.github.bumptech.glide:glide:4.11.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'&#125; Glide最吸引人的莫过于其使用方式了： 123456Glide.with(this) .load(\"http://goo.gl/gEgYUd\") .centerCrop() //centerCrop缩放模式 .circleCrop() //裁剪为圆形 .placeholder(ColorDrawable(Color.RED)) //占位drawable .into(img); 使用链式调用的方式，使用起来非常方便简洁。短短这几行代码的背后，glide做了大量的工作，因此glide代码量也是相当多的，在进行源码分析的时候只会对整个框架流程进行分析，不会涉及到具体代码细节的分析，感兴趣的同学可以把源码下载下来进行仔细研读 接下来分析一下Glide.with方法里面做了一些什么事情 Glide.with可以看出，Glide.with有挺多重载方法的： 12345678910111213141516171819202122232425262728293031@NonNullpublic static RequestManager with(@NonNull Context context) &#123; return getRetriever(context).get(context);&#125;@NonNullpublic static RequestManager with(@NonNull Activity activity) &#123; return getRetriever(activity).get(activity);&#125;@NonNullpublic static RequestManager with(@NonNull FragmentActivity activity) &#123; return getRetriever(activity).get(activity);&#125;@NonNullpublic static RequestManager with(@NonNull Fragment fragment) &#123; return getRetriever(fragment.getContext()).get(fragment);&#125;@SuppressWarnings(\"deprecation\")@Deprecated@NonNullpublic static RequestManager with(@NonNull android.app.Fragment fragment) &#123; return getRetriever(fragment.getActivity()).get(fragment);&#125;@NonNullpublic static RequestManager with(@NonNull View view) &#123; return getRetriever(view.getContext()).get(view);&#125; 可以传入FragmentActivity、Activity、Context、Fragment以及View，然后都会调用getRetriever(@Nullable Context context)来获取到一个RequestManagerRetriever对象： 1234567891011@NonNullprivate static RequestManagerRetriever getRetriever(@Nullable Context context) &#123; // Context could be null for other reasons (ie the user passes in null), but in practice it will // only occur due to errors with the Fragment lifecycle. Preconditions.checkNotNull( context, \"You cannot start a load on a not yet attached View or a Fragment where getActivity() \" + \"returns null (which usually occurs when getActivity() is called before the Fragment \" + \"is attached or after the Fragment is destroyed).\"); return Glide.get(context).getRequestManagerRetriever();&#125; Glide.get(context)方法用于获取Glide对象，Glide是一个单例，全局只有一个，由于构造Glide对象比较复杂，在后续的文章中会进行详细分析。 RequestManagerRetriever获取到RequestManagerRetriever之后，就会调用其get方法返回一个RequestManager，同样RequestManagerRetriever.get方法也是有很多重载方法的,也是可以传入FragmentActivity、Activity、Context、Fragment以及View参数的，我们来挑一个复杂点的：public RequestManager get(@NonNull View view)来看下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@NonNull public RequestManager get(@NonNull View view) &#123; if (Util.isOnBackgroundThread()) &#123; return get(view.getContext().getApplicationContext()); &#125; Preconditions.checkNotNull(view); Preconditions.checkNotNull( view.getContext(), \"Unable to obtain a request manager for a view without a Context\"); Activity activity = findActivity(view.getContext()); // The view might be somewhere else, like a service. if (activity == null) &#123; return get(view.getContext().getApplicationContext()); &#125; // Support Fragments. // Although the user might have non-support Fragments attached to FragmentActivity, searching // for non-support Fragments is so expensive pre O and that should be rare enough that we // prefer to just fall back to the Activity directly. if (activity instanceof FragmentActivity) &#123; Fragment fragment = findSupportFragment(view, (FragmentActivity) activity); return fragment != null ? get(fragment) : get((FragmentActivity) activity); &#125; // Standard Fragments. android.app.Fragment fragment = findFragment(view, activity); if (fragment == null) &#123; return get(activity); &#125; return get(fragment); &#125; @NonNull public RequestManager get(@NonNull Context context) &#123; if (context == null) &#123; throw new IllegalArgumentException(\"You cannot start a load on a null Context\"); &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123; if (context instanceof FragmentActivity) &#123; return get((FragmentActivity) context); &#125; else if (context instanceof Activity) &#123; return get((Activity) context); &#125; else if (context instanceof ContextWrapper // Only unwrap a ContextWrapper if the baseContext has a non-null application context. // Context#createPackageContext may return a Context without an Application instance, // in which case a ContextWrapper may be used to attach one. &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != null) &#123; return get(((ContextWrapper) context).getBaseContext()); &#125; &#125; return getApplicationManager(context); &#125; 可以看出，主要是分为几部分： 1、如果是子线程，会调用get(context)方法，最终会调用getApplicationManager(context)方法 2、然后会进行View以及View.geContext()的合法性检查，不合法就会抛出异常。不过这里写的有点问题：如果view.getContext()返回null的话，那么在第一步就会crash了，这里是不是可以提一个issue了 ^_^ 3、接下来会通过view.getContext找到对应的Activity，如果找不到对应的Activity，同样也是走getApplicationManager(context)逻辑。这里通过context找activity是我们日常开发中经常会遇到的问题，可以学习一下实现方式： 12345678910@Nullableprivate static Activity findActivity(@NonNull Context context) &#123; if (context instanceof Activity) &#123; return (Activity) context; &#125; else if (context instanceof ContextWrapper) &#123; return findActivity(((ContextWrapper) context).getBaseContext()); &#125; else &#123; return null; &#125;&#125; 4、如果acivity属于FragmentAcivity类型，就会找到对应的supportFragment。在这段代码上有一段注释，大概意思是：尽管会有非support类型的Fragment会在FragmentActivity上面，但是找non-support Fragments 非常耗时且这种case非常少，因此就直接使用FragmentActivity进行判断了。如果找到的support fragment不为空，就会调用get(fragment)方法，否则调用get(fragmentActivity)方法 5、如果activty不属于FragmentActivity类型，就会走non-support Fragment逻辑 接下来我们来看下get(support fragment)方法： 123456789101112@NonNullpublic RequestManager get(@NonNull Fragment fragment) &#123; Preconditions.checkNotNull( fragment.getContext(), \"You cannot start a load on a fragment before it is attached or after it is destroyed\"); if (Util.isOnBackgroundThread()) &#123; return get(fragment.getContext().getApplicationContext()); &#125; else &#123; FragmentManager fm = fragment.getChildFragmentManager(); return supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible()); &#125;&#125; 可以看出，如果是主线程，会走supportFragmentGet方法： 12345678910111213141516171819@NonNullprivate RequestManager supportFragmentGet( @NonNull Context context, @NonNull FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) &#123; SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm, parentHint, isParentVisible); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; // TODO(b/27524013): Factor out this Glide.get() call. Glide glide = Glide.get(context); requestManager = factory.build( glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context); current.setRequestManager(requestManager); &#125; return requestManager;&#125; 在这个方法里面，会通过getSupportRequestManagerFragment方法创建一个SupportRequestManagerFragment，然后里面会有一个RequestManager对象，如果这个RequestManager对象为null，会通过factory新建一个RequestManager然后塞给这个SupportRequestManagerFragment。注意一下，在通过factory创建RequestManager的时候，传入一个参数类型为:ActivityFragmentLifecycle,并且是从SupportRequestManagerFragment里面获取的，说明SupportRequestManagerFragment里面持有了一个ActivityFragmentLifecycle对象，根据这个名字大概可以猜出来是跟生命周期相关的。 在Glide官方文档里面也说了，Glide会自动感应页面的生命周期，在页面pause和resume的时候会自动起停load任务。 那么大概就可以看出RequestManager里面会通过这个ActivityFragmentLifecycle来感应生命周期的变化，而由于SupportRequestManagerFragment持有ActivityFragmentLifecycle对象，因此整个生命周期回调链路应该就是： SupportRequestManagerFragment -&gt; ActivityFragmentLifecycle -&gt; RequestManager 接下来我们来看下ActivityFragmentLifecycle： ActivityFragmentLifecycle1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class ActivityFragmentLifecycle implements Lifecycle &#123; private final Set&lt;LifecycleListener&gt; lifecycleListeners = Collections.newSetFromMap(new WeakHashMap&lt;LifecycleListener, Boolean&gt;()); private boolean isStarted; private boolean isDestroyed; @Override public void addListener(@NonNull LifecycleListener listener) &#123; lifecycleListeners.add(listener); if (isDestroyed) &#123; listener.onDestroy(); &#125; else if (isStarted) &#123; listener.onStart(); &#125; else &#123; listener.onStop(); &#125; &#125; @Override public void removeListener(@NonNull LifecycleListener listener) &#123; lifecycleListeners.remove(listener); &#125; void onStart() &#123; isStarted = true; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123; lifecycleListener.onStart(); &#125; &#125; void onStop() &#123; isStarted = false; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123; lifecycleListener.onStop(); &#125; &#125; void onDestroy() &#123; isDestroyed = true; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) &#123; lifecycleListener.onDestroy(); &#125; &#125;&#125;public interface Lifecycle &#123; void addListener(@NonNull LifecycleListener listener); void removeListener(@NonNull LifecycleListener listener);&#125;public interface LifecycleListener &#123; void onStart(); void onStop(); void onDestroy();&#125; 可以看出ActivityFragmentLifecycle实现了一个Lifecycle接口，里面有addListener以及removeListener两个方法用于添加LifecycleListener接口，在ActivityFragmentLifecycle里面还有onStart、onStop以及onDestory方法，这些方法应该是供SupportRequestManagerFragment调用的。接下来看下SupportRequestManagerFragment的代码： SupportRequestManagerFragment123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SupportRequestManagerFragment extends Fragment &#123; private static final String TAG = \"SupportRMFragment\"; private final ActivityFragmentLifecycle lifecycle; @Nullable private RequestManager requestManager; public SupportRequestManagerFragment() &#123; this(new ActivityFragmentLifecycle()); &#125; @VisibleForTesting @SuppressLint(\"ValidFragment\") public SupportRequestManagerFragment(@NonNull ActivityFragmentLifecycle lifecycle) &#123; this.lifecycle = lifecycle; &#125; /** * Sets the current &#123;@link com.bumptech.glide.RequestManager&#125;. * * @param requestManager The manager to put. */ public void setRequestManager(@Nullable RequestManager requestManager) &#123; this.requestManager = requestManager; &#125; @NonNull ActivityFragmentLifecycle getGlideLifecycle() &#123; return lifecycle; &#125; /** Returns the current &#123;@link com.bumptech.glide.RequestManager&#125; or null if none is put. */ @Nullable public RequestManager getRequestManager() &#123; return requestManager; &#125; //............ @Override public void onStart() &#123; super.onStart(); lifecycle.onStart(); &#125; @Override public void onStop() &#123; super.onStop(); lifecycle.onStop(); &#125; @Override public void onDestroy() &#123; super.onDestroy(); lifecycle.onDestroy(); unregisterFragmentWithRoot(); &#125;//............. 可以看出在SupportRequestManagerFragment的生命周期方法里面会自动调用ActivityFragmentLifecycle对应的方法。 以上分析了fragment生命周期感应的执行流程。既然是生命周期监听，肯定是有地方会调用Lifecycle的addListener方法来监听页面生命周期，由于RequestManager创建的时候传入了Lifecycle，因此接下来看下RequestManager的构造方法: RequestManager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public RequestManager( @NonNull Glide glide, @NonNull Lifecycle lifecycle, @NonNull RequestManagerTreeNode treeNode, @NonNull Context context) &#123; this( glide, lifecycle, treeNode, new RequestTracker(), glide.getConnectivityMonitorFactory(), context); &#125; // Our usage is safe here. @SuppressWarnings(\"PMD.ConstructorCallsOverridableMethod\") RequestManager( Glide glide, Lifecycle lifecycle, RequestManagerTreeNode treeNode, RequestTracker requestTracker, ConnectivityMonitorFactory factory, Context context) &#123; this.glide = glide; this.lifecycle = lifecycle; this.treeNode = treeNode; this.requestTracker = requestTracker; this.context = context; connectivityMonitor = factory.build( context.getApplicationContext(), new RequestManagerConnectivityListener(requestTracker)); // If we're the application level request manager, we may be created on a background thread. // In that case we cannot risk synchronously pausing or resuming requests, so we hack around the // issue by delaying adding ourselves as a lifecycle listener by posting to the main thread. // This should be entirely safe. if (Util.isOnBackgroundThread()) &#123; mainHandler.post(addSelfToLifecycle); &#125; else &#123; lifecycle.addListener(this); &#125; lifecycle.addListener(connectivityMonitor); defaultRequestListeners = new CopyOnWriteArrayList&lt;&gt;(glide.getGlideContext().getDefaultRequestListeners()); setRequestOptions(glide.getGlideContext().getDefaultRequestOptions()); glide.registerRequestManager(this); &#125; 在构造方法里面会先lifecycle.addListener(this)注册生命周期监听，来看下监听回调里面干啥了： 12345678910111213141516171819202122232425@Override public synchronized void onStart() &#123; resumeRequests(); targetTracker.onStart(); &#125; @Override public synchronized void onStop() &#123; pauseRequests(); targetTracker.onStop(); &#125; @Override public synchronized void onDestroy() &#123; targetTracker.onDestroy(); for (Target&lt;?&gt; target : targetTracker.getAll()) &#123; clear(target); &#125; targetTracker.clear(); requestTracker.clearRequests(); lifecycle.removeListener(this); lifecycle.removeListener(connectivityMonitor); mainHandler.removeCallbacks(addSelfToLifecycle); glide.unregisterRequestManager(this); &#125; 可以看出在onStart的时候Glide会自动重启request，然后在onStop的时候会自动暂停request，以及在onDestory里面会进行一些清理操作。 ConnectivityMonitor在构造函数里面同时注册了一个ConnectivityMonitor网络变化监听器，这个网络变化监听器是用来干嘛的呢？来看下其实现类DefaultConnectivityMonitor: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102final class DefaultConnectivityMonitor implements ConnectivityMonitor &#123; private static final String TAG = \"ConnectivityMonitor\"; private final Context context; @SuppressWarnings(\"WeakerAccess\") @Synthetic final ConnectivityListener listener; @SuppressWarnings(\"WeakerAccess\") @Synthetic boolean isConnected; private boolean isRegistered; private final BroadcastReceiver connectivityReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(@NonNull Context context, Intent intent) &#123; boolean wasConnected = isConnected; isConnected = isConnected(context); if (wasConnected != isConnected) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"connectivity changed, isConnected: \" + isConnected); &#125; listener.onConnectivityChanged(isConnected); &#125; &#125; &#125;; DefaultConnectivityMonitor(@NonNull Context context, @NonNull ConnectivityListener listener) &#123; this.context = context.getApplicationContext(); this.listener = listener; &#125; private void register() &#123; if (isRegistered) &#123; return; &#125; // Initialize isConnected. isConnected = isConnected(context); try &#123; // See #1405 context.registerReceiver( connectivityReceiver, new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION)); isRegistered = true; &#125; catch (SecurityException e) &#123; // See #1417, registering the receiver can throw SecurityException. if (Log.isLoggable(TAG, Log.WARN)) &#123; Log.w(TAG, \"Failed to register\", e); &#125; &#125; &#125; private void unregister() &#123; if (!isRegistered) &#123; return; &#125; context.unregisterReceiver(connectivityReceiver); isRegistered = false; &#125; @SuppressWarnings(\"WeakerAccess\") @Synthetic // Permissions are checked in the factory instead. @SuppressLint(\"MissingPermission\") boolean isConnected(@NonNull Context context) &#123; ConnectivityManager connectivityManager = Preconditions.checkNotNull( (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE)); NetworkInfo networkInfo; try &#123; networkInfo = connectivityManager.getActiveNetworkInfo(); &#125; catch (RuntimeException e) &#123; // #1405 shows that this throws a SecurityException. // b/70869360 shows that this throws NullPointerException on APIs 22, 23, and 24. // b/70869360 also shows that this throws RuntimeException on API 24 and 25. if (Log.isLoggable(TAG, Log.WARN)) &#123; Log.w(TAG, \"Failed to determine connectivity status when connectivity changed\", e); &#125; // Default to true; return true; &#125; return networkInfo != null &amp;&amp; networkInfo.isConnected(); &#125; @Override public void onStart() &#123; register(); &#125; @Override public void onStop() &#123; unregister(); &#125; @Override public void onDestroy() &#123; // Do nothing. &#125; 可以看出其主要做的事情是在onStart的时候会注册一个广播，当网络状态发生改变的时候会通过ConnectivityListener接口通知出去，然后在onStop的时候会反注册广播。来看下ConnectivityListener接口的实现类: 123456789101112131415161718private class RequestManagerConnectivityListener implements ConnectivityMonitor.ConnectivityListener &#123; @GuardedBy(\"RequestManager.this\") private final RequestTracker requestTracker; RequestManagerConnectivityListener(@NonNull RequestTracker requestTracker) &#123; this.requestTracker = requestTracker; &#125; @Override public void onConnectivityChanged(boolean isConnected) &#123; if (isConnected) &#123; synchronized (RequestManager.this) &#123; requestTracker.restartRequests(); &#125; &#125; &#125;&#125; 可以看出这里做了一件事情：当网络重新链接上的时候会自动重启request来加载图片。 可以看出Glide里面对页面的生命周期以及网络变化均进行了自动监听，不需要业务接入方再做额外的逻辑，这个也是Glide组件相比于其他图片组件的优势之一。这种思想非常值得借鉴，可以用于我们的日常开发当中。关于生命周期自动监听，MVVM框架中LiveData就是使用这一思想来避免内存泄漏问题及实现LifecycleOwner变成active自动实现observer的notify功能。 到这里，我们就获取到了一个RequestManager对象，接下来看下load方法： RequestManager.load1234567891011121314151617181920212223242526272829303132333435363738interface ModelTypes&lt;T&gt; &#123; @NonNull @CheckResult T load(@Nullable Bitmap bitmap); @NonNull @CheckResult T load(@Nullable Drawable drawable); @NonNull @CheckResult T load(@Nullable String string); @NonNull @CheckResult T load(@Nullable Uri uri); @NonNull @CheckResult T load(@Nullable File file); @NonNull @CheckResult T load(@RawRes @DrawableRes @Nullable Integer resourceId); @Deprecated @CheckResult T load(@Nullable URL url); @NonNull @CheckResult T load(@Nullable byte[] model); @NonNull @CheckResult @SuppressWarnings(\"unchecked\") T load(@Nullable Object model);&#125; 可以看出load方法是有很多重载方法的，可以加载各种资源类型，这里来看下load(String string)方法: 123456@NonNull @CheckResult @Override public RequestBuilder&lt;Drawable&gt; load(@Nullable String string) &#123; return asDrawable().load(string); &#125; load方法会先调用asDrawable方法,在RequestManager里面还有两个类似的方法asBitmap以及asGif，如下所示: 123456789101112131415161718192021222324@NonNull@CheckResultpublic RequestBuilder&lt;Bitmap&gt; asBitmap() &#123; return as(Bitmap.class).apply(DECODE_TYPE_BITMAP);&#125;@NonNull@CheckResultpublic RequestBuilder&lt;GifDrawable&gt; asGif() &#123; return as(GifDrawable.class).apply(DECODE_TYPE_GIF);&#125;@NonNull@CheckResultpublic RequestBuilder&lt;Drawable&gt; asDrawable() &#123; return as(Drawable.class);&#125;@NonNull@CheckResultpublic &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; as( @NonNull Class&lt;ResourceType&gt; resourceClass) &#123; return new RequestBuilder&lt;&gt;(glide, this, resourceClass, context);&#125; 可以看出as方法里面会生成一个RequestBuilder对象，这个resourceClass代表最终需要传给com.bumptech.glide.request.target.Target的资源类型，是Bitmap、Drawable以及GifDrawable里面的一种。关于这个Target，后续的文章会进行讲解。 RequestBuilder.load调用RequestManager的asDrawable得到RequestBuilder之后，会调用RequestBuilder的load方法： 12345678910111213@NonNull@Override@CheckResultpublic RequestBuilder&lt;TranscodeType&gt; load(@Nullable String string) &#123; return loadGeneric(string);&#125; @NonNullprivate RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) &#123; this.model = model; isModelSet = true; return this;&#125; load方法里面主要是把传入的url给保存起来 RequestBuider.into分析到这，我们再来回顾一下最开始我们使用Glide加载图片的代码： 123456Glide.with(this) .load(\"http://i.gtimg.cn/qqlive/images/20191209/i1575881814_1.jpg\") .centerCrop() .circleCrop() .placeholder(ColorDrawable(Color.RED)) .into(img); 可以看出调用load之后，接下来会调用RequestBuilder的centerCrop和circleCrop方法，这两个是Transformation，用于设置缩放模式以及裁切为圆形，关于Transformation后续会单独讲解。 设置了Transformation之后，通过placeHolder设置一个占位的drawable，然后into方法传入ImageView，接下来看下into方法： 123456789101112131415161718192021222324252627282930313233343536373839public ViewTarget&lt;ImageView, TranscodeType&gt; into(@NonNull ImageView view) &#123; Util.assertMainThread(); Preconditions.checkNotNull(view); BaseRequestOptions&lt;?&gt; requestOptions = this; if (!requestOptions.isTransformationSet() &amp;&amp; requestOptions.isTransformationAllowed() &amp;&amp; view.getScaleType() != null) &#123; // Clone in this method so that if we use this RequestBuilder to load into a View and then // into a different target, we don't retain the transformation applied based on the previous // View's scale type. switch (view.getScaleType()) &#123; case CENTER_CROP: requestOptions = requestOptions.clone().optionalCenterCrop(); break; case CENTER_INSIDE: requestOptions = requestOptions.clone().optionalCenterInside(); break; case FIT_CENTER: case FIT_START: case FIT_END: requestOptions = requestOptions.clone().optionalFitCenter(); break; case FIT_XY: requestOptions = requestOptions.clone().optionalCenterInside(); break; case CENTER: case MATRIX: default: // Do nothing. &#125; &#125; return into( glideContext.buildImageViewTarget(view, transcodeClass), /*targetListener=*/ null, requestOptions, Executors.mainThreadExecutor()); &#125; 可以看出into方法必须运行在主线程，然后如果没有设置过Transformation，会根据ImageView的缩放类型设置对应的Transformation,然后调用下面的into方法开始执行图片加载： 12345678910111213141516171819202122232425262728293031323334private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into( @NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, BaseRequestOptions&lt;?&gt; options, Executor callbackExecutor) &#123; Preconditions.checkNotNull(target); if (!isModelSet) &#123; throw new IllegalArgumentException(\"You must call #load() before calling #into()\"); &#125; Request request = buildRequest(target, targetListener, options, callbackExecutor); Request previous = target.getRequest(); if (request.isEquivalentTo(previous) &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123; // If the request is completed, beginning again will ensure the result is re-delivered, // triggering RequestListeners and Targets. If the request is failed, beginning again will // restart the request, giving it another chance to complete. If the request is already // running, we can let it continue running without interruption. if (!Preconditions.checkNotNull(previous).isRunning()) &#123; // Use the previous request rather than the new one to allow for optimizations like skipping // setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions // that are done in the individual Request. previous.begin(); &#125; return target; &#125; requestManager.clear(target); target.setRequest(request); requestManager.track(target, request); return target; &#125; 可以看出，首先会创建一个Request对象，最后通过requestManager.track(target, request)发起request请求加载图片。 到此，这篇文章就接近尾声了，总结一下： 总结这篇文章主要讲了一下Glide的使用方式、Glide生命周期及网络变化自动化监听处理，对Glide的with、load以及into方法进行了初步的分析。通过这篇文章相信大家对Glide应该有了一个整体的认识，欢迎继续学习：Glide系列之——Glide对象创建及功能扩展 本篇文章到此就结束了，感谢耐心阅读，不对之处，敬请指出～","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"LeakCanary源码解析之——dump堆栈","slug":"android_source_analysis/leakcanary_dump","date":"2020-12-26T02:11:07.000Z","updated":"2022-02-17T07:17:50.412Z","comments":true,"path":"2020/12/26/android_source_analysis/leakcanary_dump/","link":"","permalink":"http://easyliu.com/2020/12/26/android_source_analysis/leakcanary_dump/","excerpt":"","text":"前言在前一篇文章LeakCanary源码解析之——内存泄漏监测当中从源码的角度对Leakcanary中内存泄漏监测原理进行了剖析。既然监测到了内存泄漏，那么接下来就是要把堆栈给dump出来，进行堆栈分析，最终以图形化的方式展示内存泄漏堆栈。本篇文章就从源码的角度分析一下dump堆栈的过程。 本次分析的源码基于： 123dependencies &#123; debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.5'&#125; InternalLeakCanary在前一篇文章LeakCanary源码解析之——内存泄漏监测当中我们分析到，当发现可能有内存泄漏之后，就会通过OnObjectRetainedListener接口通知出去，那么我们看下谁实现了这个接口： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273internal object InternalLeakCanary : (Application) -&gt; Unit, OnObjectRetainedListener &#123; private lateinit var heapDumpTrigger: HeapDumpTrigger override fun invoke(application: Application) &#123; _application = application checkRunningInDebuggableBuild() AppWatcher.objectWatcher.addOnObjectRetainedListener(this) val heapDumper = AndroidHeapDumper(application, createLeakDirectoryProvider(application)) val gcTrigger = GcTrigger.Default val configProvider = &#123; LeakCanary.config &#125; val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME) handlerThread.start() val backgroundHandler = Handler(handlerThread.looper) heapDumpTrigger = HeapDumpTrigger( application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper, configProvider ) application.registerVisibilityListener &#123; applicationVisible -&gt; this.applicationVisible = applicationVisible heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible) &#125; registerResumedActivityListener(application) //添加桌面快捷方式 addDynamicShortcut(application) // We post so that the log happens after Application.onCreate() Handler().post &#123; // https://github.com/square/leakcanary/issues/1981 // We post to a background handler because HeapDumpControl.iCanHasHeap() checks a shared pref // which blocks until loaded and that creates a StrictMode violation. backgroundHandler.post &#123; SharkLog.d &#123; when (val iCanHasHeap = HeapDumpControl.iCanHasHeap()) &#123; is Yup -&gt; application.getString(R.string.leak_canary_heap_dump_enabled_text) is Nope -&gt; application.getString( R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason() ) &#125; &#125; &#125; &#125; &#125; @Suppress(\"ReturnCount\") private fun addDynamicShortcut(application: Application) &#123; //...........省略 try &#123; shortcutManager.addDynamicShortcuts(listOf(shortcut)) &#125; catch (ignored: Throwable) &#123; SharkLog.d(ignored) &#123; \"Could not add dynamic shortcut. \" + \"shortcutCount=$shortcutCount, \" + \"maxShortcutCountPerActivity=$&#123;shortcutManager.maxShortcutCountPerActivity&#125;\" &#125; &#125; &#125; override fun onObjectRetained() = scheduleRetainedObjectCheck() fun scheduleRetainedObjectCheck() &#123; if (this::heapDumpTrigger.isInitialized) &#123; heapDumpTrigger.scheduleRetainedObjectCheck() &#125; &#125;&#125; 发现是一个内部类InternalLeakCanary实现了这个接口，是通过在invoke方法里面通过AppWatcher.objectWatcher.addOnObjectRetainedListener(this)方式实现的这个接口，在这个invoke方法里面还初始化了一个HeapDumpTrigger对象，当收到OnObjectRetainedListener接口的onObjectRetained回调的时候，会调用scheduleRetainedObjectCheck方法，在这个方法里面会调用heapDumpTrigger.scheduleRetainedObjectCheck方法，那么可以看出这个heapDumpTrigger肯定是用于dump堆栈的（从名字也可以很明显看出来）。 到这里大家可能会抛出一个疑问：这个InternalLeakCanary是一个internal内部类，那么它的invoke方法是谁调用的呢？ 在InternalAppWatcher类的init方法里面有如下一段代码： 12345678910111213141516internal object InternalAppWatcher &#123; private val onAppWatcherInstalled: (Application) -&gt; Unit init &#123; val internalLeakCanary = try &#123; val leakCanaryListener = Class.forName(\"leakcanary.internal.InternalLeakCanary\") leakCanaryListener.getDeclaredField(\"INSTANCE\") .get(null) &#125; catch (ignored: Throwable) &#123; NoLeakCanary &#125; @kotlin.Suppress(\"UNCHECKED_CAST\") onAppWatcherInstalled = internalLeakCanary as (Application) -&gt; Unit &#125;&#125; 因为InternalLeakCanary是一个单例，可以看出，在InternalAppWatcher的初始化方法里面，先通过反射获取到了InternalLeakCanary对象，然后我们可以看到InternalLeakCanary是实现了一个函数类型接口的： 1InternalLeakCanary : (Application) -&gt; Unit 关于什么是：函数类型，参考:https://www.kotlincn.net/docs/reference/lambdas.html#函数类型。然后把internalLeakCanary强转为(Application) -&gt; Unit，保存为onAppWatcherInstalled变量。最后在InternalAppWatcher的install方法的最后面会执行这个函数类型实例调用：onAppWatcherInstalled(application)，也就会调用InternalLeakCanary的fun invoke(application: Application) 方法。 1234fun install(application: Application) &#123; //省略 onAppWatcherInstalled(application)&#125; 刚刚上面也说了，当收到OnObjectRetainedListener接口的onObjectRetained回调的时候，会调用scheduleRetainedObjectCheck方法，在这个方法里面会调用heapDumpTrigger.scheduleRetainedObjectCheck方法 heapDumpTrigger.scheduleRetainedObjectCheck接下来看下scheduleRetainedObjectCheck方法： 12345678910111213fun scheduleRetainedObjectCheck( delayMillis: Long = 0L) &#123; val checkCurrentlyScheduledAt = checkScheduledAt if (checkCurrentlyScheduledAt &gt; 0) &#123; return &#125; checkScheduledAt = SystemClock.uptimeMillis() + delayMillis backgroundHandler.postDelayed(&#123; checkScheduledAt = 0 checkRetainedObjects() &#125;, delayMillis)&#125; 这里首先会判断当前是否正在执行schedule，如果当前正在执行schedule就返回。然后会记录checkScheduledAt，根据传入的delayMillis延时之后执行checkRetainedObjects方法，在InternalLeakCanary里面调用heapDumpTrigger.scheduleRetainedObjectCheck没有传入参数，因此默认是不延时 heapDumpTrigger.checkRetainedObjects接下来看下checkRetainedObjects方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private fun checkRetainedObjects() &#123; val iCanHasHeap = HeapDumpControl.iCanHasHeap() val config = configProvider() if (iCanHasHeap is Nope) &#123; if (iCanHasHeap is NotifyingNope) &#123; // Before notifying that we can't dump heap, let's check if we still have retained object. var retainedReferenceCount = objectWatcher.retainedObjectCount if (retainedReferenceCount &gt; 0) &#123; gcTrigger.runGc() retainedReferenceCount = objectWatcher.retainedObjectCount &#125; val nopeReason = iCanHasHeap.reason() val wouldDump = !checkRetainedCount( retainedReferenceCount, config.retainedVisibleThreshold, nopeReason ) if (wouldDump) &#123; val uppercaseReason = nopeReason[0].toUpperCase() + nopeReason.substring(1) onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason)) showRetainedCountNotification( objectCount = retainedReferenceCount, contentText = uppercaseReason ) &#125; &#125; else &#123; SharkLog.d &#123; application.getString( R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason() ) &#125; &#125; return &#125; //获取残留对象的个数 var retainedReferenceCount = objectWatcher.retainedObjectCount if (retainedReferenceCount &gt; 0) &#123; //主动执行一次gc gcTrigger.runGc() //再次获取残留对象的个数 retainedReferenceCount = objectWatcher.retainedObjectCount &#125; //这个方法里面会有一些判断条件，判断是否需要dump，如果不需要就返回false if (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) return val now = SystemClock.uptimeMillis() val elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis if (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123; onRetainInstanceListener.onEvent(DumpHappenedRecently) showRetainedCountNotification( objectCount = retainedReferenceCount, contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait) ) scheduleRetainedObjectCheck( delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis ) return &#125; dismissRetainedCountNotification() val visibility = if (applicationVisible) \"visible\" else \"not visible\" dumpHeap( retainedReferenceCount = retainedReferenceCount, retry = true, reason = \"$retainedReferenceCount retained objects, app is $visibility\" ) &#125; 可以看出会先通过HeapDumpControl.iCanHasHeap()方法返回一个ICanHazHeap对象，这个对象有多种类型： 12345678910sealed class ICanHazHeap &#123; object Yup : ICanHazHeap() abstract class Nope(val reason: () -&gt; String) : ICanHazHeap() class SilentNope(reason: () -&gt; String) : Nope(reason) /** * Allows manual dumping via a notification */ class NotifyingNope(reason: () -&gt; String) : Nope(reason)&#125; 具体HeapDumpControl.iCanHasHeap()里面的实现这里就不讲了，感兴趣的同学可以深入看下。这里我们假设返回的是Yup类型，那么就会跳过第一个if条件，继续往下走。主要分为几步: 1、先通过objectWatcher.retainedObjectCount方法拿到了被objectWatcher持有的对象的个数。如果残留的对象大于0就主动执行一次gc，然后再次获取到残留对象的个数 2、通过checkRetainedCount方法判断是否需要马上dump，如果需要就返回false 3、需要马上dump之后，会检查两次dump之间的时间间隔是否小于1分钟，如果小于一分钟就会弹出一个通知说：Last heap dump was less than a minute ago，然后过一段时间再次执行scheduleRetainedObjectCheck方法 4、如果俩次dump时间间隔已经大于等于一分钟了，就会调用dumpHeap方法 heapDumpTrigger.dumpHeap接下来看下dumpHeap方法： 1234567891011121314151617181920212223242526272829303132333435363738private fun dumpHeap( retainedReferenceCount: Int, retry: Boolean, reason: String ) &#123; saveResourceIdNamesToMemory() val heapDumpUptimeMillis = SystemClock.uptimeMillis() KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis when (val heapDumpResult = heapDumper.dumpHeap()) &#123; is NoHeapDump -&gt; &#123; if (retry) &#123; SharkLog.d &#123; \"Failed to dump heap, will retry in $WAIT_AFTER_DUMP_FAILED_MILLIS ms\" &#125; scheduleRetainedObjectCheck( delayMillis = WAIT_AFTER_DUMP_FAILED_MILLIS ) &#125; else &#123; SharkLog.d &#123; \"Failed to dump heap, will not automatically retry\" &#125; &#125; showRetainedCountNotification( objectCount = retainedReferenceCount, contentText = application.getString( R.string.leak_canary_notification_retained_dump_failed ) ) &#125; is HeapDump -&gt; &#123; lastDisplayedRetainedObjectCount = 0 lastHeapDumpUptimeMillis = SystemClock.uptimeMillis() objectWatcher.clearObjectsWatchedBefore(lastHeapDumpUptimeMillis) HeapAnalyzerService.runAnalysis( context = application, heapDumpFile = heapDumpResult.file, heapDumpDurationMillis = heapDumpResult.durationMillis, heapDumpReason = reason ) &#125; &#125; &#125; 在这个方法里面会先调用heapDumper.dumpHeap()方法返回一个heapDumpResult：1、如果返回类型为NoHeapDump就代表dump heap失败 2、如果返回类型为HeapDump就代表dump heap成功，会先调用objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)方法，用于清除所有在lastHeapDumpUptimeMillis这个时间点之前创建的KeyedWeakReference对象，因为dump堆栈已经成功了，这里就不需要再持有了。然后会调用HeapAnalyzerService.runAnalysis进行堆栈分析 这个heapDumper是一个AndroidHeapDumper对象，来看下其dumpHeap方法： AndroidHeapDumper.dumpHeap123456789101112131415161718192021222324252627282930313233343536373839404142override fun dumpHeap(): DumpHeapResult &#123; val heapDumpFile = leakDirectoryProvider.newHeapDumpFile() ?: return NoHeapDump val waitingForToast = FutureResult&lt;Toast?&gt;() showToast(waitingForToast) if (!waitingForToast.wait(5, SECONDS)) &#123; SharkLog.d &#123; \"Did not dump heap, too much time waiting for Toast.\" &#125; return NoHeapDump &#125; val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager if (Notifications.canShowNotification) &#123; val dumpingHeap = context.getString(R.string.leak_canary_notification_dumping) val builder = Notification.Builder(context) .setContentTitle(dumpingHeap) val notification = Notifications.buildNotification(context, builder, LEAKCANARY_LOW) notificationManager.notify(R.id.leak_canary_notification_dumping_heap, notification) &#125; val toast = waitingForToast.get() return try &#123; val durationMillis = measureDurationMillis &#123; Debug.dumpHprofData(heapDumpFile.absolutePath) &#125; if (heapDumpFile.length() == 0L) &#123; SharkLog.d &#123; \"Dumped heap file is 0 byte length\" &#125; NoHeapDump &#125; else &#123; HeapDump(file = heapDumpFile, durationMillis = durationMillis) &#125; &#125; catch (e: Exception) &#123; SharkLog.d(e) &#123; \"Could not dump heap\" &#125; // Abort heap dump NoHeapDump &#125; finally &#123; cancelToast(toast) notificationManager.cancel(R.id.leak_canary_notification_dumping_heap) &#125; &#125; 可以看出主要代码是调用Debug.dumpHprofData(heapDumpFile.absolutePath)方法来dump堆栈，这个是系统的方法，调用这个方法dump堆栈的时候会造成整个界面卡住，因此你会发现每次Leakcanary开始dump堆栈的时候，整个App是没法操作的，这也是为什么前面要控制两次dump的时间间隔不能小于一分钟的原因，主要是为了防止频繁dump对开发者造成的干扰。 HeapAnalyzerService.runAnalysis最后来看下Heap分析：HeapAnalyzerService.runAnalysis方法： 12345678910111213141516171819202122232425262728companion object &#123; fun runAnalysis( context: Context, heapDumpFile: File, heapDumpDurationMillis: Long? = null, heapDumpReason: String = \"Unknown\" ) &#123; val intent = Intent(context, HeapAnalyzerService::class.java) intent.putExtra(HEAPDUMP_FILE_EXTRA, heapDumpFile) intent.putExtra(HEAPDUMP_REASON_EXTRA, heapDumpReason) heapDumpDurationMillis?.let &#123; intent.putExtra(HEAPDUMP_DURATION_MILLIS_EXTRA, heapDumpDurationMillis) &#125; startForegroundService(context, intent) &#125; private fun startForegroundService( context: Context, intent: Intent ) &#123; if (SDK_INT &gt;= 26) &#123; context.startForegroundService(intent) &#125; else &#123; // Pre-O behavior. context.startService(intent) &#125; &#125; &#125; 可以看出这个\brunAnalysis方法会启动给一个ForegroundService，这个HeapAnalyzerService是继承自ForegroundService的，而ForegroundService继承自IntentService。来看下HeapAnalyzerService的onHandleIntentInForeground方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950override fun onHandleIntentInForeground(intent: Intent?) &#123; if (intent == null || !intent.hasExtra(HEAPDUMP_FILE_EXTRA)) &#123; SharkLog.d &#123; \"HeapAnalyzerService received a null or empty intent, ignoring.\" &#125; return &#125; // Since we're running in the main process we should be careful not to impact it. Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND) val heapDumpFile = intent.getSerializableExtra(HEAPDUMP_FILE_EXTRA) as File val heapDumpReason = intent.getStringExtra(HEAPDUMP_REASON_EXTRA) val heapDumpDurationMillis = intent.getLongExtra(HEAPDUMP_DURATION_MILLIS_EXTRA, -1) val config = LeakCanary.config val heapAnalysis = if (heapDumpFile.exists()) &#123; analyzeHeap(heapDumpFile, config) &#125; else &#123; missingFileFailure(heapDumpFile) &#125; val fullHeapAnalysis = when (heapAnalysis) &#123; is HeapAnalysisSuccess -&gt; heapAnalysis.copy( dumpDurationMillis = heapDumpDurationMillis, metadata = heapAnalysis.metadata + (\"Heap dump reason\" to heapDumpReason) ) is HeapAnalysisFailure -&gt; heapAnalysis.copy(dumpDurationMillis = heapDumpDurationMillis) &#125; onAnalysisProgress(REPORTING_HEAP_ANALYSIS) config.onHeapAnalyzedListener.onHeapAnalyzed(fullHeapAnalysis) &#125; private fun analyzeHeap( heapDumpFile: File, config: Config ): HeapAnalysis &#123; val heapAnalyzer = HeapAnalyzer(this) val proguardMappingReader = try &#123; ProguardMappingReader(assets.open(PROGUARD_MAPPING_FILE_NAME)) &#125; catch (e: IOException) &#123; null &#125; return heapAnalyzer.analyze( heapDumpFile = heapDumpFile, leakingObjectFinder = config.leakingObjectFinder, referenceMatchers = config.referenceMatchers, computeRetainedHeapSize = config.computeRetainedHeapSize, objectInspectors = config.objectInspectors, metadataExtractor = config.metadataExtractor, proguardMapping = proguardMappingReader?.readProguardMapping() ) &#125; 可以看出如果heapDumpFile存在就会调用下面的analyzeHeap方法，在这个方法里面最终会new一个HeapAnalyzer对象，然后调用analyze方法进行堆栈分析。 到这里，整个dump堆栈的分析过程就结束了。","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"LeakCanary源码解析之——内存泄漏监测","slug":"android_source_analysis/leakcanary","date":"2020-12-19T12:51:55.000Z","updated":"2022-02-17T07:17:57.234Z","comments":true,"path":"2020/12/19/android_source_analysis/leakcanary/","link":"","permalink":"http://easyliu.com/2020/12/19/android_source_analysis/leakcanary/","excerpt":"","text":"前言在日常开发中，肯定都使用过LeakCanary这个库来监测app的内存泄漏问题。LeakCanary会自动监测、分析以及上报内存泄漏，其工作主要是分为以下四步： 1、监测泄漏的对象 2、dump堆栈 3、分析堆栈 4、对泄漏进行归类,然后通过通知的方式上报内存泄漏 那么LeakCanary监测内存泄漏的原理是什么呢，怎么判断一个Activity或者Fragment被泄漏了呢？本篇文章就从源码的角度来对LeakCanary工作的第一步：监测泄漏的对象 来进行剖析。 本次分析源码基于： 123dependencies &#123; debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.5'&#125; 对应的github官网：https://github.com/square/leakcanary 有一个需要注意的点： LeakCanary 2.x版本相比之前的1.x版本相比有比较大的改动，包括集成方式的改变以及使用kotlin进行了重写，如果之前项目中集成的是1.x版本，想升级到2.x版本的话，可以参考官网的升级文档：https://square.github.io/leakcanary/upgrading-to-leakcanary-2.0/ 本次源码分析是基于kotlin的，如果对kotlin不太了解，可以上kotlin中文官网学习一下：https://www.kotlincn.net/docs/reference/ 关于LeakCanary更多资料参考官网：https://square.github.io/leakcanary/ 源码分析根据官方文档，升级到2.x版本之后，只需要在gradle集成一下leakcanary就行了，在2.x版本之前是需要应用的Application里面主动调用以下代码来安装Leakcanary的： 12345678910111213public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return; &#125; LeakCanary.install(this); // Normal app init code... &#125;&#125; 那么2.x版本是怎么做到自动自动安装Leakcanary的呢？到这里大家可能会想到使用ContentProvider？ LeakCanary安装没错，在Leakcanary里面有一个AppWatcherInstaller类，继承自ContentProvider： 1234567891011/** * Content providers are loaded before the application class is created. [AppWatcherInstaller] is * used to install [leakcanary.AppWatcher] on application start. */internal sealed class AppWatcherInstaller : ContentProvider() &#123; override fun onCreate(): Boolean &#123; val application = context!!.applicationContext as Application AppWatcher.manualInstall(application) return true &#125; 在manifest里面的定义如下： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.squareup.leakcanary.objectwatcher\" &gt; &lt;uses-sdk android:minSdkVersion=\"14\" /&gt; &lt;application&gt; &lt;provider android:name=\"leakcanary.internal.AppWatcherInstaller$MainProcess\" android:authorities=\"$&#123;applicationId&#125;.leakcanary-installer\" android:enabled=\"@bool/leak_canary_watcher_auto_install\" android:exported=\"false\" /&gt; &lt;/application&gt;&lt;/manifest&gt; 可以通过leak_canary_watcher_auto_install开关控制其是否enable。 从AppWatcherInstaller可以看出在onCreate方法里面调用了AppWatcher.manualInstall(application)方法： 123456789101112131415161718object AppWatcher &#123; /** * [AppWatcher] is automatically installed in the main process on startup. You can * disable this behavior by overriding the `leak_canary_watcher_auto_install` boolean resource: * * * &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; * &lt;resources&gt; * &lt;bool name=\"leak_canary_watcher_auto_install\"&gt;false&lt;/bool&gt; * &lt;/resources&gt; * * * If you disabled automatic install then you can call this method to install [AppWatcher]. */ fun manualInstall(application: Application) &#123; InternalAppWatcher.install(application) &#125;&#125; 这个AppWatcher是一个单例，如果我们通过设置leak_canary_watcher_auto_install把AppWatcher自动安装给关掉了，外部可以直接调用AppWatcher.manualInstall(application)方法进行手动安装。AppWatcher还提供了一个Config类来进行一些配置，比如配置是否要监测fragment销毁，是否要监测ViewModel销毁以及监测时长等等，具体可以深入AppWatcher里面去查看，config使用方式为: 12345678910111213141516/** * Builder for [Config] intended to be used only from Java code. * * Usage: * * AppWatcher.Config config = AppWatcher.getConfig().newBuilder() * .watchFragmentViews(false) * .build(); * AppWatcher.setConfig(config); * * * For idiomatic Kotlin use `copy()` method instead: * * AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = false) * */ 在AppWatcher.manualInstall里面又调用了InternalAppWatcher.install方法: 123456789101112131415161718192021222324252627internal object InternalAppWatcher &#123; private val checkRetainedExecutor = Executor &#123; mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis) &#125; val objectWatcher = ObjectWatcher( clock = clock, checkRetainedExecutor = checkRetainedExecutor, isEnabled = &#123; true &#125; ) fun install(application: Application) &#123; checkMainThread() if (this::application.isInitialized) &#123; return &#125; InternalAppWatcher.application = application if (isDebuggableBuild) &#123; SharkLog.logger = DefaultCanaryLog() &#125; val configProvider = &#123; AppWatcher.config &#125; ActivityDestroyWatcher.install(application, objectWatcher, configProvider) FragmentDestroyWatcher.install(application, objectWatcher, configProvider) onAppWatcherInstalled(application) &#125;&#125; 在InternalAppWatcher的install当中，首先检查是否在主线程，如果不是在主线程就会抛crash。然后分别调用了ActivityDestoryWatcher.install方法以及FragmentDestroyWatcher.install方法，传入了全局的AppWatcher.config配置以及一个ObjectWatcher对象。这个ObjectWatcher才是真正的主角，稍后会讲到。接下来看下ActivityDestroyWatcher的实现原理。FragmentDestroyWatcher的实现原理也是差不多的，只不过是监听fragment的destory的回调而已，感兴趣的可以看下 ActivityDestroyWatcher12345678910111213141516171819202122232425262728internal class ActivityDestroyWatcher private constructor( private val objectWatcher: ObjectWatcher, private val configProvider: () -&gt; Config) &#123; private val lifecycleCallbacks = object : Application.ActivityLifecycleCallbacks by noOpDelegate() &#123; override fun onActivityDestroyed(activity: Activity) &#123; if (configProvider().watchActivities) &#123; objectWatcher.watch( activity, \"$&#123;activity::class.java.name&#125; received Activity#onDestroy() callback\" ) &#125; &#125; &#125; companion object &#123; fun install( application: Application, objectWatcher: ObjectWatcher, configProvider: () -&gt; Config ) &#123; val activityDestroyWatcher = ActivityDestroyWatcher(objectWatcher, configProvider) application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks) &#125; &#125;&#125; 可以看出install方法里面就是往application里面注册了一个ActivityLifecycleCallbacks，当activity销毁的时候，就会调用objectWatcher的watch方法来观察这个对象。那么监测activity是否泄漏的逻辑肯定是在这个watch方法里面了！刚刚前面前面也说了ObjectWatcher才是真正的主角，那么我们来重点分析一下这个ObjectWatcher： ObjectWatcher1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * [ObjectWatcher] can be passed objects to [watch]. It will create [KeyedWeakReference] instances * that reference watches objects, and check if those references have been cleared as expected on * the [checkRetainedExecutor] executor. If not, these objects are considered retained and * [ObjectWatcher] will then notify the [onObjectRetainedListener] on that executor thread. * * [checkRetainedExecutor] is expected to run its tasks on a background thread, with a significant * to give the GC the opportunity to identify weakly reachable objects. * * [ObjectWatcher] is thread safe. */// Thread safe by locking on all methods, which is reasonably efficient given how often// these methods are accessed.class ObjectWatcher constructor( private val clock: Clock, private val checkRetainedExecutor: Executor, /** * Calls to [watch] will be ignored when [isEnabled] returns false */ private val isEnabled: () -&gt; Boolean = &#123; true &#125;) &#123; private val onObjectRetainedListeners = mutableSetOf&lt;OnObjectRetainedListener&gt;() /** * References passed to [watch]. */ private val watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;() private val queue = ReferenceQueue&lt;Any&gt;() @Synchronized fun addOnObjectRetainedListener(listener: OnObjectRetainedListener) &#123; onObjectRetainedListeners.add(listener) &#125; @Synchronized fun removeOnObjectRetainedListener(listener: OnObjectRetainedListener) &#123; onObjectRetainedListeners.remove(listener) &#125; @Synchronized fun watch(watchedObject: Any) &#123; watch(watchedObject, \"\") &#125; /** * Watches the provided [watchedObject]. * * @param description Describes why the object is watched. */ @Synchronized fun watch( watchedObject: Any, description: String ) &#123; if (!isEnabled()) &#123; return &#125; removeWeaklyReachableObjects() val key = UUID.randomUUID() .toString() val watchUptimeMillis = clock.uptimeMillis() val reference = KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue) SharkLog.d &#123; \"Watching \" + (if (watchedObject is Class&lt;*&gt;) watchedObject.toString() else \"instance of $&#123;watchedObject.javaClass.name&#125;\") + (if (description.isNotEmpty()) \" ($description)\" else \"\") + \" with key $key\" &#125; watchedObjects[key] = reference checkRetainedExecutor.execute &#123; moveToRetained(key) &#125; &#125; @Synchronized private fun moveToRetained(key: String) &#123; removeWeaklyReachableObjects() val retainedRef = watchedObjects[key] if (retainedRef != null) &#123; retainedRef.retainedUptimeMillis = clock.uptimeMillis() onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125; &#125; &#125; private fun removeWeaklyReachableObjects() &#123; // WeakReferences are enqueued as soon as the object to which they point to becomes weakly // reachable. This is before finalization or garbage collection has actually happened. var ref: KeyedWeakReference? do &#123; ref = queue.poll() as KeyedWeakReference? if (ref != null) &#123; watchedObjects.remove(ref.key) &#125; &#125; while (ref != null) &#125;&#125; 在watch方法当中，首先会调用一个removeWeaklyReachableObjects方法。在这里先引入一个知识点： Java的WeakRefrence可以关联一个queue，当弱引用保存的对象被回收了，就会把这个弱引用对象放入这个队列里面。 因此removeWeaklyReachableObjects方法主要做的事情是：从queue里面获取到一个弱引用对象，如果这个弱引用对象不为空，就把这个弱引用对象对应的对象从watchedObjects里面给移除掉，代表这个对象被回收了，没有泄漏。 执行removeWeaklyReachableObjects方法之后就会把传入的观察对象封装成一个KeyedWeakReference对象放入watchedObjects这个map当中保存起来。 最后会调用checkRetainedExecutor线程池来执行一个task。这个线程池的实现也挺简单的: 123private val checkRetainedExecutor = Executor &#123; mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)&#125; 就是延时一段时间来执行task,这个延时时间默认是5s，外部可配置。 延时一段时候之后，执行这个task,这个task里面会调用moveToRetained方法。可以看出这个方法也会先调用一下removeWeaklyReachableObjects方法，把可以被回收的对象从map里面移掉，然后再判断map里面是否还保存这个key对应的弱引用对象，如果还保存说明可能发生内存泄漏了！这个时候就会通过onObjectRetainedListeners通知出去交给下一步：dump堆栈 进行处理。在dump堆栈这步里面会先执行gc来进行对象回收，然后再次通过removeWeaklyReachableObjects方法来判断是否真正发生了内存泄漏，如果出现了内存泄漏就会进行dump堆栈处理，最终通过通知的方式上报内存泄漏。 总结以上主要是针对Leakcnary中的内存泄漏监测这一部分，从源码的角度进行了分析，总结如下： 1、通过ContentProvier来进行Leakcanary自动安装（也可以采取手动安装的方式） 2、通过Lifecycle来监听activity或者fragment的destory回调 3、利用Java当中WeakRefrenece+ReferenceQueue的特性来判断弱引用对象是否被泄漏了 Leakcanary监控到有内存泄漏只是第一步，后续还有dump堆栈，分析堆栈等，后续有时间也会对这些部分进行学习。 做为一个开源库，Leakcanary框架源码还是挺值得学习的，其思想非常值得我们学习，并且个人觉得里面的kotlin代码还是写的挺好的，是学习kotlin的好材料。","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Jetpack Compose初体验","slug":"android_jetpack/compose","date":"2020-12-12T14:21:06.000Z","updated":"2022-02-17T07:16:37.294Z","comments":true,"path":"2020/12/12/android_jetpack/compose/","link":"","permalink":"http://easyliu.com/2020/12/12/android_jetpack/compose/","excerpt":"","text":"关于Jetpack Compose Android Jetpack Compose是2019 Google/IO大会上推出的一种声明式的UI开发框架，经过一年左右的演进，现在到了alpha阶段。Jetpack Compose是用于构建原生界面的新款Android工具包。它可简化并加快Android上的界面开发。使用更少的代码、强大的工具和直观的KotlinAPI，快速让应用生动而精彩，从此不再需要写xml，使用声明式的Compose函数来构建页面UI。 听起来是不是很厉害的样子？以下是android官方介绍： 从介绍可以看来google对compose还是给予厚望的。 Jetpack Compose 目前为Alpha版。API Surface尚未最终确定，预计后续会有变动。 接下来就来开启我们的Compose之旅吧，刚好还可以顺带学习一下kotlin，compose版本基于1.0.0-alpha04 环境配置安装Android Studio首先需要安装最新Canary版Android Studio预览版本，当您搭配使用Android Studio和 Jetpack Compose开发应用时，可以从智能编辑器功能中受益，这些功能包括“新建项目”模板和立即预览 Compose 界面等。下载链接：https://developer.android.com/studio/preview 创建Jetpack Compose项目关于如何创建Jetpack Compose项目，参考：https://developer.android.com/jetpack/compose/setup 基础入门首先来认识一个非常重要的概念：@Composable在Jetpack Compose中，一切UI的绘制均基于可组合函数。在开发Jetpack Compose程序过程中，基本上都是与@Composable这个注解打交道。使用Composable注解可以标记一个函数为可组合函数，可组合函数可用于描述UI界面中的具体展示内容或绘制规则。通过不同的Compose的组合或嵌套，可以很灵活的完成复杂UI的展示。比如我们在界面上展示一个简单的text，代码如下： 12345678class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContent &#123; Text(text = \"hello world!\") &#125; &#125;&#125; 运行效果如下：是不是很神奇！其实对于setContent来说，其接受@Compose注解的子元素，Text其实就是一个组合函数，在Jetpack Compose当中类似于TextView提供文本展示的能力。我们还可以换一种写法： 12345678910111213class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContent &#123; hello(name = \"hello world!\") &#125; &#125;&#125;@Composablefun hello(name: String) &#123; Text(text = name)&#125; 运行效果也是一样的。在Compose的世界里，万物皆@Compose注解。 上面只是简单的展示了一个文本，我们还可以给这个文本设置一些属性，比如常见的文本颜色，文字大小等，还可以使用Modifier来设置背景颜色、上下padding等: 1234567891011121314151617181920212223class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContent &#123; Greeting(name = \"hello world!\") &#125; &#125;&#125;@Composablefun Greeting(name: String) &#123; Text( text = name, fontSize = TextUnit.Companion.Sp(15), fontStyle = FontStyle.Italic, maxLines = 2, color = Color.Blue, modifier = Modifier.background( color = Color.Red, shape = RoundedCornerShape(20) ).padding(10.dp) )&#125; 运行效果如下： 预览使用@Preview注解支持预览功能，只需要在@Composable函数上面添加@Preview注解是可以进行预览，如下所示： 1234567891011121314151617181920212223242526//预览@Preview(showBackground = true)@Composablefun DefaultPreview() &#123; Greeting()&#125;@Composablefun Greeting()&#123; Greeting(name = \"hello world!\")&#125;@Composablefun Greeting(name: String) &#123; Text( text = name, fontSize = TextUnit.Companion.Sp(15), fontStyle = FontStyle.Italic, maxLines = 2, color = Color.Blue, modifier = Modifier.background( color = Color.Red, shape = RoundedCornerShape(20) ).padding(10.dp) )&#125; 接下来讲一下Compose当中一些常用的布局方式 常用布局在日常开发中，铁定是少不了各种布局方式的，Jetpack compose也提供了相当多的布局方式，首先是横向布局Row。 RowRow提供了横向布局的能力，如下所示： 12345678910111213141516171819202122232425//Row@Composablefun RowTest() &#123; var nameList = listOf(\"1\", \"2\", \"3\") Row( modifier = Modifier.padding(0.dp, 16.dp), verticalAlignment = Alignment.CenterVertically ) &#123; nameList.forEach() &#123; name -&gt; //进行3等分，居中展示 Text( text = \"Row $name\", fontSize = TextUnit.Companion.Sp(15), fontStyle = FontStyle.Normal, maxLines = 2, modifier = Modifier.background( color = Color.LightGray, shape = RoundedCornerShape(20) ).padding(10.dp) .weight(0.3f), textAlign = TextAlign.Center ); &#125; &#125;&#125; 效果如下所示：这里使用了weight属性进行等分，类似于LinearLayout的weight属性 ColumnColumn提供了纵向布局的能力，如下所示： 123456789101112131415161718192021@Composablefun ColumnTest() &#123; var nameList = listOf(\"1\", \"2\", \"3\") Column( modifier = Modifier.padding(0.dp, 16.dp), horizontalAlignment = Alignment.CenterHorizontally ) &#123; nameList.forEach &#123; name -&gt; Text( text = \"Column $name\", fontSize = TextUnit.Companion.Sp(15), fontStyle = FontStyle.Italic, maxLines = 2, modifier = Modifier.background( color = Color.LightGray, shape = RoundedCornerShape(20) ).padding(10.dp) ); &#125; &#125;&#125; 效果如下所示： BoxBox提供了叠放的效果，类似于FrameLayout: 12345678910111213//Stack Box@Composablefun StackDemo() &#123; Box(modifier = Modifier.padding(0.dp, 16.dp)) &#123; Text( text = \"layer one\", fontSize = TextUnit.Companion.Sp(30), color = Color.Blue, fontStyle = FontStyle.Italic ) Text(text = \"layer two\", fontSize = TextUnit.Companion.Sp(10)) &#125;&#125; 效果如下所示： 滚动列表使用ScrollableRow或ScrollableColumn可使Row或Column内的元素滚动,来看下ScrollableColumn的用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Artist &#123; var avatarImg: Int = R.drawable.icon; var name: String? = null; var intro: String? = null; var img: Int = R.drawable.img;&#125;@Composablefun ArtistCard(artist: Artist, onSelected: (Artist) -&gt; Unit) &#123; Column( Modifier .fillMaxWidth() .padding(16.dp) .clickable(onClick = &#123; onSelected(artist) &#125;) ) &#123; Row() &#123; val avatarImg = imageResource(artist.avatarImg) Image( avatarImg, modifier = Modifier.background( color = Color.Transparent, shape = RoundedCornerShape(20.dp) ) .width(60.dp).height(60.dp) ) Column( verticalArrangement = Arrangement.Center, horizontalAlignment = Alignment.CenterHorizontally, ) &#123; artist.name?.let &#123; Text(text = it) &#125; artist.intro?.let &#123; Text(text = it, modifier = Modifier.padding(0.dp, 8.dp, 0.dp, 0.dp)) &#125; &#125; &#125; val img = imageResource(artist.img) Image( img, modifier = Modifier.height(250.dp).padding(0.dp, 16.dp, 0.dp, 0.dp) .background(color = Color.LightGray, shape = RoundedCornerShape(20.dp)) .fillMaxWidth() ) &#125;&#125;@Composablefun Feed( feedItems: List&lt;Artist&gt;, onSelected: (Artist) -&gt; Unit) &#123; //ScrollableColumn ScrollableColumn(Modifier.fillMaxSize()) &#123; feedItems.forEach &#123; ArtistCard(it, onSelected) &#125; &#125;&#125;@Composableprivate fun ListDemo() &#123; val artistOne = Artist() artistOne.name = \"张三\" artistOne.intro = \"哈哈哈哈\" artistOne.avatarImg = R.drawable.icon artistOne.img = R.drawable.img val artistTwo = Artist() artistTwo.name = \"张三\" artistTwo.intro = \"哈哈哈哈\" artistTwo.avatarImg = R.drawable.icon artistTwo.img = R.drawable.img val artistThree = Artist() artistThree.name = \"张三\" artistThree.intro = \"哈哈哈哈\" artistThree.avatarImg = R.drawable.icon artistThree.img = R.drawable.img Feed(feedItems = listOf(artistOne, artistTwo, artistThree), onSelected = &#123; // Toast.makeText(this, it.name, Toast.LENGTH_SHORT).show(); &#125;) 效果如下所示： 这个ScrollableColumn就类似于Android的ScrollView，如果要显示的元素很少，这种方法效果很好，但对于大型数据集，很快就会出现性能问题。如需仅显示屏幕上可见的部分元素，可以使用LazyColumnFor或LazyRowFor： 1234567891011@Composablefun Feed( feedItems: List&lt;Artist&gt;, onSelected: (Artist) -&gt; Unit) &#123; Surface(Modifier.fillMaxSize()) &#123; LazyColumnFor(feedItems) &#123; item -&gt; ArtistCard(item, onSelected(item)) &#125; &#125;&#125; 总结以上只是Jetpack Compose的一个简单使用，还有很多高级的知识点没有涉及，包括ConstraintLayout、自定义布局、内置 Material组件、动画、主题，状态以及框架的实现原理等，如下所示： 感兴趣的同学可以花时间进行深入研究一番，应该会有收获。 总体使用下来的感受的话，结合kotlin搭配使用还是挺灵活的，第一次接触这种声明式UI的写法，还是觉得挺新奇的，做为一个新的知识点还是值得学习一下的～～～。 官方Sample里面有很多优秀的案例可以参考：https://github.com/android/compose-samples 参考：https://developer.android.com/jetpack/composehttps://developer.android.com/jetpack/compose/layouthttps://developer.android.com/jetpack/compose/mental-model","categories":[{"name":"Android架构学习","slug":"Android架构学习","permalink":"http://easyliu.com/categories/Android架构学习/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"hexo插入音频和视频","slug":"hexo/insert_video","date":"2020-11-22T04:08:15.000Z","updated":"2021-02-18T11:57:32.993Z","comments":true,"path":"2020/11/22/hexo/insert_video/","link":"","permalink":"http://easyliu.com/2020/11/22/hexo/insert_video/","excerpt":"","text":"音视频准备在线音视频如果是在线音视频的话，只要有url就行 本地音视频在public文件夹下面新建一个resources目录，把视频和音频放在这个目录里面，这里我把视频放在video子目录下面，把音频放在audio子目录下面。 为啥要把资源放在public？只有把资源放在public文件夹下面，网页才能访问！！最开始就是在这里卡了很久一直没法播放，原来是路径设置不对导致没法访问 安装插件安装aplayer以及dplayer: npm install hexo-tag-aplayer npm install hexo-tag-dplayer 关于aplayer以及dplayer语法，参考： hexo-tag-aplayer hexo-tag-dplayer Hexo博客中插入音乐/视频/ DPlayer http://dplayer.js.org/guide.html#quick-start 然后在md文件中插入如下代码，视频就正常加载起播了，这里播放的是本地视频！ 12345678910111213141516171819202122232425&#123;% dplayer \"url=/resources/video/scenery.mp4\" //设置视频目录，这里我放在了网站根目录下面，也就是public目录下面 \"pic=/resources/images/scenery_three.jpeg\" //设置封面图，同样是放在根目录下面 \"loop=yes\" //循环播放 \"theme=#FADFA3\" //主题 \"autoplay=true\" //自动播放 \"screenshot=true\" //允许截屏 \"hotkey=true\" //允许hotKey，比如点击空格暂停视频等操作 \"preload=auto\" //预加载：auto \"volume=0.9\" //初始音量 \"playbackSpeed=1\"//播放速度1倍速，可以选择1.5,2等 \"lang=zh-cn\"//语言 \"mutex=true\"//播放互斥，就比如其他视频播放就会导致这个视频自动暂停 //下面是弹幕相关 \"id=9E2E3368B56CD123BB4\" \"api=https://api.prprpr.me/dplayer/\" \"token=tokendemo\" \"maximum=1000\" \"addition=['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']\" \"user=DIYgod\" \"bottom=15%\" \"unlimited=true\"%&#125; 以上只是部分设置，更多参数设置参考DPlayer (function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer2\"),\"autoplay\":true,\"theme\":\"#FADFA3\",\"loop\":true,\"lang\":\"zh-cn\",\"screenshot\":true,\"hotkey\":true,\"preload\":\"auto\",\"volume\":0.9,\"mutex\":true,\"video\":{\"url\":\"/resources/video/scenery.mp4\",\"pic\":\"/resources/images/scenery_three.jpeg\"},\"danmaku\":{\"id\":\"9E2E3368B56CD123BB4\",\"api\":\"https://api.prprpr.me/dplayer/\",\"token\":\"tokendemo\",\"maximum\":1000,\"addition\":[\"['https://api.prprpr.me/dplayer/v3/bilibili?aid=4157142']\"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 插入音频代码,音频就正常加载起播了，这里播放的是在线音频！ aplayer安装不了，先注释： 如果您觉得写的还不错，感谢支持：","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://easyliu.com/categories/开发工具/"}],"tags":[{"name":"hexo进阶","slug":"hexo进阶","permalink":"http://easyliu.com/tags/hexo进阶/"}]},{"title":"厦门——2020.11.22-24","slug":"life/2020_11_22-24-xiamen","date":"2020-11-22T02:39:18.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/11/22/life/2020_11_22-24-xiamen/","link":"","permalink":"http://easyliu.com/2020/11/22/life/2020_11_22-24-xiamen/","excerpt":"","text":"","categories":[{"name":"旅游","slug":"旅游","permalink":"http://easyliu.com/categories/旅游/"}],"tags":[{"name":"日常生活","slug":"日常生活","permalink":"http://easyliu.com/tags/日常生活/"}]},{"title":"梧桐山——2020.11.21","slug":"life/2020_11_21_wutong_mountain","date":"2020-11-22T02:10:28.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/11/22/life/2020_11_21_wutong_mountain/","link":"","permalink":"http://easyliu.com/2020/11/22/life/2020_11_21_wutong_mountain/","excerpt":"","text":"看我犀利的眼神 置身仙境","categories":[{"name":"周末活动","slug":"周末活动","permalink":"http://easyliu.com/categories/周末活动/"}],"tags":[{"name":"日常生活","slug":"日常生活","permalink":"http://easyliu.com/tags/日常生活/"}]},{"title":"Android MVVM框架之Livedata以及ViewModel","slug":"android_jetpack/livedata","date":"2020-11-07T10:07:19.000Z","updated":"2022-02-17T07:16:54.400Z","comments":true,"path":"2020/11/07/android_jetpack/livedata/","link":"","permalink":"http://easyliu.com/2020/11/07/android_jetpack/livedata/","excerpt":"","text":"背景场景1:假设现在我们在Activity或者fragment当中会监听数据Model的回调，在回调里面会更新一些UI的状态，那么就会存在以下问题： 1、当页面不可见的时候也是能收到回调的，相当于在后台进行UI刷新，这个其实是不对的。一般情况下如果想解决这个问题的话就需要在onStop的时候反注册Model监听，然后等页面回来onStart的时候重新注册Model监听且需要主动读取一次Model数据进行ui刷新，听起来是不是很麻烦？ 2、在onDestory里面会需要主动反注册Model的回调,如果忘记反注册就会导致内存泄漏问题 针对这个问题，google在jetpack组件的Android架构组件当中提供了LiveData类来解决这个问题 场景2Activity或者Fragment在后台的时候可能由于资源不足导致销毁重新创建，就会导致界面数据丢失问题，对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的Bundle恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图 针对这个问题google在jetpack组件的Android架构组件当中提供了ViewModel类来解决这个问题 MVVM框架大家可以看下google推荐的Android架构图,如下所示。ViewModel和LiveData是一起配套使用的，组成了MVVM架构： 使用方式ViewModel及LiveData的接入方式参考:https://developer.android.com/jetpack/androidx/releases/lifecycle 下面看下使用方式：1、首先自定义一个ViewModel类: 1234567891011121314public class NameViewModel extends ViewModel &#123;// Create a LiveData with a Stringprivate MutableLiveData&lt;String&gt; currentName; public MutableLiveData&lt;String&gt; getCurrentName() &#123; if (currentName == null) &#123; currentName = new MutableLiveData&lt;String&gt;(); &#125; return currentName; &#125;// Rest of the ViewModel...&#125; 自定义一个NamaViewModel继承自ViewModel，稍后会对ViewModel源码进行解析。里面有一个MutableLiveData对象，它是LiveData子类，稍后会对LiveData源码进行解析。 2、接下来看下这个NameViewModel的使用方式： 1234567891011121314151617181920212223242526public class NameActivity extends AppCompatActivity &#123; private NameViewModel model; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Other code to setup the activity... // Get the ViewModel. model = new ViewModelProvider(this,new NewInstanceFactory()).get(NameViewModel.class); // Create the observer which updates the UI. final Observer&lt;String&gt; nameObserver = new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable final String newName) &#123; // Update the UI, in this case, a TextView. nameTextView.setText(newName); &#125; &#125;; // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. model.getCurrentName().observe(this, nameObserver); &#125;&#125; 可以看出从ViewModelProvider里面根据class类型到了一个NameViewModel，然后给里面的LiveData注册了一个观察者Observer，在这个Observer会更新TextView的显示文本 3、更新数据： 1234567button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; String anotherName = \"John Doe\"; model.getCurrentName().setValue(anotherName); &#125;&#125;); 更新数据的方式也很简单，调用LiveData里面的\bsetValue方法即可，如果是在子线程，就调用postValue方法 以上就是ViewModel+LiveData的使用方式，接下来分别对LiveData及ViewModel进行源码剖析 LiveDataLiveData为什么可以解决开头提到的第一个问题场景1 来看下官网关于LiveData的描述： LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。LiveData 只会将更新通知给活跃的观察者。为观察 LiveData 对象而注册的非活跃观察者不会收到更改通知 看起来很厉害的样子，接下来从源码的角度来进行分析： LiveData源码解析首先是observer方法：12345678910111213141516public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // ignore return; &#125; LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; throw new IllegalArgumentException(\"Cannot add the same observer\" + \" with different lifecycles\"); &#125; if (existing != null) &#123; return; &#125; owner.getLifecycle().addObserver(wrapper);&#125; 可以看到observer方法传入了2个参数： LifecycleOwner（如果对LifecycleOwner不太了解，参考之前的博文：Android生命周期感应组件lifecycle ）和Observer接口，Oberver就是一个简单的观察接口，通过泛型代表具体的数据类型： 1234567public interface Observer&lt;T&gt; &#123; /** * Called when the data is changed. * @param t The new data */ void onChanged(@Nullable T t);&#125; 方法主要分为几部分： 1、如果当前LifecycleOwner是destoryed的状态就直接返回2、生成一个LifecycleBoundObserver对象wrapper，放入mObservers这个Map当中3、最后把wrapper加入到Lifecycle里面，从这里可以看出LifecycleBoundObserver实现了Lifecycle接口 解析来看下这个LifecycleBoundObserver对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;T&gt; observer) &#123; super(observer); mOwner = owner; &#125; @Override boolean shouldBeActive() &#123; return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; //1、在LifecycleOwner销毁了之后会自动移除obverver，解决内存泄漏问题 if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(mObserver); return; &#125; activeStateChanged(shouldBeActive()); &#125; @Override boolean isAttachedTo(LifecycleOwner owner) &#123; return mOwner == owner; &#125; @Override void detachObserver() &#123; mOwner.getLifecycle().removeObserver(this); &#125; &#125; private abstract class ObserverWrapper &#123; final Observer&lt;T&gt; mObserver; boolean mActive; int mLastVersion = START_VERSION; ObserverWrapper(Observer&lt;T&gt; observer) &#123; mObserver = observer; &#125; abstract boolean shouldBeActive(); boolean isAttachedTo(LifecycleOwner owner) &#123; return false; &#125; void detachObserver() &#123; &#125; void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; return; &#125; // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; //变成active状态 if (wasInactive &amp;&amp; mActive) &#123; onActive(); &#125; //变成InActive状态 if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; onInactive(); &#125; //2、从InActive变成Active，会自动dispatchVaule，也就是页面可见的时候就会自动收到最新的数据回调 if (mActive) &#123; dispatchingValue(this); &#125; &#125; &#125; 从以上代码可以看出，LifecycleBoundObserver实现了Lifecycle生命周期接口，能够自动感应生命周期的变化，并且解决了最开始场景1提出的2个问题： 1、在LifecycleOwner销毁了之后会自动移除obverver，解决内存泄漏问题2、从InActive变成Active，会自动dispatchVaule，也就是页面可见的时候就会自动收到最新的数据回调 我们还注意到LiveData有两个方法:onActive和onInactive，这两个方法在LiveData是空方法，子类可以覆写这俩个方法，在里面做一些注册和反注册的操作，如下所示： 123456789101112131415161718192021222324public class StockLiveData extends LiveData&lt;BigDecimal&gt; &#123; private StockManager stockManager; private SimplePriceListener listener = new SimplePriceListener() &#123; @Override public void onPriceChanged(BigDecimal price) &#123; setValue(price); &#125; &#125;; public StockLiveData(String symbol) &#123; stockManager = new StockManager(symbol); &#125; @Override protected void onActive() &#123; stockManager.requestPriceUpdates(listener); &#125; @Override protected void onInactive() &#123; stockManager.removeUpdates(listener); &#125;&#125; 接下来是setValue以及postValue12345678910111213141516171819202122232425262728293031323334353637383940private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; Object newValue; synchronized (mDataLock) &#123; newValue = mPendingData; mPendingData = NOT_SET; &#125; //noinspection unchecked setValue((T) newValue); &#125;&#125;;protected void postValue(T value) &#123; boolean postTask; synchronized (mDataLock) &#123; postTask = mPendingData == NOT_SET; mPendingData = value; &#125; if (!postTask) &#123; return; &#125; ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);&#125;/** * Sets the value. If there are active observers, the value will be dispatched to them. * &lt;p&gt; * This method must be called from the main thread. If you need set a value from a background * thread, you can use &#123;@link #postValue(Object)&#125; * * @param value The new value */@MainThreadprotected void setValue(T value) &#123; assertMainThread(\"setValue\"); mVersion++; mData = value; dispatchingValue(null);&#125; 可以看出postValue用于在子线程调用的场景，post到主线程执行setValue。这里大家可能有个疑问就是这个postValue以及setValue都是protected方法，外部怎么调用呢？一般情况下使用MutableLiveData： 1234567891011121314151617/** * &#123;@link LiveData&#125; which publicly exposes &#123;@link #setValue(T)&#125; and &#123;@link #postValue(T)&#125; method. * * @param &lt;T&gt; The type of data hold by this instance */@SuppressWarnings(\"WeakerAccess\")public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt; &#123; @Override public void postValue(T value) &#123; super.postValue(value); &#125; @Override public void setValue(T value) &#123; super.setValue(value); &#125;&#125; 以上就是LiveData源码分析结果，可以看出主要还是借助了Lifecycle生命周期自动感应的特性来解决问题。LiveData还有一些高级的玩法，具体参考：https://developer.android.com/topic/libraries/architecture/livedata ViewModelViewModel为什么可以解决开头提到的第二个问题场景2 来看下官网关于ViewModel的描述： ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel类让数据可在发生屏幕旋转等配置更改后继续留存。 先来回顾一下ViewModel的使用方式： 123456789101112131415161718192021222324252627public class NameActivity extends AppCompatActivity &#123; private NameViewModel model; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Other code to setup the activity... // Get the ViewModel. // 只要是同一个Activity，数据就是同一份 model = new ViewModelProvider(this,new NewInstanceFactory()).get(NameViewModel.class); // Create the observer which updates the UI. final Observer&lt;String&gt; nameObserver = new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable final String newName) &#123; // Update the UI, in this case, a TextView. nameTextView.setText(newName); &#125; &#125;; // Observe the LiveData, passing in this activity as the LifecycleOwner and the observer. model.getCurrentName().observe(this, nameObserver); &#125;&#125; 可以看出如果重新创建了NameActivity，它接收的NameViewModel实例与第一个NameActivity创建的实例相同，这样就数据就不会存在丢失的问题。当所有者NameActivity走了finish销毁之后，框架会调用ViewModel对象的onCleared()方法，以便它可以清理资源。 来看下ViewModel的生命周期 ViewModel生命周期ViewModel 对象存在的时间范围是获取 ViewModel 时传递给 ViewModelProvider 的 Lifecycle。ViewModel 将一直留在内存中，直到限定其存在时间范围的 Lifecycle 永久消失：对于 Activity，是在 Activity 完成时；而对于 Fragment，是在 Fragment 分离时。如下图所示： 在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel。系统可能会在 Activity 的整个生命周期内多次调用 onCreate()，如在旋转设备屏幕时。ViewModel 存在的时间范围是从首次请求 ViewModel 直到 Activity 完成并销毁。 接下来看下对ViewModel源码进行解析： ViewModel源码解析ViewModel：1234567891011public abstract class ViewModel &#123; /** * This method will be called when this ViewModel is no longer used and will be destroyed. * &lt;p&gt; * It is useful when ViewModel observes some data and you need to clear this subscription to * prevent a leak of this ViewModel. */ @SuppressWarnings(\"WeakerAccess\") protected void onCleared() &#123; &#125;&#125; 可以看出ViewModel本身的话比较简单，就是一个抽象类，里面有一个onCleared（）方法，子类在这个方法里面可以做一些资源清理的操作 ViewModel有一个子类AndroidViewModel： 123456789101112131415161718public class AndroidViewModel extends ViewModel &#123; @SuppressLint(\"StaticFieldLeak\") private Application mApplication; public AndroidViewModel(@NonNull Application application) &#123; mApplication = application; &#125; /** * Return the application. */ @SuppressWarnings(\"TypeParameterUnusedInFormals\") @NonNull public &lt;T extends Application&gt; T getApplication() &#123; //noinspection unchecked return (T) mApplication; &#125;&#125; 一般情况下我们使用的时候是直接继承自AndroidViewModel，因为里面持有Application,可以获取到Android系统的一些系统资源 那么到这里大家就会有个疑问，ViewModel就这么简单？ViewModel的onCleared()方法是谁负责调用的呢？ 首先ViewModel的获取方式为： 1model = new ViewModelProvider(this,new NewInstanceFactory()).get(NameViewModel.class); ViewModelProvider我们来看下ViewModelProvider构造函数： 12345678public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) &#123; this(owner.getViewModelStore(), factory);&#125;public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) &#123; mFactory = factory; this.mViewModelStore = store;&#125; 可以看出传入的第一个参数为一个接口ViewModelStoreOwner，说明Activity实现了这个接口，返回一个ViewModelStore类型，第二个参数是一个工厂类，代表model创建工厂,系统提供了两个默认的工厂，分别是NewInstanceFactory用于创建普通的ViewModel，AndroidViewModelFactory用于创建AndroidViewModel 接下来看下get方法： 123456789101112131415161718192021222324252627282930@NonNull @MainThread public &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException(\"Local and anonymous classes can not be ViewModels\"); &#125; return get(DEFAULT_KEY + \":\" + canonicalName, modelClass); &#125; @NonNull @MainThread public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel; &#125; 可以看出get方法就是从ViewModleStore里面根据key获得一个ViewModel返回，如果获取不到就通过factory创建一个ViewModel放入ViewModelStore当中,然后返回ViewModel。 ViewModelStore那么这里我们来看下ViewModelStore是个什么东东： 12345678910111213141516171819202122232425public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.onCleared(); &#125; mMap.clear(); &#125;&#125; 可以看到ViewModelStore里面其实就是一个HashMap，存有这个ViewModelProvider里面所有的ViewModel，一个ViewModelProvider跟一个页面进行对应。可以看到ViewModelStore里面还有一个clear方法，里面就调用了每个ViewModel的onCleared()方法，根据前面对ViewModel生命周期的说明，这个clear方法应该是在lifecycle的onDestroyed方法调用的。 通过Android Studio的find usage找到这个clear()方法的调用链，发现在lifecycle的extension包下面找到了一个叫做HolderFragment的类: HolderFragment12345678910111213141516171819202122232425262728293031/** * @hide */@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)public class HolderFragment extends Fragment implements ViewModelStoreOwner &#123; .............. private ViewModelStore mViewModelStore = new ViewModelStore(); ................ @Override public void onDestroy() &#123; super.onDestroy(); mViewModelStore.clear(); &#125; /** * @hide */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public static HolderFragment holderFragmentFor(FragmentActivity activity) &#123; return sHolderFragmentManager.holderFragmentFor(activity); &#125; /** * @hide */ @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP) public static HolderFragment holderFragmentFor(Fragment fragment) &#123; return sHolderFragmentManager.holderFragmentFor(fragment); &#125; 在这个fragment的onDestroy()方法里面调用了ViewModelStore的clear方法。熟悉lifecycle的朋友看到这里是不是有一种豁然开朗的感觉，这个HolderFragment肯定是跟ViewModelProvider对应的页面进行了绑定！那么HolderFragment是啥时候跟页面进行绑定的呢？ 来看下holderFragmentFor(FragmentActivity activity)调用的地方： ViewModelStores123456789101112131415161718192021@SuppressWarnings(\"WeakerAccess\")public class ViewModelStores &#123; @NonNull @MainThread public static ViewModelStore of(@NonNull FragmentActivity activity) &#123; if (activity instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) activity).getViewModelStore(); &#125; return holderFragmentFor(activity).getViewModelStore(); &#125; @NonNull @MainThread public static ViewModelStore of(@NonNull Fragment fragment) &#123; if (fragment instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) fragment).getViewModelStore(); &#125; return holderFragmentFor(fragment).getViewModelStore(); &#125;&#125; 可以看出这个ViewModelStores是一个工具类，用于生成ViewModelStore，而这个ViewModelStore就是从HolderFragment获取的，这个HolderFragment就挂载在这个fragment或者activity上面，接下来看下ViewModelStores的of方法调用的地方： ViewModelProviders1234567891011121314151617181920212223242526272829303132333435public class ViewModelProviders &#123; @NonNull @MainThread public static ViewModelProvider of(@NonNull Fragment fragment) &#123; return of(fragment, null); &#125; @NonNull @MainThread public static ViewModelProvider of(@NonNull FragmentActivity activity) &#123; return of(activity, null); &#125; @NonNull @MainThread public static ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory) &#123; Application application = checkApplication(checkActivity(fragment)); if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; return new ViewModelProvider(ViewModelStores.of(fragment), factory); &#125; @NonNull @MainThread public static ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory) &#123; Application application = checkApplication(activity); if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; return new ViewModelProvider(ViewModelStores.of(activity), factory); &#125;&#125; 可以看出这个ViewModelProviders是一个工具类，用于生成ViewModelProvider，这里面就会调用ViewModelStores的of方法获取ViewModelStore，而我们刚刚也说了这个of方法里面就会挂载一个HolderFragment用于感应对应页面的生命周期。因此，要想自定义的ViewModel在页面销毁的时候能够自动调用onCleared()方法，得通过ViewModelProviders来获取： 1viewModelProvider= ViewModelProviders.of(this); 至此ViewModel源码分析完成,更多高级玩法参考：https://developer.android.com/topic/libraries/architecture/viewmodel 总结至此LiveData+ViewModel源码已经分析完成，结合之前的Android生命周期感应组件lifecycle,整个就组成了MVVM架构。 这个架构里面很多思想值得我们细细品味～～ 基于这个LiveData这些优良的特性，美团技术团队开发了一个LiveDataEventBus来代替传统的EventBus、RxJava等消息框架,感兴趣的可以看看：https://tech.meituan.com/2018/07/26/android-livedatabus.html https://github.com/JeremyLiao/LiveEventBus","categories":[{"name":"Android架构学习","slug":"Android架构学习","permalink":"http://easyliu.com/categories/Android架构学习/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"早起龙城公园爬山——2020.11.1","slug":"life/2020_11_1_longcheng_park","date":"2020-11-01T08:59:16.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/11/01/life/2020_11_1_longcheng_park/","link":"","permalink":"http://easyliu.com/2020/11/01/life/2020_11_1_longcheng_park/","excerpt":"","text":"空气新鲜(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"autoplay\":true,\"theme\":\"#FADFA3\",\"loop\":true,\"video\":{\"url\":\"/resources/video/scenery.mp4\",\"pic\":\"/resources/image/scenery_three.jpeg\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 你大爷还是你大爷","categories":[{"name":"周末活动","slug":"周末活动","permalink":"http://easyliu.com/categories/周末活动/"}],"tags":[{"name":"日常生活","slug":"日常生活","permalink":"http://easyliu.com/tags/日常生活/"}]},{"title":"Android生命周期感应组件lifecycle","slug":"android_jetpack/lifecycle","date":"2020-10-31T08:34:04.000Z","updated":"2022-02-17T07:16:49.484Z","comments":true,"path":"2020/10/31/android_jetpack/lifecycle/","link":"","permalink":"http://easyliu.com/2020/10/31/android_jetpack/lifecycle/","excerpt":"","text":"背景生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您写出更有条理且往往更精简的代码，这样的代码更易于维护。 一种常见的模式是在 Activity 和 Fragment 的生命周期方法中实现依赖组件的操作。但是，这种模式会导致代码条理性很差而且会扩散错误。通过使用生命周期感知型组件，您可以将依赖组件的代码从生命周期方法移入组件本身中。 androidx.lifecycle 软件包提供了可用于构建生命周期感知型组件的类和接口 - 这些组件可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。导入方法 在 Android 框架中定义的大多数应用组件都存在生命周期。生命周期由操作系统或进程中运行的框架代码管理。它们是 Android 运作方式的核心，应用必须遵循它们。如果不这样做，可能会引发内存泄露甚至应用崩溃。 假设我们有一个在屏幕上显示设备位置的 Activity。常见的实现可能如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940class MyLocationListener &#123; public MyLocationListener(Context context, Callback callback) &#123; // ... &#125; void start() &#123; // connect to system location service &#125; void stop() &#123; // disconnect from system location service &#125;&#125;class MyActivity extends AppCompatActivity &#123; private MyLocationListener myLocationListener; @Override public void onCreate(...) &#123; myLocationListener = new MyLocationListener(this, (location) -&gt; &#123; // update UI &#125;); &#125; @Override public void onStart() &#123; super.onStart(); myLocationListener.start(); // manage other components that need to respond // to the activity lifecycle &#125; @Override public void onStop() &#123; super.onStop(); myLocationListener.stop(); // manage other components that need to respond // to the activity lifecycle &#125;&#125; 虽然此示例看起来没问题，但在真实的应用中，最终会有太多管理界面和其他组件的调用，以响应生命周期的当前状态。管理多个组件会在生命周期方法（如 onStart() 和 onStop()）中放置大量的代码，这使得它们难以维护。 androidx.lifecycle 软件包提供的类和接口可帮助您以弹性和隔离的方式解决这些问题。 LifecycleLifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。 Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态： 事件从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。 状态由 Lifecycle 对象跟踪的组件的当前状态。 Lifecycle源代码如下，可以看出下Lifecycle类主要是3个方法，分别是：添加observer、移除observer以及获取当前的状态，然后类里面有关于Event和State的定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public abstract class Lifecycle &#123; /** * Adds a LifecycleObserver that will be notified when the LifecycleOwner changes * @param observer The observer to notify. */ @MainThread public abstract void addObserver(@NonNull LifecycleObserver observer); /** * Removes the given observer from the observers list. * @param observer The observer to be removed. */ @MainThread public abstract void removeObserver(@NonNull LifecycleObserver observer); /** * Returns the current state of the Lifecycle. * * @return The current state of the Lifecycle. */ @MainThread @NonNull public abstract State getCurrentState(); @SuppressWarnings(\"WeakerAccess\") public enum Event &#123; /** * Constant for onCreate event of the &#123;@link LifecycleOwner&#125;. */ ON_CREATE, /** * Constant for onStart event of the &#123;@link LifecycleOwner&#125;. */ ON_START, /** * Constant for onResume event of the &#123;@link LifecycleOwner&#125;. */ ON_RESUME, /** * Constant for onPause event of the &#123;@link LifecycleOwner&#125;. */ ON_PAUSE, /** * Constant for onStop event of the &#123;@link LifecycleOwner&#125;. */ ON_STOP, /** * Constant for onDestroy event of the &#123;@link LifecycleOwner&#125;. */ ON_DESTROY, /** * An &#123;@link Event Event&#125; constant that can be used to match all events. */ ON_ANY &#125; /** * Lifecycle states. You can consider the states as the nodes in a graph and * &#123;@link Event&#125;s as the edges between these nodes. */ @SuppressWarnings(\"WeakerAccess\") public enum State &#123; /** * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch * any more events. For instance, for an &#123;@link android.app.Activity&#125;, this state is reached * &lt;b&gt;right before&lt;/b&gt; Activity's &#123;@link android.app.Activity#onDestroy() onDestroy&#125; call. */ DESTROYED, /** * Initialized state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this is * the state when it is constructed but has not received * &#123;@link android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet. */ INITIALIZED, /** * Created state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this state * is reached in two cases: * &lt;ul&gt; * &lt;li&gt;after &#123;@link android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call; * &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;@link android.app.Activity#onStop() onStop&#125; call. * &lt;/ul&gt; */ CREATED, /** * Started state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this state * is reached in two cases: * &lt;ul&gt; * &lt;li&gt;after &#123;@link android.app.Activity#onStart() onStart&#125; call; * &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;@link android.app.Activity#onPause() onPause&#125; call. * &lt;/ul&gt; */ STARTED, /** * Resumed state for a LifecycleOwner. For an &#123;@link android.app.Activity&#125;, this state * is reached after &#123;@link android.app.Activity#onResume() onResume&#125; is called. */ RESUMED; /** * Compares if this State is greater or equal to the given &#123;@code state&#125;. * * @param state State to compare with * @return true if this State is greater or equal to the given &#123;@code state&#125; */ public boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0; &#125; &#125; 类可以通过向其方法添加注解来监控组件的生命周期状态。然后，可以通过调用 Lifecycle 类的 addObserver() 方法并传递观察者的实例来添加观察者，如以下示例中所示： 12345678910111213public class MyObserver implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void connectListener() &#123; ... &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void disconnectListener() &#123; ... &#125;&#125;myLifecycleOwner.getLifecycle().addObserver(new MyObserver()); 在上面的示例中，myLifecycleOwner 对象实现了 LifecycleOwner 接口 ,接下来讲一下LifecycleOwner接口： LifecycleOwner首先来看下LifecycleOwner接口的源码： 12345678910111213141516/** * A class that has an Android lifecycle. These events can be used by custom components to * handle lifecycle changes without implementing any code inside the Activity or the Fragment. * * @see Lifecycle */@SuppressWarnings(&#123;\"WeakerAccess\", \"unused\"&#125;)public interface LifecycleOwner &#123; /** * Returns the Lifecycle of the provider. * * @return The lifecycle of the provider. */ @NonNull Lifecycle getLifecycle();&#125; Android源码中，Activity以及Fragment均实现了这个LifecycleOwner接口，这样使用就非常简单了，直接使用getLifecycle().addObserver(new MyObserver())就可以把Observer注册到Lifecycle上，自动感应生命周期了。 生命周期自动感应原理解析那么问题来了，fragment或者activity是怎么把自身的生命周期分发给每一个Observer的呢？生命周期自动感应是怎么工作的呢？我们通过解析源码来找到答案。 查看SupportActivity的源码： 12345678910111213141516171819202122public class SupportActivity extends Activity implements LifecycleOwner, Component &#123; private SimpleArrayMap&lt;Class&lt;? extends SupportActivity.ExtraData&gt;, private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); public SupportActivity() &#123; &#125; protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this); &#125; @CallSuper protected void onSaveInstanceState(Bundle outState) &#123; this.mLifecycleRegistry.markState(State.CREATED); super.onSaveInstanceState(outState); &#125; public Lifecycle getLifecycle() &#123; return this.mLifecycleRegistry; &#125;&#125; 可以看出在activity的onCreate方法调用了一个方法： ReportFragment.injectIfNeededIn(activity)，接下来看下这个init做了什么事情： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class ReportFragment extends Fragment &#123; private static final String REPORT_FRAGMENT_TAG = \"android.arch.lifecycle\" + \".LifecycleDispatcher.report_fragment_tag\"; public static void injectIfNeededIn(Activity activity) &#123; // ProcessLifecycleOwner should always correctly work and some activities may not extend // FragmentActivity from support lib, so we use framework fragments for activities android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); &#125; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); dispatchCreate(mProcessListener); dispatch(Lifecycle.Event.ON_CREATE); &#125; @Override public void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START); &#125; @Override public void onResume() &#123; super.onResume(); dispatchResume(mProcessListener); dispatch(Lifecycle.Event.ON_RESUME); &#125;..................... @Override public void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); // just want to be sure that we won't leak reference to an activity mProcessListener = null; &#125; private void dispatch(Lifecycle.Event event) &#123; Activity activity = getActivity(); if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125; &#125;&#125; 这个代码就比较清晰了：在activity上面挂了一个ReportFragment专门用来感应activity的生命周期，把activity的生命周期分发给activity里面的Lifecycle,其中activity里面的Lifecycle是一个LifecycleRegistry对象。通过这种方式就完成了activity生命周期到Lifecycle的转发。 到这里大家可能会有一个疑问了：那么fragment的生命周期是怎么感应的呢？因为fragment的生命周期是可能比activity的生命周期要短的，这个我们从fragment源码中寻找答案： 123456789101112131415void performStart() &#123; .......... this.mLifecycleRegistry.handleLifecycleEvent(Event.ON_START); if (this.mView != null) &#123; this.mViewLifecycleRegistry.handleLifecycleEvent(Event.ON_START); &#125; &#125; void performResume() &#123; .............. this.mLifecycleRegistry.handleLifecycleEvent(Event.ON_RESUME); if (this.mView != null) &#123; this.mViewLifecycleRegistry.handleLifecycleEvent(Event.ON_RESUME); &#125; &#125; 可以看出fragment中生命周期是主动转发的，主动调用LifecycleRegistry的方法进行转发。 至此，activity和fragment的生命周期转发机制已经了解清楚了，接下来我们看下LifecycleRegistry是怎么把生命周期进一步转发给LifecycleObserver的。 LifecycleRegistry源码解析上面说了activity和fragment里面都持有LifecycleRegistry,通过这个类来进行生命周期转发，接下来对LifecycleRegistry源码进行解析： 添加观察者：添加观察者通过addObserver方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic void addObserver(@NonNull LifecycleObserver observer) &#123; State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; //把传入的observer封装成一个ObserverWithState对象 ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); //如果之前已经有这个observer，就直接返回 if (previous != null) &#123; return; &#125; //获取到LifecycleOwner LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; /**是否是可重入的，什么意思呢？这里有两个判断条件： 1、mAddingObserverCounter ！=0，什么时候会满足这个条件呢，就是在下面的statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));方法里面可能又会调用addObserver,这次addObserver的时候这个mAddingObserverCounter就不为0了 2、mHandlingEvent为true代表正在进行状态转移 isReentrance这个值主要是为了防止重复调用sync方法，在嵌套的情况下，保证只有最上层最后调用这个sync方法，这个下面也有注释说明 **/ boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; //计算出目标的State State targetState = calculateTargetState(observer); mAddingObserverCounter++; //如果observer目前呢的state小于要转移的targetState,那么就要进行state转移，比如目前页面的state状态为CREATED,但是oberver.mState初始化的状态是INITIALIZED,那么就要把状态转移到CREATED while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); //upEvent方法就是把state转移到下一个生命周期Event，然后再把这个Event通知给oberver进行分发，然后在这个 //statefulObserver内部会根据这个Event更新自己的mState //这里每次只能进行一个Event转移，就比如说现在页面的state状态为STARTED,那么就需要进行两次转移，也就是这个这个while循环会执行2次，相应的observer会先后收到ON_CREATE和ON_START回调 statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); //再次计算targetState,判断observer.mState是否达到了targetState,这里是一个while循环，直到达到了 //targetState才会退出 targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. //把当前页面的state状态同步给所有的oberver sync(); &#125; mAddingObserverCounter--;&#125; 可以看出addObserver主要是分为几个步骤： 1、把传入的observer封装成一个ObserverWithState对象，保存到一个map里面，key值就是这个observer。我们来看下ObserverWithState的构造方法： 12345678910111213141516static class ObserverWithState &#123; State mState; GenericLifecycleObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; mLifecycleObserver = Lifecycling.getCallback(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; &#125;&#125; 在构造方法里面会通过Lifecycling.getCallback(observer)方法把observer转换为一个GenericLifecycleObserver对象。刚刚上面说了类可以通过向其方法添加注解来监控组件的生命周期状态，这个Lifecycling.getCallback方法里面就是会去读取每个LifecycleObserver对象方法上面的注解，然后转换成对应的GenericLifecycleObserver： 123456789101112131415161718192021222324252627static GenericLifecycleObserver getCallback(Object object) &#123; if (object instanceof FullLifecycleObserver) &#123; return new FullLifecycleObserverAdapter((FullLifecycleObserver) object); &#125; if (object instanceof GenericLifecycleObserver) &#123; return (GenericLifecycleObserver) object; &#125; //根据注解生成对应的GenericLifecycleObserver ，一般不推荐这种方式 final Class&lt;?&gt; klass = object.getClass(); int type = getObserverConstructorType(klass); if (type == GENERATED_CALLBACK) &#123; List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors = sClassToAdapters.get(klass); if (constructors.size() == 1) &#123; GeneratedAdapter generatedAdapter = createGeneratedAdapter( constructors.get(0), object); return new SingleGeneratedAdapterObserver(generatedAdapter); &#125; GeneratedAdapter[] adapters = new GeneratedAdapter[constructors.size()]; for (int i = 0; i &lt; constructors.size(); i++) &#123; adapters[i] = createGeneratedAdapter(constructors.get(i), object); &#125; return new CompositeGeneratedAdaptersObserver(adapters); &#125; return new ReflectiveGenericLifecycleObserver(object);&#125; 从上面代码也可以看出我们可以让我们自定义的LifecycleObserver直接实现FullLifecycleObserver或者GenericLifecycleObserver接口，如果没有实现这两个接口，继续往下走的话就是注解相关处理，然后包装生成对应的GenericLifecycleObserver子类，一般情况下不推荐这种方式，因为涉及到runtime反射，会有一定的性能开销。最佳操作是如果工程支持java8的话，可以实现DefaultLifecycleObserver接口,子类根据自身需求实现对应的方法（不得不说default真是个好东西啊～～）： 1234567891011121314151617181920212223242526public interface DefaultLifecycleObserver extends FullLifecycleObserver &#123; @Override default void onCreate(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onStart(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onResume(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onPause(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onStop(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onDestroy(@NonNull LifecycleOwner owner) &#123; &#125;&#125; ObserverWithState对象封装好了之后，继续往下走： 2、根据当前页面state对observer进行state转移，这里可能会涉及到多次转移 3、把当前页面的state状态同步给所有的oberver 移除观察者移除观察者通过removeObserver方法： 123456789101112131415public void removeObserver(@NonNull LifecycleObserver observer) &#123; // we consciously decided not to send destruction events here in opposition to addObserver. // Our reasons for that: // 1. These events haven't yet happened at all. In contrast to events in addObservers, that // actually occurred but earlier. // 2. There are cases when removeObserver happens as a consequence of some kind of fatal // event. If removeObserver method sends destruction events, then a clean up routine becomes // more cumbersome. More specific example of that is: your LifecycleObserver listens for // a web connection, in the usual routine in OnStop method you report to a server that a // session has just ended and you close the connection. Now let's assume now that you // lost an internet and as a result you removed this observer. If you get destruction // events in removeObserver, you should have a special case in your onStop method that // checks if your web connection died and you shouldn't try to report anything to a server. mObserverMap.remove(observer);&#125; 可以看出removeObserver只做了一件事，就是把observer从map里面移除。 生命周期转发当生命周期发生改变的时候，会调用handleLifecycleEvent方法进行分发，里面调用moveToState方法进行状态转移，同步给所有的observer 12345678910111213141516171819public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next);&#125;private void moveToState(State next) &#123; if (mState == next) &#123; return; &#125; mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) &#123; mNewEventOccurred = true; // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; sync(); mHandlingEvent = false;&#125; 通过以上这3个方法就完成了生命周期-&gt;oberver的转发，实现了生命周期的自动监听实现。 自定义LifecycleOwner如果您有一个自定义类并希望使其成为 LifecycleOwner，您可以使用 LifecycleRegistry 类，但需要将事件转发到该类，如以下代码示例中所示： 1234567891011121314151617181920212223public class MyActivity extends Activity implements LifecycleOwner &#123; private LifecycleRegistry lifecycleRegistry; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); lifecycleRegistry = new LifecycleRegistry(this); lifecycleRegistry.markState(Lifecycle.State.CREATED); &#125; @Override public void onStart() &#123; super.onStart(); lifecycleRegistry.markState(Lifecycle.State.STARTED); &#125; @NonNull @Override public Lifecycle getLifecycle() &#123; return lifecycleRegistry; &#125;&#125; 总结Lifecycle组件实际上就是对activity或者fragment的生命周期进行自动化监听，然后业务方根据自己的需求可以往Lifecycle组件里面在add或者remove监听，就是一种典型的观察者模式，去掉了以往需要直接在acivity和fragment的生命周期方法中显示调用组件对应方法的过程，让组件代码更有条理，也避免了activity和fragment的代码膨胀，提升代码的可维护性。","categories":[{"name":"Android架构学习","slug":"Android架构学习","permalink":"http://easyliu.com/categories/Android架构学习/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android Jetpack简介","slug":"android_jetpack/jetpack_intro","date":"2020-10-31T07:31:26.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/10/31/android_jetpack/jetpack_intro/","link":"","permalink":"http://easyliu.com/2020/10/31/android_jetpack/jetpack_intro/","excerpt":"","text":"Jetpack简介Jetpack 是一个由多个库组成的套件，可帮助开发者遵循最佳做法，减少样板代码并编写可在各种 Android 版本和设备中一致运行的代码，让开发者精力集中编写重要的代码。 Jetpack 包含与平台 API 解除捆绑的 androidx.* 软件包库。这意味着，它可以提供向后兼容性，且比 Android 平台的更新频率更高，以此确保您始终可以获取最新且最好的 Jetpack 组件版本。 优势加速开发组件可以单独采用（不过这些组件是为协同工作而构建的），同时利用 Kotlin 语言功能帮助您提高工作效率。 消除样板代码Android Jetpack 可管理繁琐的 Activity（如后台任务、导航和生命周期管理），以便您可以专注于如何让您的应用出类拔萃。 构建高质量的强大应用Android Jetpack 组件围绕现代化设计实践构建而成，具有向后兼容性，可以减少崩溃和内存泄漏。 以下是jetpack包含的内容： jetpack文档 jetpack视频介绍 Jetpack架构组件设计思路应用架构指南 基于移动应用用户体验在大多数情况下，桌面应用会在桌面或程序启动器中有一个入口点，且作为一个单体式进程运行。Android 应用则不然，它们的结构要复杂得多。典型的 Android 应用包含多个应用组件，包括 Activity、Fragment、Service、内容提供程序和广播接收器。 您需要在应用清单中声明其中的大多数应用组件。Android 操作系统随后会使用此文件来决定如何将您的应用集成到设备的整体用户体验中。鉴于正确编写的 Android 应用包含多个组件，并且用户经常会在短时间内与多个应用进行互动，因此应用需要适应不同类型的用户驱动型工作流和任务。 例如，思考一下当您在自己喜欢的社交网络应用中分享照片时会发生什么： 该应用将触发相机 intent。Android 操作系统随后会启动相机应用来处理请求。此时，用户已离开社交网络应用，但他们的体验仍然是无缝的。 相机应用可能会触发其他 intent（如启动文件选择器），而这可能会再启动一个应用。 最后，用户返回社交网络应用并分享照片。 在此过程中，用户随时可能会被电话或通知打断。处理之后，用户希望能够返回并继续分享照片。这种应用跳跃行为在移动设备上很常见，因此您的应用必须正确处理这些流程。 请注意，移动设备的资源也很有限，因此操作系统可能会随时终止某些应用进程，以便为新的进程腾出空间。 鉴于这种环境条件，您的应用组件可以不按顺序地单独启动，并且操作系统或用户可以随时销毁它们。由于这些事件不受您的控制，因此您不应在应用组件中存储任何应用数据或状态，并且应用组件不应相互依赖。 常见的架构原则如果您不应使用应用组件存储应用数据和状态，那么您应该如何设计应用呢？ 关注分离点要遵循的最重要的原则是分离关注点。一种常见的错误是在一个 Activity 或 Fragment 中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。您应使这些类尽可能保持精简，这样可以避免许多与生命周期相关的问题。 请注意，您并非拥有 Activity 和 Fragment 的实现；它们只是表示 Android 操作系统与应用之间关系的粘合类。操作系统可能会根据用户互动或因内存不足等系统条件随时销毁它们。为了提供令人满意的用户体验和更易于管理的应用维护体验，您最好尽量减少对它们的依赖。 通过模型驱动界面另一个重要原则是您应该通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。它们独立于应用中的 View 对象和应用组件，因此不受应用的生命周期以及相关的关注点的影响。 持久性是理想之选，原因如下： 如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据。 当网络连接不稳定或不可用时，应用会继续工作。 应用所基于的模型类应明确定义数据管理职责，这样将使应用更可测试且更一致。 基于以上讨论就演变出来了如何使用Jetpack架构组件构建应用，如下所示： 请注意，每个组件仅依赖于其下一级的组件。例如，Activity 和 Fragment 仅依赖于视图模型。存储区是唯一依赖于其他多个类的类；在本例中，存储区依赖于持久性数据模型和远程后端数据源。 这种设计打造了一致且愉快的用户体验。无论用户上次使用应用是在几分钟前还是几天之前，现在回到应用时都会立即看到应用在本地保留的用户信息。如果此数据已过时，则应用的存储区模块将开始在后台更新数据。 Jetpack架构组件介绍Jetpack架构组件 Android 架构组件是一组库，可帮助您设计稳健、可测试且易维护的应用。您可以从管理界面组件生命周期和处理数据持久性的类着手。 通过应用架构指南，学习有关汇编稳健应用的基础知识。 管理应用的生命周期。新的生命周期感知型组件可帮助您管理 Activity 和 Fragment 的生命周期。在配置更改后继续有效、避免内存泄漏，以及轻松加载数据到界面中。 使用 LiveData 构建数据对象，在基础数据库改变时通知视图。 ViewModel 存储界面相关的数据，这些数据不会在应用轮转时销毁。 Room 是一个 SQLite 对象映射库。它可用来避免样板代码，并轻松地将 SQLite 表数据转换为 Java 对象。Room 提供 SQLite 语句的编译时检查，并且可以返回 RxJava、Flowable 和 LiveData 可观察对象。 以上就是对Jetpack组件的介绍，接下来会对Jetpack里面的架构组件进行剖析讲解。","categories":[{"name":"Android架构学习","slug":"Android架构学习","permalink":"http://easyliu.com/categories/Android架构学习/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"android组件化","slug":"android_architecture/component","date":"2020-09-19T16:21:14.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/09/20/android_architecture/component/","link":"","permalink":"http://easyliu.com/2020/09/20/android_architecture/component/","excerpt":"","text":"学习资料Android彻底组件化demo发布 知乎 Android 客户端组件化实践 微信Android模块化架构重构实践 中心思想1、代码解耦。如何将一个庞大的工程拆分成有机的整体？2、组件单独运行。每个组件都是一个完整的整体，如何让其单独运行和调试呢？3、数据传递。因为每个组件都会给其他组件提供的服务，那么主项目（Host）与组件、组件与组件之间如何传递数据？4、UI跳转。UI跳转可以认为是一种特殊的数据传递，在实现思路上有啥不同？5、组件的生命周期。我们的目标是可以做到对组件可以按需、动态的使用，因此就会涉及到组件加载、卸载和降维的生命周期。6、集成调试。在开发阶段如何做到按需的编译组件？一次调试中可能只有一两个组件参与集成，这样编译的时间就会大大降低，提高开发效率。7、代码隔离。组件之间的交互如果还是直接引用的话，那么组件之间根本没有做到解耦，如何从根本上避免组件之间的直接引用呢？也就是如何从根本上杜绝耦合的产生呢？只有做到这一点才是彻底的组件化。","categories":[{"name":"Android架构学习","slug":"Android架构学习","permalink":"http://easyliu.com/categories/Android架构学习/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"学习路线","slug":"android/StudyPlan","date":"2020-09-18T03:38:59.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/09/18/android/StudyPlan/","link":"","permalink":"http://easyliu.com/2020/09/18/android/StudyPlan/","excerpt":"","text":"学习路线图","categories":[{"name":"学习计划","slug":"学习计划","permalink":"http://easyliu.com/categories/学习计划/"}],"tags":[{"name":"学习计划","slug":"学习计划","permalink":"http://easyliu.com/tags/学习计划/"}]},{"title":"4、linkedList","slug":"algorithm/linkedList","date":"2020-07-12T06:49:39.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/07/12/algorithm/linkedList/","link":"","permalink":"http://easyliu.com/2020/07/12/algorithm/linkedList/","excerpt":"","text":"链表结构体定义123456789101112131415161718192021222324252627public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass()) &#123; return false; &#125; ListNode listNode = (ListNode) o; boolean valueEqual = val == listNode.val; boolean nextEqual = (next == null &amp;&amp; listNode.next == null) || (next != null &amp;&amp; next.equals(listNode.next)); return valueEqual &amp;&amp; nextEqual; &#125; @Override public int hashCode() &#123; return Objects.hash(val, next); &#125;&#125; 链表相关操作创建链表123456789101112131415161718192021/** * 创建链表 */public static ListNode createList(int[] arrays) &#123; if (arrays == null || arrays.length &lt;= 0) &#123; return null; &#125; ListNode head = null; ListNode cur = null; for (int val : arrays) &#123; ListNode newNode = new ListNode(val); if (head == null) &#123; head = newNode; cur = head; &#125; else &#123; cur.next = newNode; cur = cur.next; &#125; &#125; return head;&#125; 找到链表的最后一个节点12345678910111213/** * 找到最后一个节点 */public static ListNode findLastNode(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode lastNode = head; while (lastNode.next != null) &#123; lastNode = lastNode.next; &#125; return lastNode;&#125; 删除一个节点12345678910111213141516171819202122232425/** * 删除一个节点 */public static ListNode deleteNode(ListNode head, ListNode toDelete) &#123; if (toDelete == null || head == null) &#123; return null; &#125; ListNode tmp; if (head.val == toDelete.val) &#123; tmp = head; head = head.next; tmp.next = null; return head; &#125; ListNode cur = head; while (cur != null &amp;&amp; cur.next != null) &#123; if (cur.next.val == toDelete.val) &#123; tmp = cur.next; cur.next = cur.next.next; tmp.next = null; &#125; cur = cur.next; &#125; return head;&#125; 插入链表123456789101112131415161718192021222324252627/** * 插入一个节点或者链表 */public static ListNode insertNode(ListNode head, ListNode toInsert, int pos) &#123; if (pos &lt; 0 || head == null || toInsert == null) &#123; return head; &#125; int count = 0; ListNode curNode = head; if (pos &gt; 0) &#123; while (curNode.next != null) &#123; curNode = curNode.next; count++; if (count == pos) &#123; break; &#125; &#125; &#125; if (count == pos) &#123; ListNode tmp = curNode.next; curNode.next = toInsert; //找到insertNode的最后一个节点指向tmp ListNode lastNodeOfInsertNode = findLastNode(toInsert); lastNodeOfInsertNode.next = tmp; &#125; return head;&#125; 反转链表使用stack实现1234567891011121314151617181920212223/** * 反转链表，使用stack实现 */public static ListNode reverseListWithStack(ListNode head) &#123; if (head == null) &#123; return null; &#125; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); stack.push(head); while (head.next != null) &#123; stack.push(head.next); head.next = head.next.next; &#125; ListNode newHead = stack.pop(); ListNode pNode = newHead; while (!stack.isEmpty()) &#123; ListNode curNode = stack.pop(); pNode.next = curNode; pNode = curNode; &#125; pNode.next = null; return newHead;&#125; 使用双向指针实现1234567891011121314/** * 反转链表，使用双指针实现 */public static ListNode reverseListWithDoublePointer(ListNode head) &#123; ListNode tmp; ListNode pre = null; while (head != null) &#123; tmp = head.next; head.next = pre; pre = head; head = tmp; &#125; return pre;&#125; 单元测试删除节点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.easyliu.test.linklist;import org.junit.Assert;import org.junit.Test;public class DeleteNodeTest &#123; /** * 自测用例： * 1、head为null * 2、要删除的节点为null * 3、删除头部的节点 * 4、删除尾部的节点 * 5、删除中间节点 * 6、有多个val一样的节点，删除第一个相等的节点 */ @Test public void testNullHead() &#123; //arrange //act ListNode result = ListOperate.deleteNode(null, null); //verify Assert.assertNull(result); &#125; @Test public void testNulToDeleteNode() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2&#125;); //act ListNode result = ListOperate.deleteNode(listNode, null); //verify Assert.assertNull(result); &#125; @Test public void testDeleteHeadNode() &#123; //arrange ListNode head = ListOperate.createList(new int[]&#123;1, 2&#125;); ListNode toDeleteNode = ListOperate.createList(new int[]&#123;1&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;2&#125;); //act ListNode result = ListOperate.deleteNode(head, toDeleteNode); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testDeleteTailNode() &#123; //arrange ListNode head = ListOperate.createList(new int[]&#123;1, 2&#125;); ListNode toDeleteNode = ListOperate.createList(new int[]&#123;2&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1&#125;); //act ListNode result = ListOperate.deleteNode(head, toDeleteNode); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testDeleteMiddleNode() &#123; //arrange ListNode head = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); ListNode toDeleteNode = ListOperate.createList(new int[]&#123;2&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 3&#125;); //act ListNode result = ListOperate.deleteNode(head, toDeleteNode); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testDeleteRepeatNode() &#123; //arrange ListNode head = ListOperate.createList(new int[]&#123;1, 2, 2, 3&#125;); ListNode toDeleteNode = ListOperate.createList(new int[]&#123;2&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); //act ListNode result = ListOperate.deleteNode(head, toDeleteNode); //verify Assert.assertEquals(expectList, result); &#125;&#125; 插入节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.easyliu.test.linklist;import org.junit.Assert;import org.junit.Test;public class InsertNodeTest &#123; /** * 自测用例 * 1、pos小于0 * 2、head为null * 3、toInsertNode为null * 4、pos=0 * 5、pos为size-1 * 6、pos&gt;0&amp;&amp;pos&lt;size-1 * 7、toInsert有多个节点 */ @Test public void testNullHead() &#123; //arrange //act ListNode result = ListOperate.insertNode(null, null, 0); //verify Assert.assertNull(result); &#125; @Test public void testNegativePos() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); //act ListNode result = ListOperate.insertNode(listNode, null, -1); //verify Assert.assertEquals(listNode, result); &#125; @Test public void testNullInsertNode() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); //act ListNode result = ListOperate.insertNode(listNode, null, 0); //verify Assert.assertEquals(listNode, result); &#125; @Test public void testZeroPos() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); ListNode insertNode = ListOperate.createList(new int[]&#123;1&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 1, 2, 3&#125;); //act ListNode result = ListOperate.insertNode(listNode, insertNode, 0); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testMaxPos() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); ListNode insertNode = ListOperate.createList(new int[]&#123;1&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 2, 3, 1&#125;); //act ListNode result = ListOperate.insertNode(listNode, insertNode, 2); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testMiddlePos() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); ListNode insertNode = ListOperate.createList(new int[]&#123;1&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 2, 1, 3&#125;); //act ListNode result = ListOperate.insertNode(listNode, insertNode, 1); //verify Assert.assertEquals(expectList, result); &#125; @Test public void testMultiNodeOfInsert() &#123; //arrange ListNode listNode = ListOperate.createList(new int[]&#123;1, 2, 3&#125;); ListNode insertNode = ListOperate.createList(new int[]&#123;5, 6, 7, 8&#125;); ListNode expectList = ListOperate.createList(new int[]&#123;1, 2, 5, 6, 7, 8, 3&#125;); //act ListNode result = ListOperate.insertNode(listNode, insertNode, 1); //verify Assert.assertEquals(expectList, result); &#125;&#125; 反转链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.easyliu.test.linklist;import org.junit.Assert;import org.junit.Test;public class ReverseListTest &#123; @Test public void testNullInput() &#123; //arrange ListNode head = null; //act ListNode result = ListOperate.reverseListWithStack(head); ListNode doubleResult = ListOperate.reverseListWithDoublePointer(head); //verify Assert.assertNull(result); Assert.assertNull(doubleResult); &#125; @Test public void testSingleNodeNormal() &#123; //arrange ListNode listOne = ListOperate.createList(new int[]&#123;1&#125;); ListNode listTwo = ListOperate.createList(new int[]&#123;1&#125;); //act ListNode result = ListOperate.reverseListWithStack(listOne); ListNode doubleResult = ListOperate.reverseListWithDoublePointer(listTwo); //verify ListNode expect = ListOperate.createList(new int[]&#123;1&#125;); Assert.assertEquals(expect, result); Assert.assertEquals(expect, doubleResult); &#125; @Test public void testNormal() &#123; //arrange ListNode listOne = ListOperate.createList(new int[]&#123;1, 2, 3, 4, 5&#125;); ListNode listTwo = ListOperate.createList(new int[]&#123;1, 2, 3, 4, 5&#125;); //act ListNode result = ListOperate.reverseListWithStack(listOne); ListNode doubleResult = ListOperate.reverseListWithDoublePointer(listTwo); //verify ListNode expect = ListOperate.createList(new int[]&#123;5, 4, 3, 2, 1&#125;); Assert.assertEquals(expect, result); Assert.assertEquals(expect, doubleResult); &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://easyliu.com/categories/刷题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"3、SecondArrayFind","slug":"algorithm/SecondArrayFind","date":"2020-06-18T03:40:08.000Z","updated":"2021-02-18T11:58:18.068Z","comments":true,"path":"2020/06/18/algorithm/SecondArrayFind/","link":"","permalink":"http://easyliu.com/2020/06/18/algorithm/SecondArrayFind/","excerpt":"","text":"题目在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 输入int[][] inputArray = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };int target = 6; 输出true 实现1234567891011121314151617181920212223242526public class SecondArrayFind &#123; public static boolean secondArrayFindTarget(final int[][] inputArray, final int target) &#123; if (inputArray == null) &#123; return false; &#125; if (inputArray[0] == null) &#123; return false; &#125; int rowSize = inputArray.length; int columnSize = inputArray[0].length; int row = 0; int column = columnSize - 1; while (column &gt;= 0 &amp;&amp; row &lt; rowSize) &#123; int curValue = inputArray[row][column]; if (curValue &lt; target) &#123; row++; &#125; else if (curValue &gt; target) &#123; column--; &#125; else &#123; break; &#125; &#125; return column &gt;= 0 &amp;&amp; row &lt; rowSize; &#125;&#125; 单元测试123456789101112131415161718192021public class SecondArrayFindTest &#123; @Test public void testNullInput() &#123; Assert.assertFalse(SecondArrayFind.secondArrayFindTarget(null, 100)); &#125; @Test public void testNormalFound() &#123; int[][] inputArray = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; int target = 6; Assert.assertTrue(SecondArrayFind.secondArrayFindTarget(inputArray, target)); &#125; @Test public void testNormalNotFound() &#123; int[][] inputArray = &#123;&#123;1, 2, 3&#125;, &#123;6, 7, 8&#125;, &#123;7, 8, 9&#125;&#125;; int target = 5; Assert.assertFalse(SecondArrayFind.secondArrayFindTarget(inputArray, target)); &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://easyliu.com/categories/刷题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"2、findFirstOneTimeChar","slug":"algorithm/findFirstOneTimeChar","date":"2020-06-10T03:00:22.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/06/10/algorithm/findFirstOneTimeChar/","link":"","permalink":"http://easyliu.com/2020/06/10/algorithm/findFirstOneTimeChar/","excerpt":"","text":"题目请实现一个函数，输入一个字符串，找出第一个只出现一次的字符。 输入“asdfasdfo” 输出‘o’ 实现12345678910111213141516public static char findFirstOneTimeChar(String input) &#123; if (input == null || input.length() &lt;= 0) &#123; return 0; &#125; char[] chars = input.toCharArray(); final int[] numArray = new int[256]; for (char curChar : chars) &#123; numArray[curChar]++; &#125; for (char curChar : chars) &#123; if (numArray[curChar] == 1) &#123; return curChar; &#125; &#125; return 0;&#125; 单元测试12345678910111213141516171819202122232425public class FindFirstOneTimeCharTest &#123; @Test public void testNulInput() &#123; Assert.assertEquals(FindFirstOneTimeChar.findFirstOneTimeChar(null), 0); &#125; @Test public void testEmptyInput() &#123; Assert.assertEquals(FindFirstOneTimeChar.findFirstOneTimeChar(\"\"), 0); &#125; @Test public void testSpaceInput() &#123; Assert.assertEquals(FindFirstOneTimeChar.findFirstOneTimeChar(\" \"), ' '); &#125; @Test public void testNormalInput() &#123; String input = \"asdfasdfo\"; char expect = 'o'; char result = FindFirstOneTimeChar.findFirstOneTimeChar(input); Assert.assertEquals(expect, result); &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://easyliu.com/categories/刷题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"1、replaceSpace","slug":"algorithm/repalceSpace","date":"2020-06-07T07:37:57.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/06/07/algorithm/repalceSpace/","link":"","permalink":"http://easyliu.com/2020/06/07/algorithm/repalceSpace/","excerpt":"","text":"题目请实现一个函数，把字符串中的每个空格替换为”%20”。 输入“We are happy” 输出“We%20are%20happy” 实现1234567891011121314151617181920212223242526272829 public static String replaceSpace(String input) &#123; if (input == null) &#123; return null; &#125; if (\"\".equals(input)) &#123; return null; &#125; //计算空格的个数 char[] chars = input.toCharArray(); int numOfSpace = 0; for (char curChar : chars) &#123; if (curChar == ' ') &#123; numOfSpace++; &#125; &#125; //创建一个新的字符数组 char[] newChars = new char[chars.length + numOfSpace * 2]; int indexOfNewChar = -1; for (char curChar : chars) &#123; if (curChar != ' ') &#123; newChars[++indexOfNewChar] = curChar; &#125; else &#123; newChars[++indexOfNewChar] = '%'; newChars[++indexOfNewChar] = '2'; newChars[++indexOfNewChar] = '0'; &#125; &#125; return String.valueOf(newChars);&#125; 单元测试123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.easyliu.test.replace_space;import org.junit.Assert;import org.junit.Test;public class ReplaceSpaceTest &#123; @Test public void testNullInput() &#123; Assert.assertNull(ReplaceSpace.replaceSpace(null)); &#125; @Test public void testEmptyInput() &#123; Assert.assertNull(ReplaceSpace.replaceSpace(\"\")); &#125; @Test public void testNormalSpace() &#123; String expect = \"we%20are%20happy\"; String result = ReplaceSpace.replaceSpace(\"we are happy\"); Assert.assertEquals(expect, result); &#125; @Test public void testMultiSpace() &#123; String expect = \"we%20%20are%20%20happy\"; String result = ReplaceSpace.replaceSpace(\"we are happy\"); Assert.assertEquals(expect, result); &#125; @Test public void testSingleSpace() &#123; String expect = \"%20\"; String result = ReplaceSpace.replaceSpace(\" \"); Assert.assertEquals(expect, result); &#125; @Test public void testNoSpace() &#123; String expect = \"we\"; String result = ReplaceSpace.replaceSpace(\"we\"); Assert.assertEquals(expect, result); &#125;&#125;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://easyliu.com/categories/刷题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://easyliu.com/tags/算法/"}]},{"title":"Android studio 快捷键","slug":"android/as_shortcut","date":"2020-05-30T03:38:43.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/05/30/android/as_shortcut/","link":"","permalink":"http://easyliu.com/2020/05/30/android/as_shortcut/","excerpt":"","text":"重构快捷键shift+alt+M 选中抽取方法ctrl+alt+c 抽取常量","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://easyliu.com/categories/开发工具/"}],"tags":[{"name":"android","slug":"android","permalink":"http://easyliu.com/tags/android/"}]},{"title":"java代码规范","slug":"code/java_code_style","date":"2020-05-26T13:31:58.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/05/26/code/java_code_style/","link":"","permalink":"http://easyliu.com/2020/05/26/code/java_code_style/","excerpt":"","text":"1、减少嵌套层级，提前返回2、一行不大于100个字符3、函数参数个数不宜过多，太多了考虑抽象成类4、private成员变量以m为前缀5、常量为全大写，以下划线拼接6、静态成员变量以s为前缀7、单个函数行数不宜过多，超过20 line就考虑抽取函数8、经常进行重构9、时常考虑抽象、封装、多态10、命名规则：精简但能清楚表达语义11、写函数的时候从方便单测的角度进行考虑，进行单测覆盖","categories":[{"name":"代码规范","slug":"代码规范","permalink":"http://easyliu.com/categories/代码规范/"}],"tags":[{"name":"代码规范","slug":"代码规范","permalink":"http://easyliu.com/tags/代码规范/"}]},{"title":"xcode快捷键","slug":"ios/xcode_shortcut","date":"2020-05-17T09:34:22.000Z","updated":"2021-02-18T11:58:18.067Z","comments":true,"path":"2020/05/17/ios/xcode_shortcut/","link":"","permalink":"http://easyliu.com/2020/05/17/ios/xcode_shortcut/","excerpt":"","text":"1、cmd+shift+j 在左边文件管理区定位到当前文件 2、cmd+shift+o 快速查找某个类，对应Android studio开发的话是shift+shift 3、ctrl+cmd+往左箭头或者往右箭头 光标返回到上一个选中的位置或者下一个选中的位置","categories":[{"name":"ios开发","slug":"ios开发","permalink":"http://easyliu.com/categories/ios开发/"}],"tags":[{"name":"ios开发","slug":"ios开发","permalink":"http://easyliu.com/tags/ios开发/"}]},{"title":"PowerMockIo单元测试基础语法","slug":"unit_test/unit_test","date":"2020-05-17T09:05:17.000Z","updated":"2022-02-17T07:19:21.011Z","comments":true,"path":"2020/05/17/unit_test/unit_test/","link":"","permalink":"http://easyliu.com/2020/05/17/unit_test/unit_test/","excerpt":"","text":"1、使用verifyPrivate来验证私有方法被调用//arrangeSeeVideoBoardTopStartVM fakeVm = PowerMockito.mock(SeeVideoBoardTopStartVM.class);Whitebox.setInternalState(mTestVm, “mSeeVideoBoardTopVM”, fakeVm);//actWhitebox.invokeMethod(mTestVm, “resetPlayer”);//assertPowerMockito.verifyPrivate(mTestVm).invoke(“setPlayStatus”, IUpdatePlayStatus.BEFORE);PowerMockito.verifyPrivate(fakeVm).invoke(“onUnbindView”); 2、PowerMockIo来mock静态方法：PowerMockito.mockStatic(AdaptiveUI.class);PowerMockito.when(AdaptiveUI.getCurUISizeType(Mockito.any(Context.class))).thenReturn(UISizeType.REGULAR); 3、调用private方法boolean result = Whitebox.invokeMethod(mBasePBSectionController, MOCK_METHOD, section);Assert.assertFalse(result); 4、模拟私有方法PowerMockito.when(mockPrivateClass, “privateFunc”).thenReturn(“test”); 5、mock公有方法PowerMockito.when(mTestVm.getTextViewWidth()).thenReturn(FAKE_TEXT_WIDTH); 6、设置私有成员变量Whitebox.setInternalState(mTestVm, “mSeeVideoBoardTopVM”, fakeVm); 7、当你需要使用PowerMock强大功能（Mock静态、final、私有方法等）的时候，就需要加注解@PrepareForTest8、如果一个对象，只希望mock它的部分方法，而其他方法希望和真实对象的行为一眼，可以使用PowerMockito.spy(Class clazz)代替PowerMockito.mock(Class clazz)方法，其后的设置依旧，这时，没有通过when设置过的方法，测试调用时，行为和真实对象一样","categories":[{"name":"单元测试","slug":"单元测试","permalink":"http://easyliu.com/categories/单元测试/"}],"tags":[{"name":"单元测试","slug":"单元测试","permalink":"http://easyliu.com/tags/单元测试/"}]},{"title":"Gradle基础之Grovy语法","slug":"android/Gradle基础之Grovy语法","date":"2018-02-11T15:56:14.000Z","updated":"2018-02-11T16:37:38.000Z","comments":true,"path":"2018/02/11/android/Gradle基础之Grovy语法/","link":"","permalink":"http://easyliu.com/2018/02/11/android/Gradle基础之Grovy语法/","excerpt":"","text":"Gradle基础之Groovy语法在使用Android Studio开发app的过程中，都会接触到Gradle配置，而Gradle的配置是基于Grovvy语法的。因此，要想熟练的使用Gradle进行配置，就必须熟悉Groovy语法，下面开始讲解下Groovy的基本语法。 Groovy可以看作是java的加强版，扩展了java的语法，拥有自己的一些特性。 Groovy语法官方文档 注释单行注释单行注释如下所示，跟java一样： 12// a standalone single line commentprintln \"hello\" // a comment till the end of the line 多行注释多行注释如下所示，跟java一样： 12345/* a standalone multiline comment spanning two lines */println \"hello\" /* a multiline comment starting at the end of a statement */println 1 /* one */ + 2 /* two */ GroovyDoc 注释GroovyDoc跟javaDoc语法也是一样的，如下所示： 1234567891011121314151617/** * A Class description */class Person &#123; /** the name of the person */ String name /** * Creates a greeting method for a certain person. * * @param otherPerson the person to greet * @return a greeting message */ String greet(String otherPerson) &#123; \"Hello $&#123;otherPerson&#125;\" &#125;&#125; Shebang line除了单行注释，还有一种特殊的单行注释，如下所示，叫做Shebang line（各位可以自行去翻译）。这行注释主要是便于unix理解，有了这行注释就可以直接在命令行运行groovy脚本文件啦。当然前提是电脑上要安装了Groovy，且要把Groovy加入path环境变量，注意这种注释中#必须是第一个字符，否则会报编译错误。 12#!/usr/bin/env groovyprintln \"Hello from the shebang line\" Groovy关键字Groovy语法的关键字如下所示： as assert break finally implements new switch trait case catch class false import null符号 switch true const continue def for in package this try default do else goto instanceof return throw while enum enum extends if interface super throws ### 标识符 #### 正常的标识符 标识符可以由字母、美元符号以及下划线开头，不能以数字开头。 字符的范围如下： * ‘a’ to ‘z’ (lowercase ascii letter) * ‘A’ to ‘Z’ (uppercase ascii letter) * ‘\\u00C0’ to ‘\\u00D6’ * ‘\\u00D8’ to ‘\\u00F6’ * ‘\\u00F8’ to ‘\\u00FF’ * ‘\\u0100’ to ‘\\uFFFE’ 如下为有效的标识符： 1234def namedef item3def with_underscoredef $dollarStart 如下的标识符就是非法的： 123def 3tierdef a+bdef a#b 所有的关键字如果跟在一个dot后面也都是合法的标识符： 12345foo.asfoo.assertfoo.breakfoo.casefoo.catch 引用标识符引用标识符出现在一个打点运算符之后，如下所示： 123456def map= [:]map.\"an identifier with a space and double quotes\" = \"ALLOWED\"map.'with-dash-signs-and-single-quotes' = \"ALLOWED\"assert map.\"an identifier with a space and double quotes\" == \"ALLOWED\"assert map.'with-dash-signs-and-single-quotes' == \"ALLOWED\" Groovy允许多种类型的字符串，后面会讲到。这些字符串都可以出现在打点运算符之后，如下所示： 123456map.'single quote'map.\"double quote\"map.'''triple single quote'''map.\"\"\"triple double quote\"\"\"map./slashy string/map.$/dollar slashy string/$ 有一种特殊的Groovy GStrings，也叫做插值字符串，如下所示： 123def firstname = \"Homer\"map.\"Simpson-$&#123;firstname&#125;\" = \"Homer Simpson\" //被插值为Simpson-Homerassert map.'Simpson-Homer' == \"Homer Simpson\" 字符串Groovy支持两种字符串，一种是java原生的java.lang.String，一种是groovy.lang.GString，叫做插值字符串。 单引号字符串单引号字符串就是java.lang.String，不支持插值，如下所示： 1'a single quoted string' 字符串连接所有的Groovy字符串均支持+操作，如下所示： 1assert 'ab' == 'a' + 'b' 三单引号字符串三单引号字符串如下所示： 1'''a triple single quoted string''' 三单引号支持多行，也是java.lang.String类型，不支持插值，如下所示： 1234567891011121314151617def aMultilineString = '''line oneline twoline three'''def startingAndEndingWithANewline = '''line oneline twoline three'''def strippedFirstNewline = '''\\line oneline twoline three'''assert !strippedFirstNewline.startsWith('\\n') 转义特殊字符可以使用反斜杠字符转义单引号字符，这样就可以避免字符串的终止： 1'an escaped single quote: \\' needs a backslash' 可以使用双重反斜杠转义反斜杠，如下所示： 1'an escaped escape character: \\\\ needs a double backslash' 如下所示为转义字符对照表： Unicode转义序列对于键盘上没有出现的字符，可以使用一个反斜杠+’u’+四个十六进制数字表示。例如欧元符号可以使用一下方式表示： 1'The Euro currency symbol: \\u20AC' 双引用字符串双引用字符串如下所示： 1\"a double quoted string\" 对于双引用字符串来说，如果其中没有插值表达式那就是java.lang.String类型，否则就是groovy.lang.GString类型。 字符串插值在Groovy所有的字符串字面量表示中，除了单引用和三引用字符串，其他的均支持插值。所谓字符串插值：就是将占位表达式的值替换到字符串中相应的位置当中，如下所示： 1234def name = 'Guillaume' // a plain stringdef greeting = \"Hello $&#123;name&#125;\" //把name插入到greeting当中assert greeting.toString() == 'Hello Guillaume' 还支持算数运算符： 12def sum = \"The sum of 2 and 3 equals $&#123;2 + 3&#125;\"assert sum.toString() == 'The sum of 2 and 3 equals 5' 在${}当中还支持表达式，如下所示： 1\"The sum of 1 and 2 is equal to $&#123;def a = 1; def b = 2; a + b&#125;\" 还支持$占位符，当使用点号表达式时： 12def person = [name: 'Guillaume', age: 36]assert \"$person.name is $person.age years old\" == 'Guillaume is 36 years old' 如下是非法的，会抛出groovy.lang.MissingPropertyException异常，因为系统会认为你在获取一个number的toString属性，从而报错。 1234def number = 3.14shouldFail(MissingPropertyException) &#123; println \"$number.toString()\"&#125; 如果你想去掉GString中的插值，只需要一个反斜杠即可： 1assert '$&#123;name&#125;' == \"\\$&#123;name&#125;\" //\"\\$&#123;name&#125;\"就和普通的'$&#123;name&#125;'相等了，因为去掉了插值 插值闭包表达式插值占位符还支持闭包表达式，如下所示： 12345def sParameterLessClosure = \"1 + 2 == $&#123;-&gt; 3&#125;\" //这个闭包表达式没有参数assert sParameterLessClosure == '1 + 2 == 3'def sOneParamClosure = \"1 + 2 == $&#123; w -&gt; w &lt;&lt; 3&#125;\" //这个闭包表达式有一个java.io.StringWriter类型的参数assert sOneParamClosure == '1 + 2 == 3' 闭包的一个最大的好处是惰性求值lazy evaluation，如下所示： 12345678910def number = 1def eagerGString = \"value == $&#123;number&#125;\"def lazyGString = \"value == $&#123; -&gt; number &#125;\"assert eagerGString == \"value == 1\"assert lazyGString == \"value == 1\"number = 2assert eagerGString == \"value == 1\" //eagerGString的值已经被固定了assert lazyGString == \"value == 2\" //lazyGString的值被重新计算 和java进行交互当一个方法需要java.lang.String参数，传入的却是一个GString类型的参数，这个参数的toString()方法就会被自动调用，看起来像我们可以直接将一个GString赋值给一个String变量一样： 1234567891011String takeString(String message) &#123; assert message instanceof String return message&#125;def message = \"The message is $&#123;'hello'&#125;\" assert message instanceof GString def result = takeString(message) assert result instanceof Stringassert result == 'The message is hello' GString和String的hashCodeGString和String的hashCode是不一样的，即便他们的最终结果是一样： 1assert \"one: $&#123;1&#125;\".hashCode() != \"one: 1\".hashCode() 因此在Map当中不能不能使用GString作为Key值，如下所示： 1234defkey= \"a\"def m = [\"$&#123;key&#125;\": \"letter $&#123;key&#125;\"] // key类型是一个GStringassert m[\"a\"] == null // 用一个普通String类型的key去取值,会找不到这个key,因此就会取不到值 三双引号字符串三双引号字符串类似于双引号字符串，但是是多行的，因此又类似于三引号字符串： 123456789101112def name = 'Groovy'def template = \"\"\" Dear Mr $&#123;name&#125;, You're the winner of the lottery! Yours sincerly, Dave\"\"\"assert template.toString().contains('Groovy') 斜线字符串除了使用引号来括住字符串，还可以使用/，斜线字符串一般用来定义正则表达式： 12def fooPattern = /.*foo.*/assert fooPattern == '.*foo.*' 只有正斜线需要用反斜线转义： 12def escapeSlash = /The character \\/ is a forward slash/assert escapeSlash == 'The character / is a forward slash' 斜线字符串是多行的： 12def escapeSlash = /The character \\/ is a forward slash/assert escapeSlash == 'The character / is a forward slash' 斜线字符串也可以被插值： 1234defcolor= 'blue'def interpolatedSlashy = /a $&#123;color&#125; car/assert interpolatedSlashy == 'a blue car' 注意：一个空的斜线字符串不能使用两个正斜线表示，因为Groovy会把其理解为注释。因此，下面的断言不会被编译，因为这个是一个非终止的语句： 1assert '' == // 美元斜线字符串这种字符串使用$/开始，使用/$结束，其中的转义字符为$： 123456789101112131415161718192021222324252627def name = \"Guillaume\"def date = \"April, 1st\"def dollarSlashy = $/ Hello $name, today we're $&#123;date&#125;. $ dollar sign $$ escaped dollar sign \\ backslash / forward slash $/ escaped forward slash $$$/ escaped opening dollar slashy $/$$ escaped closing dollar slashy/$assert [ 'Guillaume', 'April, 1st', '$ dollar sign', '$ escaped dollar sign', '\\\\ backslash', '/ forward slash', '/ escaped forward slash', '$/ escaped opening dollar slashy', '/$ escaped closing dollar slashy'].every &#123; dollarSlashy.contains(it) &#125; 字符串总结 字符Groovy当中并没有明确的字符字面量，需要明确指明： 12345678char c1 = 'A'assert c1 instanceof Characterdef c2 = 'B' as charassert c2 instanceof Characterdef c3 = (char)'C'assert c3 instanceof Character 数字Groovy支持不同类型的整型字面量和小数字面量。 整型字面量支持的整型字面量和java是一样的： byte char short int long java.lang.BigInteger 如下所示： 123456789// primitive typesbyte b = 1char c = 2short s = 3int i = 4long l = 5// infinite precisionBigInteger bi = 6 当使用def指明整数字面量时，变量的类型会根据数字的大小自动调整: 123456789101112131415161718def a = 1assert a instanceof Integer// Integer.MAX_VALUEdef b = 2147483647assert b instanceof Integer// Integer.MAX_VALUE + 1def c = 2147483648assert c instanceof Long// Long.MAX_VALUEdef d = 9223372036854775807assert d instanceof Long// Long.MAX_VALUE + 1def e = 9223372036854775808assert e instanceof BigInteger 对于负数也是如此： 123456789101112131415161718def na = -1assert na instanceof Integer// Integer.MIN_VALUEdef nb = -2147483648assert nb instanceof Integer// Integer.MIN_VALUE - 1def nc = -2147483649assert nc instanceof Long// Long.MIN_VALUEdef nd = -9223372036854775808assert nd instanceof Long// Long.MIN_VALUE - 1def ne = -9223372036854775809assert ne instanceof BigInteger 数字的非十进制表示数字可以用二进制、八进制、16进制以及小数表示。数字二进制表示如下，以ob开头： 1234567891011121314151617int xInt = 0b10101111assert xInt == 175short xShort = 0b11001001assert xShort == 201 as shortbyte xByte = 0b11assert xByte == 3 as bytelong xLong = 0b101101101101assert xLong == 2925lBigInteger xBigInteger = 0b111100100001assert xBigInteger == 3873gint xNegativeInt = -0b10101111assert xNegativeInt == -175 数字的八进制表示如下,以0开头： 1234567891011121314151617int xInt = 077assert xInt == 63short xShort = 011assert xShort == 9 as shortbyte xByte = 032assert xByte == 26 as bytelong xLong = 0246assert xLong == 166lBigInteger xBigInteger = 01111assert xBigInteger == 585gint xNegativeInt = -077assert xNegativeInt == -63 数字的16进制表示如下，以0x开头： 1234567891011121314151617181920int xInt = 0x77assert xInt == 119short xShort = 0xaaassert xShort == 170 as shortbyte xByte = 0x3aassert xByte == 58 as bytelong xLong = 0xffffassert xLong == 65535lBigInteger xBigInteger = 0xaaaaassert xBigInteger == 43690gDouble xDouble = new Double('0x1.0p0')assert xDouble == 1.0dint xNegativeInt = -0x77assert xNegativeInt == -119 小数字面量小数字面量也跟java是一样的： float double java.lang.BigDemical 如下所示： 123456// primitive typesfloat f = 1.234double d = 2.345// infinite precisionBigDecimal bd = 3.456 小数还支持科学计数法： 12345assert 1e3 == 1_000.0assert 2E4 == 20_000.0assert 3e+1 == 30.0assert 4E-2 == 0.04assert 5e-1 == 0.5 为了精确的计算小数，groovy选择java.lang.BigDecimal作为其小数类型。此外，float和double也是支持的小数类型，但是这俩类型需要一个显式类型声明、强制类型转换或后缀声明。 12def decimal = 123.456println decimal.getClass() // class java.lang.BigDecimal 字面中的下划线12345678long creditCardNumber = 1234_5678_9012_3456Llong socialSecurityNumbers = 999_99_9999Ldouble monetaryAmount = 12_345_132.12long hexBytes = 0xFF_EC_DE_5Elong hexWords = 0xFFEC_DE5Elong maxLong = 0x7fff_ffff_ffff_ffffLlong alsoMaxLong = 9_223_372_036_854_775_807Llong bytes = 0b11010010_01101001_10010100_10010010 数字类型后缀可以给一个数字加入后缀把其转换为指定类型，如下所示：Type|Suffix—|—BigInteger|G or gLong|L or lInteger|I or iBigDecimal|G or gDouble|D or dFloat|F or f 如下所示： 12345678910111213assert 42I == new Integer('42')assert 42i == new Integer('42') // lowercase i more readableassert 123L == new Long(\"123\") // uppercase L more readableassert 2147483648 == new Long('2147483648') // Long type used, value too large for an Integerassert 456G == new BigInteger('456')assert 456g == new BigInteger('456')assert 123.45 == new BigDecimal('123.45') // default BigDecimal type usedassert 1.200065D == new Double('1.200065')assert 1.234F == new Float('1.234')assert 1.23E23D == new Double('1.23E23')assert 0b1111L.class == Long // binaryassert 0xFFi.class == Integer // hexadecimalassert 034G.class == BigInteger // octal 数学运算以下是数学运算表（除法运算和指数运算例外）： 除法运算如果两个数中其中有一个是float或double类型，那么除法运算/或者/=得到的结果就是double类型，否则就是BigDemical类型。 指数运算运算表如下所示： 12345678910111213141516171819202122232425262728293031323334353637// base and exponent are ints and the result can be represented by an Integerassert 2 ** 3 instanceof Integer // 8assert 10 ** 9 instanceof Integer // 1_000_000_000// the base is a long, so fit the result in a Long// (although it could have fit in an Integer)assert 5L ** 2 instanceof Long // 25// the result can't be represented as an Integer or Long, so return a BigIntegerassert 100 ** 10 instanceof BigInteger // 10e20assert 1234 ** 123 instanceof BigInteger // 170515806212727042875...// the base is a BigDecimal and the exponent a negative int// but the result can be represented as an Integerassert 0.5 ** -2 instanceof Integer // 4// the base is an int, and the exponent a negative float// but again, the result can be represented as an Integerassert 1 ** -0.3f instanceof Integer // 1// the base is an int, and the exponent a negative int// but the result will be calculated as a Double// (both base and exponent are actually converted to doubles)assert 10 ** -1 instanceof Double // 0.1// the base is a BigDecimal, and the exponent is an int, so return a BigDecimalassert 1.2 ** 10 instanceof BigDecimal // 6.1917364224// the base is a float or double, and the exponent is an int// but the result can only be represented as a Double valueassert 3.4f ** 5 instanceof Double // 454.35430372146965assert 5.6d ** 2 instanceof Double // 31.359999999999996// the exponent is a decimal value// and the result can only be represented as a Double valueassert 7.8 ** 1.9 instanceof Double // 49.542708423868476assert 2 ** 0.1f instanceof Double // 1.0717734636432956 布尔型如下所示： 123def myBooleanVariable = trueboolean untypedBooleanVar = falseboolean Field = true true和false只是两个基础的布尔值，关于更复杂的boolean操作，参考：logical operators.special rules 列表ListGroovy列表就是java.util.List，默认的子类就是java.util.ArrayList，如下所示： 1234def numbers = [1, 2, 3] assert numbers instanceof List assert numbers.size() == 3 列表中可以支持各种类型： 1def heterogeneous = [1, \"a\", true] 还可以定义各种类型的List，默认是ArrayList: 12345678def arrayList = [1, 2, 3]assert arrayList instanceof java.util.ArrayListdef linkedList = [2, 3, 4] as LinkedList assert linkedList instanceof java.util.LinkedListLinkedList otherLinked = [3, 4, 5] assert otherLinked instanceof java.util.LinkedList 可以通过[]运算来获取列表的元素以及设置列表元素的值，下标可以是正数、负数、范围，还可以使用&lt;&lt;运算符来给list追加元素，如下所示： 1234567891011121314151617def letters = ['a', 'b', 'c', 'd']assert letters[0] == 'a' assert letters[1] == 'b'assert letters[-1] == 'd' //获取最后一个元素，-1是从数组末尾开始的第一个元素assert letters[-2] == 'c'letters[2] = 'C' //赋值 assert letters[2] == 'C'letters &lt;&lt; 'e' //在末尾追加一个元素 assert letters[ 4] == 'e'assert letters[-1] == 'e'assert letters[1, 3] == ['b', 'd'] // 一次性获取两个元素，返回一个新的List assert letters[2..4] == ['C', 'd', 'e'] //使用一个范围获取范围内的元素，返回一个新的List 还可以组成多维List： 12def multi = [[0, 1], [2, 3]] assert multi[1][0] == 2 数组数组需要显式定义数组的类型： 123456789String[] arrStr = ['Ananas', 'Banana', 'Kiwi'] assert arrStr instanceof String[] assert !(arrStr instanceof List)def numArr = [1, 2, 3] as int[] assert numArr instanceof int[] assert numArr.size() == 3 可以定义多维数组： 123456def matrix3 = new Integer[3][3] assert matrix3.size() == 3Integer[][] matrix2 matrix2 = [[1, 2], [3, 4]]assert matrix2 instanceof Integer[][] 获取数组元素的方式跟List一样： 12345String[] names = ['Cédric', 'Guillaume', 'Jochen', 'Paul']assert names[0] == 'Cédric' names[2] = 'Blackdrag' assert names[2] == 'Blackdrag' 映射表Maps如下所示： 123456789101112def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF'] assert colors['red'] == '#FF0000' assert colors.green == '#00FF00' colors['pink'] = '#FF00FF' colors.yellow = '#FFFF00' assert colors.pink == '#FF00FF'assert colors['yellow'] == '#FFFF00'assert colors instanceof java.util.LinkedHashMap //默认是LinkedHashMap类型 当获取一个map中不存在的key，会返回null: 1assert colors.unknown == null 除了使用string类型的key，还可以使用其他类型的key: 123def numbers = [1: 'one', 2: 'two']assert numbers[1] == 'one' 如果key是一个变量，如下所示： 12345def key = 'name'def person = [key: 'Guillaume'] //'Guilaume'对应的key为\"key\"，而不是变量key所关联的值 assert !person.containsKey('name') //不包含'name'这个keyassert person.containsKey('key') //包含'key'这个key 要想解决上述问题，可以如下所示： 12345def key = 'name'person = [(key): 'Guillaume'] //此时'Guilaume'对应的key就是变量key所对应的值 assert person.containsKey('name') assert !person.containsKey('key') 以上就是Groovy的基本语法，关于Groovy的语法特性，还包含一下几个方面，直接看官方文档即可，有兴趣的可以了解下。运算符 Operators程序结构 Program structureGroovy 面向对象语法 Object orientation 闭包 ClosuresGroovy 语义 Semantics","categories":[{"name":"Gradle相关","slug":"Gradle相关","permalink":"http://easyliu.com/categories/Gradle相关/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"SimpleSlidingMenu","slug":"android/SimpleSlidingMenu","date":"2017-05-14T03:26:19.000Z","updated":"2017-06-01T15:59:40.000Z","comments":true,"path":"2017/05/14/android/SimpleSlidingMenu/","link":"","permalink":"http://easyliu.com/2017/05/14/android/SimpleSlidingMenu/","excerpt":"","text":"概述一个简单的Android侧滑菜单，支持left, right,left_right三种菜单模式，支持edge,all两种滑动模式，支持设置菜单的宽度，支持滑动动画 效果如下每个Fragment里面是一个RecyclerView，解决了滑动冲突问题，包含滑动动画 使用方式12345678910111213141516171819202122232425private SlidingMenuLayout mSlideMenuLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mSlideMenuLayout = new SlidingMenuLayout(this); setContentView(mSlideMenuLayout); initSlideMenuLayout(); &#125; private void initSlideMenuLayout() &#123; getSupportFragmentManager().beginTransaction() .replace(SlidingMenuLayout.LEFT_TAG, ItemFragment.newInstance(1)) .commit(); getSupportFragmentManager().beginTransaction() .replace(SlidingMenuLayout.MIDDLE_TAG, ItemFragment.newInstance(1)) .commit(); getSupportFragmentManager().beginTransaction() .replace(SlidingMenuLayout.RIGHT_TAG, ItemFragment.newInstance(1)) .commit(); mSlideMenuLayout.setBackgroundColor(Color.parseColor(\"#4876FF\")); mSlideMenuLayout.setMenuMode(SlidingMenuLayout.MenuMode.LEFT_RIGHT); mSlideMenuLayout.setSlidingMode(SlidingMenuLayout.SlidingMode.ALL); mSlideMenuLayout.setSlideEnable(true); mSlideMenuLayout.setMenuContentWidthRation(0.75f); &#125; 把SlidingMenuLayout作为根布局 左侧，中间，以及右侧菜单布局都会有一个tag，通过给每一个布局设置一个fragment即可！ 具体参考代码中的：MainActivity.java 关于滑动动画滑动动画主要是给SlideMenuLayout设置IOnMenuOpenListener接口，在接口里面对菜单以及中间视图进行一些缩放、透明度以及平移操作，从而达到动画效果，如下所示： 12345678910111213141516171819mSlideMenuLayout.setOnMenuOpenListener(new SlidingMenuLayout.IOnMenuOpenListener() &#123; @Override public void menuOpen(View menuView, View middleView, float openPercent, boolean isLeftMenu) &#123; float menuScale = (float) (0.8 + 0.2 * openPercent);//0.8到1 float contentScale = (float) (1 - 0.2 * openPercent);//1到0.8 float translationXScale = 0; if (isLeftMenu) &#123; translationXScale = (1 - openPercent) * 0.6f;//范围是0.6到0 &#125; else &#123; translationXScale = -(1 - openPercent) * 0.6f;//范围是-0.6到0 &#125; menuView.setScaleX(menuScale); menuView.setScaleY(menuScale); menuView.setAlpha(openPercent); menuView.setTranslationX(menuView.getWidth() * translationXScale); middleView.setScaleX(contentScale); middleView.setScaleY(contentScale); &#125; &#125;); 代码地址：https://github.com/EasyLiu-Ly/SimpleSlidingMenu.git","categories":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://easyliu.com/categories/Android自定义控件/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"SlideFinishActivity","slug":"android/SlideFinishActivity","date":"2017-05-14T03:07:05.000Z","updated":"2017-06-01T15:59:44.000Z","comments":true,"path":"2017/05/14/android/SlideFinishActivity/","link":"","permalink":"http://easyliu.com/2017/05/14/android/SlideFinishActivity/","excerpt":"","text":"概述让Activity跟随者手指的滑动而滑动，当向右滑动到一定距离或者往右滑动到达一定速度就finish，类似于微信滑动finish的效果。 效果如下 支持边界滑动和全屏滑动两种模式 解决了滑动冲突问题，例如上图中Activity当中就包含了ViewPager，解决了和ViewPager的滑动冲突问题 使用方式如下 自定义的Activity继承自BaseSlideFinishActivity 自定义的Activity的主题需要包含以下两个属性12&lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@android:color/transparent&lt;/item&gt; 滑动动画在滑动的时候，可以实现滑动动画效果，如下所示，类似于酷狗播放界面滑动Finish的效果。具体实现查看SlideFinishRelativeLayout中的IOnSlideFinishChangeListener接口，在BaseSlideFinishActivity当中实现了这个接口，在这个接口里面对顶层视图进行rotation操作即可。 代码地址：https://github.com/EasyLiu-Ly/SlideFinishActivity.git","categories":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://easyliu.com/categories/Android自定义控件/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android应用层View触摸事件分发机制","slug":"android/ViewDispatchTouchEvent","date":"2017-04-24T14:39:11.000Z","updated":"2017-06-01T15:56:50.000Z","comments":true,"path":"2017/04/24/android/ViewDispatchTouchEvent/","link":"","permalink":"http://easyliu.com/2017/04/24/android/ViewDispatchTouchEvent/","excerpt":"","text":"概述前两篇博客从源码的角度对View绘制流程进行了分析，那么当用户需要跟View进行交互的时候，比如点击按钮的时候，按钮是如何得到点击事件的呢？当用户在屏幕上进行点击或触摸的时候，事件是如何传递到各个View的呢？这个就是本篇博客研究的点：View事件分发机制。只有同时掌握View事件分发机和View绘制流程，并辅以一定的练习，才能真正掌握自定义View。下面开始进入正题！注：源码基于API25。 触摸事件的来源及View事件分发入口还记得之前说过，在Activity的attach方法里面会新建一个PhoneWindow作为顶层Window，如下所示： 12345678910111213141516171819final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); .......... .......... &#125; 在上面的代码当中有一句：mWindow.setCallback(this),这句话给Window设置了一个Callback回调接口给Activity,来看一下这个回调接口： 1234567891011121314151617181920212223/** * API from a Window back to its caller. This allows the client to * intercept key dispatching, panels and menus, etc. */ public interface Callback &#123; public boolean dispatchKeyEvent(KeyEvent event); public boolean dispatchKeyShortcutEvent(KeyEvent event); /** * Called to process touch screen events. At the very least your * implementation must call * &#123;@link android.view.Window#superDispatchTouchEvent&#125; to do the * standard touch screen processing. * * @param event The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent event); ............. 可以发现这个回调接口里面有很多回调方法，前三个方法都是对事件进行分发，第三个方法dispatchTouchEvent就是触摸事件分发。当android系统发生触摸事件时，会把触摸事件发送给顶层Window（至于是怎么传递给Window的，这里暂时不深入研究，涉及到WindowManager,WindowManagerService等跨进程的调用过程，也涉及到Activity的启动过程分析）,这里是PhoneWindow,由于给PhoneWindow设置了回调接口，在Activity当中实现了这个接口，因此，我们查看Activity当中的dispatchTouchEvent方法，如下所示： 12345678910111213141516171819/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 可以看出，如果Action为ACTION_DOWN,首先会调用onUserInteraction方法，这个方法如下所示： 123456789101112131415161718192021/** * Called whenever a key, touch, or trackball event is dispatched to the * activity. Implement this method if you wish to know that the user has * interacted with the device in some way while your activity is running. * This callback and &#123;@link #onUserLeaveHint&#125; are intended to help * activities manage status bar notifications intelligently; specifically, * for helping activities determine the proper time to cancel a notfication. * * &lt;p&gt;All calls to your activity's &#123;@link #onUserLeaveHint&#125; callback will * be accompanied by calls to &#123;@link #onUserInteraction&#125;. This * ensures that your activity will be told of relevant user activity such * as pulling down the notification pane and touching an item there. * * &lt;p&gt;Note that this callback will be invoked for the touch down action * that begins a touch gesture, but may not be invoked for the touch-moved * and touch-up actions that follow. * * @see #onUserLeaveHint() */ public void onUserInteraction() &#123; &#125; 关于这个方法，注释已经说的很明白了，一般和onUserLeaveHint方法配对使用，主要是用来帮助Activity管理状态栏通知。 调用完onUserInteraction方法之后，就会调用getWindow.superDispatchTouchEvent方法，也就是调用PhoneWindow的superDispatchTouchEvent方法。如果这个方法返回true,就直接返回true,否则会调用Activity的onTouchEvent方法。 我们可以在Activity重写dispatchTouchEvent方法来对所有的触摸事件进行拦截，防止其分发至window。 当Activity的onTouchEvent被调用的时候，说明Window的superDispatchTouchEvent方法返回false,也就是没有消耗事件，事件最终交给Activity进行处理，因此我们也可以在Activity当中重写onTouchEvent方法来进行事件处理。 来看下PhoneWindow的superDispatchTouchEvent方法： 1234@Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125; 可以看出其调用的是顶层视图DecorView的superDispatchTouchEvent方法，如下所示： 123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event); &#125; 可以看出，DecorView调用了其父类的dispatchTouchEvent方法，跳进去看发现调用的是ViewGroup的dispatchTouchEvent方法。这个也可以理解，因为DecorView是继承自FrameLayout，而FrameLayout是继承自ViewGroup。 通过以上分析可以看出，View触摸事件的入口是DecorView, 也就是ViewGroup。整个事触摸件的传递过程如下：**-&gt; 顶层PhoneWindow得到触摸事件，调用其dispatchTouchEvent方法-&gt; Activity当中收到dispatchTouchEvent回调方法，调用mWindow的superDispatchTouchEvent方法-&gt; 调用PhoneWindow的superDispatchTouchEvent方法-&gt; 调用DecorView的superDispatchTouchEvent方法-&gt; 最终调用ViewGroup的dispatchTouchEvent方法-&gt; View触摸事件分发入口** ViewGroup事件分发机制既然View触摸事件的入口是ViewGroup的dispatchTouchEvent方法，说明这个方法至关重要，接下来看下这个dispatchTouchEvent方法,这个方法比较长，我会在代码中加入注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224public boolean dispatchTouchEvent(MotionEvent ev) &#123; ................ boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; //ACTION_DOWN的话就恢复初始状态，清除TouchTarget if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // 检测事件拦截 final boolean intercepted;//这个标志用于是否拦截事件，如果拦截的话，就交给自身的这个ViewGroup进行处理 //如果是ACTION_DOWN或者mFirstTouchTarget不为空（说明已经有了TouchTarget），就开始判断是否拦截事件 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //是否不允许拦截，在ViewGroup当中有一个requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法 //这个函数可以用来设置是否拦截，一般用在子View当中，通过调用父View的这个方法来阻止父View拦截事件 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; //允许拦截的话，就调用onInterceptTouchEvent方法，一般我们需要重写这个方法，来根据需求来进行事件拦截 if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; //不允许拦截 intercepted = false; &#125; &#125; else &#123; //如果没有TouchTarget且当前action不是初始的ACTION_DOWN,就拦截 //如果当前ViewGroup拦截了ACTION_DOWN,那么剩下的ACTION_UP,ACTION_MOVE事件都是交给它处理，且onInterceptTouchEvent方法 // 不会再次调用，因为此时mFirstTouchTarget==null且action!=ACTION_DOWN // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //如果事件没有取消且没有拦截事件 if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; //发现没有，这里只是对ACTION_DOWN进行处理，那么ACTION_UP和ACTION_MOVE呢？ if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. //开始遍历子View，找到能够接收事件的子View final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; //判断子view是否能接收pointer事件或者当前的触摸点在子view的边界内， //如果这两个没有一个满足，就continue，跳到循环的下一步，也就是下一个子view if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); // 如果child已经接收了触摸事件 if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); // 这个函数内部调用了child.dispatchTouchEvent方法 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // 有子View接收这个事件 // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //把child的TouchTarget加入到链表的开头且返回child的TouchTarget newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; //这里有三种情况：一种是当前ViewGroup拦截了事件，一种是没有子View，还有一种是子View的dispatchTouchEvent方法返回了false //这三种情况下就交给当前ViewGroup进行处理 // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // 我们发现前面只是对ACTION_DOWN进行了分发,当某个子当某个子View返回true时，会中止Down事件的分发， // 同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理,如下所示。 // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 以上对ViewGroup的dispatchTouchEvent方法进行了分析，总结如下： 1、每次当触摸事件为ACTION_DOWN的时候就会清除之前的状态，开始一次新的事件分发2、如果当前ViewGroup拦截了ACTION_DOWN,那么剩下的ACTION_UP,ACTION_MOVE事件都是交给它处理3、在自定义继承自ViewGroup的View的时候，通过重写onInterceptTouchEvent对事件进行拦截，事件拦截仅仅是针对于ViewGroup，对于View来说不存在事件拦截的说法4、ViewGroup当中有一个requestDisallowInterceptTouchEvent(boolean disallowIntercept)方法，可以用来设置是否拦截，一般用在子View当中，通过调用父View的这个方法来阻止父View进行事件拦截5、有三种情况，触摸事件会交给当前的ViewGroup进行处理，此时就把ViewGroup当成普通的View,走的是View事件分发逻辑，调用的是View的dispatchTouchEvent方法： 一种是当前ViewGroup拦截了事件 一种是没有子View， 还有一种是子View的dispatchTouchEvent方法返回了false 6、事件分发只是针对ACTION_DOWN进行了分发,当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理！这个就有点类似于：一旦一个活交给你干了，你就得干到底的意思！ View事件分发机制之dispatchTouchEvent方法以上讲的是ViewGroup的事件分发机制，对于View来说，触摸事件都是由父ViewGroup分发而来，调用的是View的dispatchTouchEvent方法，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; // 如果满足：mOnTouchListener!=null、View是ENABLED的、mOnTouchListener的onTouch方法返回true,那么result为true if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; //如果上面的result为true，那么就不会调用下面的onTouchEvent方法 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 可以看出： 如果View是使能的、设置了TouchListener接口、接口中的onTouch方法返回true的话，这三个条件同时满足的话就不会调用下面的onTouchEvent方法！ 比如对于一个Button, 如果它是使能的，且给它设置一个TouchListener，在onTouch方法里面返回true，那么就无法响应点击事件（这个大家可以验证一下）， 按钮的点击事件以及长按事件是在onTouchEvent方法里面响应的 当View不使能的时候，是可以继续调用onTouchEvent方法的 如果onTouchEvent返回true,那么整个dispatchTouchEvent也就返回true，代表当前View消耗了事件。 View事件分发机制之onTouchEvent方法来看下onTouchEvent方法，如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); // view不使能 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; //ACTION_UP事件，设置按下状态为false if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; //一个不使能的view,如果是可点击的依然会消耗这个事件，比如button,即使是不使能的，也会返回true消耗事件，只是不对事件作出响应而已。 //因为button默认是可点击的，除非手动设置为不可点击 // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); &#125; // 如果设置了触摸代理，调用触摸代理的onTouchEvent方法，如果返回true,就消耗事件。 // 这个触摸代理常常用在扩大View的点击区域，比如一个图标太小，就可以扩大其点击区域 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; // 如果是可点击的 if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // 如果View还没有获得焦点的话就主动获得焦点 // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; // 如果长按的动作没有发生且没有忽略下一个ACTION_UP事件 if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // 移除长按检测 // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. //这个PerformClick是一个Runnable对象 if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; //把mPerformClick给post到消息队列 if (!post(mPerformClick)) &#123; // 如果上述Runnable执行失败，就直接调用performClick方法，在这个方法里面调用 // OnClickListener回调接口 performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away // 设置为按下状态 setPressed(true, x, y); // 检测长按，如果长按下成功，会把mHasPerformedLongPress置为true，这样点击事件就得不到响应 // 也就是说长按事件会屏蔽点击事件 checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: //复位 setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false; &#125; 从以上代码可以看出： 一个不使能的view,如果是可点击的依然会消耗这个事件，比如button,即使是不使能的，也会返回true消耗事件，只是不对事件作出响应而已。因为button默认是可点击的，除非手动设置为不可点击 这要这个View是可点击的，不管是否使能，都会消耗事件 如果长按检测成功，会把mHasPerformedLongPress置为true，这样点击事件就得不到响应，也就是说长按事件会屏蔽点击事件 还有一点，像ImageView这种控件默认是不可点击的，但是如果给它设置OnClickListener或者onLongClickListener的话，就会主动把其设置为可点击 以上从源码的角度对触摸事件的来源、ViewGroup事件分发机制、View事件分发机制进行了解读。在自定义View的时候，当需要对触摸事件进行处理的时候，一般是重写onTouchEvent方法，拥有子类的View一般还需要重写onInterceptTouchEvent方法进行事件拦截，要想让这两个方法很好的配合使用，就需要熟悉并且理解触摸事件分发机制，再配合之前的View绘制流程，就能自定义出各式各样的View啦！ 感谢大家的阅读！有啥问题，欢迎指出，谢谢！","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android应用层View绘制流程之measure,layout,draw三步曲","slug":"android/ViewInvalidteProcessTwo","date":"2017-04-22T13:20:18.000Z","updated":"2017-06-01T15:57:10.000Z","comments":true,"path":"2017/04/22/android/ViewInvalidteProcessTwo/","link":"","permalink":"http://easyliu.com/2017/04/22/android/ViewInvalidteProcessTwo/","excerpt":"","text":"概述上一篇博文对DecorView和ViewRootImpl的关系进行了剖析，这篇文章主要是来剖析View绘制的三个基本流程:measure,layout,draw，只有把这三个基本流程搞清楚了，平时在自定义View的时候才会有清晰的思路！开始进入正题。 View的measure过程三个流程均是从ViewRootImpl的performTraversals方法开始的，如下所示： 123456789101112private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ...... mView.draw(canvas); ...... &#125; 首先看下getRootMeasureSpec方法,如下所示： 1234567891011121314151617181920212223242526272829303132/** * Figures out the measure spec for the root view in a window based on it's * layout params. * * @param windowSize * The available width or height of the window * * @param rootDimension * The layout params for one dimension (width or height) of the * window. * * @return The measure spec to use to measure the root view. */ private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec; &#125; 从上面的注释可以看出这个getRootMeasureSpec是为了根据根视图的LayoutParams计算根视图的MeasureSpec，这个根视图就是上篇博客讲的DecorView。 关于MeasureSpec关于MeasureSpec来做一个简单的说明：通过MeasureSpec.makeMeasureSpec来得到一个32位的整数，高两位代码测量模式mode,低30位代表测量大小size，如下所示： 12345678public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size, @MeasureSpecMode int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; 然后再通过getMode和getSize这两个方法来得到对应的测试模式mode和测量尺寸size，如下所示： 1234567891011121314151617181920212223/** * Extracts the mode from the supplied measure specification. * * @param measureSpec the measure specification to extract the mode from * @return &#123;@link android.view.View.MeasureSpec#UNSPECIFIED&#125;, * &#123;@link android.view.View.MeasureSpec#AT_MOST&#125; or * &#123;@link android.view.View.MeasureSpec#EXACTLY&#125; */ @MeasureSpecMode public static int getMode(int measureSpec) &#123; //noinspection ResourceType return (measureSpec &amp; MODE_MASK); &#125; /** * Extracts the size from the supplied measure specification. * * @param measureSpec the measure specification to extract the size from * @return the size in pixels defined in the supplied measure specification */ public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; View的measure和onMeasure方法通过getRootMeasureSpec来得到DecorView的widthMeasureSpec和heightMeasureSpec之后，就需要来设置DecorView的大小了，也就是调用： 1mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); 发现这个measure是View的方法，如下所示： 12345678910111213141516171819202122232425/** * &lt;p&gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * &lt;/p&gt; * * &lt;p&gt; * The actual measurement work of a view is performed in * &#123;@link #onMeasure(int, int)&#125;, called by this method. Therefore, only * &#123;@link #onMeasure(int, int)&#125; can and must be overridden by subclasses. * &lt;/p&gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */ public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ........... onMeasure(widthMeasureSpec, heightMeasureSpec); ........... &#125; 通过注释可以看出，这个方法是用来计算当前View应该为多大，也就是实际的宽高。widthMeasureSpec和heightMeasureSpec是由父View传入的约束信息，代表了父View给当前View的测量规格，当前View的宽高是由父View和自身一起决定的。measure方法是final的，不可重载，实际的测量过程是在onMeasure方法里面完成了，因此子类必须且只能重载onMeasure方法来实现自身的测量逻辑。 接下来看onMeasure方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * &lt;p&gt; * Measure the view and its content to determine the measured width and the * measured height. This method is invoked by &#123;@link #measure(int, int)&#125; and * should be overridden by subclasses to provide accurate and efficient * measurement of their contents. * &lt;/p&gt; * * &lt;p&gt; * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you * &lt;em&gt;must&lt;/em&gt; call &#123;@link #setMeasuredDimension(int, int)&#125; to store the * measured width and height of this view. Failure to do so will trigger an * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by * &#123;@link #measure(int, int)&#125;. Calling the superclass' * &#123;@link #onMeasure(int, int)&#125; is a valid use. * &lt;/p&gt; * * &lt;p&gt; * The base class implementation of measure defaults to the background size, * unless a larger size is allowed by the MeasureSpec. Subclasses should * override &#123;@link #onMeasure(int, int)&#125; to provide better measurements of * their content. * &lt;/p&gt; * * &lt;p&gt; * If this method is overridden, it is the subclass's responsibility to make * sure the measured height and width are at least the view's minimum height * and width (&#123;@link #getSuggestedMinimumHeight()&#125; and * &#123;@link #getSuggestedMinimumWidth()&#125;). * &lt;/p&gt; * * @param widthMeasureSpec horizontal space requirements as imposed by the parent. * The requirements are encoded with * &#123;@link android.view.View.MeasureSpec&#125;. * @param heightMeasureSpec vertical space requirements as imposed by the parent. * The requirements are encoded with * &#123;@link android.view.View.MeasureSpec&#125;. * * @see #getMeasuredWidth() * @see #getMeasuredHeight() * @see #setMeasuredDimension(int, int) * @see #getSuggestedMinimumHeight() * @see #getSuggestedMinimumWidth() * @see android.view.View.MeasureSpec#getMode(int) * @see android.view.View.MeasureSpec#getSize(int) */ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 注释已经写的非常明白了，子类必须复写onMeasure方法，且最终通过调用setMeasuredDimension方法来存储当前View测量得到的宽和高。这个宽和高是通过getDefaultSize方法得来的，如下所示： 12345678910111213141516171819202122232425/** * Utility to return a default size. Uses the supplied size if the * MeasureSpec imposed no constraints. Will get larger if allowed * by the MeasureSpec. * * @param size Default size for this view * @param measureSpec Constraints imposed by the parent * @return The size this view should be. */ public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; 可以看出，如果specMode等于AT_MOST或者EXACTLY就返回specSize，也就是父类指定的specSize，否则返回通过getSuggestedMinimumWidth和getSuggestedMinimumHeight得到的size，从名字可以看出是建议的最小宽度和高度，代码如下所示： 1234567protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125;protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125; 可以看出，建议的最小宽度和高度是由view的background以及其mMinWidth、mMinHeight共同决定的。 setMeasuredDimension方法如下所示： 12345678910111213141516171819protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; &#125; setMeasuredDimensionRaw(measuredWidth, measuredHeight);&#125;private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) &#123; mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;&#125; 可以看出这个方法就是给mMeasuredHeight和mMeasuredWidth进行赋值。进行了赋值之后调用View 的getMeasuredWidth和getMeasuredHeight方法才能得到其正确的测量宽高！ ViewGroup的measure过程上面提到View的measure方法传入的widthMeasureSpec和heightMeasureSpec是由父View传入的约束信息，那么这些信息是何时传入的呢？由于View是嵌套的，因此measure过程也是递归传递的，子View的measure是由父类调用的，然后子View根据传入的父类约束来设置自身的测量规格。 ** 继承自ViewGroup的视图均需要实现onMeasure方法，在这个方法里面对其子View进行测量，同时也对自身进行测量，比如LinearLayout的onMeasure方法如下：** 12345678@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125; &#125; 根据布局的方向分别调用measureHorizontal和measureVertical方法。 在ViewGroup中定义了measureChildren, measureChild, measureChildWithMargins方法来对子视图进行测量。measureChildren内部循环调用了measureChild。measureChild和measureChildWithMargins的区别在于measureChildWithMargins把child的margin也考虑在内。下面来对measureChildWithMargins方法来分析： 12345678910111213141516171819202122232425262728/** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding * and margins. The child must have MarginLayoutParams The heavy lifting is * done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param widthUsed Extra space that has been used up by the parent * horizontally (possibly by other children of the parent) * @param parentHeightMeasureSpec The height requirements for this view * @param heightUsed Extra space that has been used up by the parent * vertically (possibly by other children of the parent) */ protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //子视图的测量规格是由父视图的测量测量规格以及子视图的LayoutParams来共同决定的 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //调用子视图的measure方法来设置子视图的测量规格 child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 从以上代码可以看出：子视图的测量规格是由父视图的测量测量规格以及子视图的LayoutParams来共同决定的，因此关键函数是getChildMeasureSpec函数，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * Does the hard part of measureChildren: figuring out the MeasureSpec to * pass to a particular child. This method figures out the right MeasureSpec * for one dimension (height or width) of one child view. * * The goal is to combine information from our MeasureSpec with the * LayoutParams of the child to get the best possible results. For example, * if the this view knows its size (because its MeasureSpec has a mode of * EXACTLY), and the child has indicated in its LayoutParams that it wants * to be the same size as the parent, the parent should ask the child to * layout given an exact size. * * @param spec The requirements for this view * @param padding The padding of this view for the current dimension and * margins, if applicable * @param childDimension How big the child wants to be in the current * dimension * @return a MeasureSpec integer for the child */ public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec);//得到父视图的mode int specSize = MeasureSpec.getSize(spec);//得到父视图的size //得到Parent视图剩余的大小 int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; //根据Parent视图的specMode来进行分支判断 switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY://父类是精确模式 if (childDimension &gt;= 0) &#123; //子视图是精确模式，直接设置了精确的大小（在xml当中设置了layout_width=\"xxx\"或者在代码中设置了具体的数值),子视图的size就是精确值,子视图的mode就是EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; //如果子视图的layout_width或者layout_height为MATCH_PARENT,也就是为父视图的大小，那么子视图的size就是Parent视图剩余的大小，且mode与父类相同，也为EXACTLY // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; //如果子视图的layout_width或者layout_height为WRAP_CONTENT,也就是不超过父视图的大小，那么子视图的size为size，且mode为AT_MOST。 // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; //子视图是精确模式，直接设置了精确的大小（在xml当中设置了layout_width=\"xxx\"或者在代码中设置了具体的数值),子视图的size就是精确值,子视图的mode就是EXACTLY // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; //如果子视图的layout_width或者layout_height为MATCH_PARENT,也就是为父视图的大小，那么子视图的size就是Parent视图剩余的大小，且mode与父类相同，也是AT_MOST。 // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; //如果子视图的layout_width或者layout_height为WRAP_CONTENT,也就是不超过父视图的大小，那么子视图的size为size，且mode为AT_MOST。 // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; // 将resultSize和resultMode进行组装为32为整数返回 //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 可以看到，getChildMeasureSpec就是根据父视图的specSize和specMode以及child视图的LayoutParams来确定子视图的resultSize和resultMode，然后把resultSize和resultMode进行组装成32位的整数，作为child.measure的参数来对子视图进行测量。 ** 有一个需要特别注意的地方：** 当childDimension == LayoutParams.WRAP_CONTENT的时候，其specSize和specMode分别为父视图的size和MeasureSpec.AT_MOST。 再回到上面的View测量过程当中的getDefaultSize方法，如下所示。我们发现当View的specMode为AT_MOST的时候，其size默认就是parent视图的size! 因此，在我们自定义View的时候，需要考虑当specMode为AT_MOST的时候（也就是在xml布局当中设置为WRAP_CONTENT的时候）给当前View的宽高设置一个具体的值，大家可以去看看比如TextView的源代码，均对WRAP_CONTENT的情况进行了特殊的处理！ 123456789101112public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); ...... case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 以上就是View和ViewGroup的measure过程,在ViewGroup的实现视图当中递归调用子视图的的measure方法来实现整个View树的测量。在自定义View的时候，当我们需要对View的尺寸进行更改的时候，需要实现onMeasure方法，在里面根据父视图给的specSize和specMode来设置当前View的specMode和specSize,需要注意的是当父视图给的specMode==AT_MOST的时候，需要给当前View的宽高设置一个具体的值。 View的layout过程讲完了View的measure过程，接下来就是layout过程。那么这个layout过程是干什么的呢？在measure过程当中设置了view的宽高，那么设置了宽高之后，具体view是显示在屏幕的哪个位置呢？这个就是layout过程干的事。 layout跟measure一样，也是递归结构，来看下View的layout方法： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Assign a size and position to a view and all of its * descendants * * &lt;p&gt;This is the second phase of the layout mechanism. * (The first is measuring). In this phase, each parent calls * layout on all of its children to position them. * This is typically done using the child measurements * that were stored in the measure pass().&lt;/p&gt; * * &lt;p&gt;Derived classes should not override this method. * Derived classes with children should override * onLayout. In that method, they should * call layout on each of their children.&lt;/p&gt; * * @param l Left position, relative to parent * @param t Top position, relative to parent * @param r Right position, relative to parent * @param b Bottom position, relative to parent */ @SuppressWarnings(&#123;\"unchecked\"&#125;) public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //setFrame方法把参数分别赋值给mLeft、mTop、mRight和mBottom这几个变量 //判断布局是否发生改变 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); ........ &#125; ...... &#125; 在layout方法里面首先通过setFrame来设置自身的位置，然后调用了onLayout方法，是不是跟measure方法里面调用onMeasure方法类似！来看下onLayout方法： 123456789101112131415/** * Called from layout when this view should * assign a size and position to each of its children. * * Derived classes with children should override * this method and call layout on each of * their children. * @param changed This is a new size or position for this view * @param left Left position, relative to parent * @param top Top position, relative to parent * @param right Right position, relative to parent * @param bottom Bottom position, relative to parent */ protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; &#125; 发现onLayout是一个空方法，通过注释可以看出：具有子视图的子类需要重写这个onLayout方法并且调用其每一个子视图的layout方法。这就完全明白了：也就是说直接或者间接继承自ViewGroup的视图需要重写onLayout方法，然后调用其每个子视图的layout方法来设置子视图的位置！我们可以查看LinearLayout，其肯定是实现了onLayout方法，在这个方法里面来一一设置子视图的位置！LinearLayout的onLayout方法如下所示： 12345678@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125; &#125; 来看下layoutVertical方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Position the children during a layout pass if the orientation of this * LinearLayout is set to &#123;@link #VERTICAL&#125;. * * @see #getOrientation() * @see #setOrientation(int) * @see #onLayout(boolean, int, int, int, int) * @param left * @param top * @param right * @param bottom */ void layoutVertical(int left, int top, int right, int bottom) &#123; final int paddingLeft = mPaddingLeft; int childTop; int childLeft; // Where right end of child should go final int width = right - left; int childRight = width - mPaddingRight; //child可以使用的空间 // Space available for child int childSpace = width - paddingLeft - mPaddingRight; //得到 child的个数 final int count = getVirtualChildCount(); final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK; final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK; //根据majorGravity计算childTop的位置 switch (majorGravity) &#123; case Gravity.BOTTOM: // mTotalLength contains the padding already childTop = mPaddingTop + bottom - top - mTotalLength; break; // mTotalLength contains the padding already case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; &#125; // 开始进行遍历child视图 for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123;//child不为GONE,因为GONE是不占空间的 final int childWidth = child.getMeasuredWidth();// 得到onMeasure之后的测量宽度 final int childHeight = child.getMeasuredHeight();// 得到onMeasure之后的测量高度 final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); // 根据absoluteGravity计算childLeft的值 switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; &#125; if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; //通过setChildFrame函数来设置child的位置， setChildFrame函数如下所示 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125; &#125; private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height); &#125; 上面这个方法还是比较易懂的，主要就是调用child的layout方法来设置child的位置，当我们给一个View设置好位置之后，其内部的四个变量mLeft、mTop、mRight和mBottom也就确定了，不过要注意这些值都是相对父视图而言的，而不是相对整个屏幕而言的。这个四个变量是通过以下方式获取的。 1234567891011121314151617181920212223public final int getWidth() &#123; return mRight - mLeft; &#125; public final int getHeight() &#123; return mBottom - mTop; &#125; public final int getLeft() &#123; return mLeft; &#125; public final int getRight() &#123; return mRight; &#125; public final int getTop() &#123; return mTop; &#125; public final int getBottom() &#123; return mBottom; &#125; 在View当中还有下面两个函数，这也解释了为什么有时候getWidth()和getMeasuredWidth()以及getHeight()和getMeasuredHeight()会得到不同的值的原因。 1234567public final int getMeasuredWidth() &#123; return mMeasuredWidth &amp; MEASURED_SIZE_MASK; &#125; public final int getMeasuredHeight() &#123; return mMeasuredHeight &amp; MEASURED_SIZE_MASK; &#125; 以上就是View的layout过程，layout相对measure过程来说还是算比较简单的。 ** 总结起来就是：直接或者间接继承自ViewGroup的视图需要重写onLayout方法，然后调用其每个子视图的layout方法来设置子视图的位置。** View的draw过程讲完了View的layout流程，接下来就是draw流程，draw负责对view进行绘制。在ViewRootImpl的drawSoftware方法当中： 123456789101112131415161718192021/** * @return true if drawing was successful, false if an error occurred */ private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; final int left = dirty.left; final int top = dirty.top; final int right = dirty.right; final int bottom = dirty.bottom; canvas = mSurface.lockCanvas(dirty); ................ mView.draw(canvas); ......... return true; &#125; 在上述方法当中调用了mView的draw方法，来看View的draw方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * &#123;@link #onDraw(android.graphics.Canvas)&#125; instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered. */ @CallSuper public void draw(Canvas canvas) &#123; ............... /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; ........ // skip step 2 &amp; 5 if possible (common case) ....... // Step 2, save the canvas' layers if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; ........ // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); &#125; ............... // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); &#125; 通过注释可以看出整个绘制过程分为6部分，在大多数情况下第2步和第5步可以跳过，在自定义View的时候需要实现onDraw方法而不是实现draw方法。接下来对剩下的四步进行分析： 第一步：绘制背景 通过调用drawBackground方法实现123456789101112131415161718private void drawBackground(Canvas canvas) &#123; final Drawable background = mBackground; if (background == null) &#123; return; &#125; setBackgroundBounds(); ............... final int scrollX = mScrollX; final int scrollY = mScrollY; if ((scrollX | scrollY) == 0) &#123; background.draw(canvas); &#125; else &#123; canvas.translate(scrollX, scrollY); background.draw(canvas); canvas.translate(-scrollX, -scrollY); &#125;&#125; 如上所示，调用了background的draw方法，也就是Drawable的draw方法。 第三步：绘制内容 通过调用onDraw方法实现1234567/** * Implement this to do your drawing. * * @param canvas the canvas on which the background will be drawn */ protected void onDraw(Canvas canvas) &#123; &#125; 我们发现onDraw是一个空的方法，需要子类去实现，一般我们在自定义View的时候都会重写onDraw方法来进行绘制。 第四步：绘制子类 通过调用dispatchDraw实现123456789/** * Called by draw to draw the child views. This may be overridden * by derived classes to gain control just before its children are drawn * (but after its own view has been drawn). * @param canvas the canvas on which to draw the view */ protected void dispatchDraw(Canvas canvas) &#123; &#125; 发现dispatchDraw为空，根据注释：如果View包含子类就需要重写这个方法，那么说明下ViewGroup应该重写了这个方法，看下ViewGroup的dispatchDraw方法，如下所示： 123456789101112131415161718192021222324@Override protected void dispatchDraw(Canvas canvas) &#123; ............. for (int i = 0; i &lt; childrenCount; i++) &#123; while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123; final View transientChild = mTransientViews.get(transientIndex); if ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || transientChild.getAnimation() != null) &#123; more |= drawChild(canvas, transientChild, drawingTime); &#125; transientIndex++; if (transientIndex &gt;= transientCount) &#123; transientIndex = -1; &#125; &#125; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; ............. &#125; 从上述方法看出主要是遍历child,然后调用child的drawChild方法，来看下drawChild方法： 123protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 可以看出，在drawChild方法当中调用了child.draw方法来实现子视图的绘制。 第六步：绘制装饰，比如前景色，滚动条等 通过onDrawForeground方法实现1234567891011121314151617/** * Draw any foreground content for this view. * * &lt;p&gt;Foreground content may consist of scroll bars, a &#123;@link #setForeground foreground&#125; * drawable or other view-specific decorations. The foreground is drawn on top of the * primary view content.&lt;/p&gt; * * @param canvas canvas to draw into */ public void onDrawForeground(Canvas canvas) &#123; onDrawScrollIndicators(canvas); onDrawScrollBars(canvas); ........ final Drawable foreground = mForegroundInfo != null ? mForegroundInfo.mDrawable : null; ........ foreground.draw(canvas); &#125; 可以看出主要是对滚动条和前景色进行绘制。 到此，View绘制的三个基本流程：measure,layout,draw就讲完了，measure过程应该是三个流程里面最为复杂的。希望通过本次对源码的剖析，能够对View的绘制流程有一个清楚的认识，在以后自定义View的时候能够少走弯路～～ View树的重绘还记得在上一篇博客中我们讲ViewGroup#addView方法会导致View树的重新绘制，代码如下所示： 1234567891011121314public void addView(View child, int index, LayoutParams params) &#123; if (DBG) &#123; System.out.println(this + \" addView\"); &#125; if (child == null) &#123; throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\"); &#125; // addViewInner() will call child.requestLayout() when setting the new LayoutParams // therefore, we call requestLayout() on ourselves before, so that the child's request // will be blocked at our level requestLayout(); invalidate(true); addViewInner(child, index, params, false);&#125; 其实归根结底是调用了requestLayout和invalidate方法的原因，导致View进行重新绘制，下面来对这两个方法进行分析： View的requestLayout方法：requestLayout是view的方法，如下所示： 12345678@CallSuper public void requestLayout() &#123; ............ if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123; mParent.requestLayout(); &#125; ......... &#125; 核心代码是mParent.requestLayout，这个方法就会一层层的往上递归，一直到ViewRootImpl的requestLayout。ViewRootImpl的requestLayout方法在上一篇博客中已经分析过，这个方法会导致整个View树的重绘。 View的invalidate方法：12345678910111213141516171819202122public void invalidate() &#123; invalidate(true);&#125;void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);&#125;void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) &#123; ........... // Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage); &#125; ...........&#125; 我们发现最终调用了当前view父视图的invalidateChid方法，于是查看ViewGroup的invalidateChid方法： 12345678910111213141516171819202122232425262728293031/** * Don't call or override this method. It is used for the implementation of * the view hierarchy. */ @Override public final void invalidateChild(View child, final Rect dirty) &#123; ViewParent parent = this; ............. do &#123; View view = null; if (parent instanceof View) &#123; view = (View) parent; &#125; .......... parent = parent.invalidateChildInParent(location, dirty); if (view != null) &#123; // Account for transform on current parent Matrix m = view.getMatrix(); if (!m.isIdentity()) &#123; RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); m.mapRect(boundingRect); dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom)); &#125; &#125; &#125; while (parent != null); &#125; &#125; 我们发现invalidateChild方法里面有一个do-while循环，在这个循环里面循环调用invalidateChildInParent方法，到这里我们自然就可以想到最终会调用ViewRootImpl的invalidateChildInParent方法，ViewRootImpl的invalidateChildInParent方法如下所示： 1234567891011121314@Override public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; checkThread(); if (DEBUG_DRAW) Log.v(mTag, \"Invalidate child: \" + dirty); if (dirty == null) &#123; invalidate(); return null; &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123; return null; &#125; ............ return null; &#125; 可以看到在这个方法里面调用了invalidate方法，如下所示： 123456void invalidate() &#123; mDirty.set(0, 0, mWidth, mHeight); if (!mWillDrawSoon) &#123; scheduleTraversals(); &#125; &#125; 看到这里是否有一种很熟悉的赶脚（如果看了上一篇博客的话），这个scheduleTraversals方法最终会调用View的三个基本绘制流程来实现整个View树的绘制。 View的postInvalidate方法：当我们想在非ui线程当中刷新View的时候一般都是调用postInvalidate方法，View的postInvalidate方法如下所示： 123456789101112public void postInvalidate() &#123; postInvalidateDelayed(0); &#125;public void postInvalidateDelayed(long delayMilliseconds) &#123; // We try only with the AttachInfo because there's no point in invalidating // if we are not attached to our window final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds); &#125; &#125; 可以看出是调用了ViewRootImpl的dispatchInvalidateDelayed方法： 1234public void dispatchInvalidateDelayed(View view, long delayMilliseconds) &#123; Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view); mHandler.sendMessageDelayed(msg, delayMilliseconds); &#125; 这个方法就是发送一个MSG_INVALIDATE消息到消息队列当中，那肯定是在Handler的handleMessage方法里面对消息进行了处理： 123456@Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_INVALIDATE: ((View) msg.obj).invalidate(); break; 在handleMessage方法里面调用了View的invalidate方法,而关于invalidate方法，在上面进行了详细的分析。 到此为止，对View绘制的三个基本流程从源码的角度进行了详细的剖析，谢谢各位的阅读，不足之处欢迎指出。","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Android应用层View绘制流程之DecorView与ViewRootImpl","slug":"android/ViewInvalidteProcessOne","date":"2017-04-22T09:22:24.000Z","updated":"2017-06-01T15:57:00.000Z","comments":true,"path":"2017/04/22/android/ViewInvalidteProcessOne/","link":"","permalink":"http://easyliu.com/2017/04/22/android/ViewInvalidteProcessOne/","excerpt":"","text":"概述一直对Android中View的整个绘制流程不是很了解，View是怎么添加到Activity当中去的？当View中的内容发生改变的时候是怎样执行界面的刷新的？因此，今天准备从源码的角度来对View的整个绘制流程来进行分析，源码基于API25。由于篇幅限制，这篇文章只分析顶层视图DecorView的显示逻辑，具体的View树绘制三部曲:measure,layout,draw将在下篇博文进行深入剖析。 从Activity的setContentView方法说起我们都知道给Activity设置布局通常就是调用其setContentView方法，这个方法有几个重载的方法，如下所示： 1234567891011121314public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125; public void setContentView(View view) &#123; getWindow().setContentView(view); initWindowDecorActionBar(); &#125;public void setContentView(View view, ViewGroup.LayoutParams params) &#123; getWindow().setContentView(view, params); initWindowDecorActionBar();&#125; 从上面的三个方法可以看出其均调用了getWindow()的相对应的方法，我们来看getWindow()方法： 123public Window getWindow() &#123; return mWindow; &#125; 可以看出这个方法返回的是一个Window类型的变量mWindow，那么这个mWindow肯定是在Activity某个地方进行初始化,如下所示在attach方法里面进行了初始化： 12345678910111213141516171819final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window); mWindow.setWindowControllerCallback(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); .......... .......... &#125; mWindow是一个PhoneWindow类型的变量，其实我们通过查看抽象类Window最开始的简介可以知道，PhoneWindow是Window的唯一子类！ 1234567891011/** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */public abstract class Window &#123; 接下来查看PhoneWindow的setContentView方法，跟Activity对应，也有三个重载的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 @Overridepublic void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125;@Overridepublic void setContentView(View view) &#123; setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));&#125;@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; mContentParent.addView(view, params); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 对setContentView(View view,ViewGroup.LayoutParams)方法进行分析： 首先判断mContentParent是否为null，如果为null的话就执行方法installDecor，这个mContentParent是一个ViewGroup类型，这个方法如下所示： 1234567891011121314151617 private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); ........ .......&#125; generateDecor用于产生mDecor,mDecor是DecorView类型，是整个Activity的顶层视图，DecorView是FrameLayout的子类，有兴趣的可以看看DecorView源码，这里只是给个结论。然后是generateLayout方法，这个方法很长，看关键代码： 123456 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(\"Window couldn't find content container view\"); &#125;....return contentParent; 从上述代码可以看出，上面讲到的mContentParent是顶层视图mDecor中的一个子View，这个子View的id为： 1234/** * The ID that the main layout in the XML layout file should have. */ public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content; 因此，执行了installDecor方法之后就得到了mDecor和mContentParent，然后是一句很关键的代码，如下所示：1mContentParent.addView(view, params); 通过这句代码就把我们在Activity当中设置的布局视图加入了mContentParent里面。** 层次关系为：DecorView &gt; contentParent &gt; Activity中的布局。**由于mContentParent是ViewGroup类型，查看ViewGroup#addView方法，如下所示： 123456789101112131415161718192021222324252627/** * Adds a child view with the specified layout parameters. * * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; do not invoke this method from * &#123;@link #draw(android.graphics.Canvas)&#125;, &#123;@link #onDraw(android.graphics.Canvas)&#125;, * &#123;@link #dispatchDraw(android.graphics.Canvas)&#125; or any related method.&lt;/p&gt; * * @param child the child view to add * @param index the position at which to add the child or -1 to add last * @param params the layout parameters to set on the child */ public void addView(View child, int index, LayoutParams params) &#123; if (DBG) &#123; System.out.println(this + \" addView\"); &#125; if (child == null) &#123; throw new IllegalArgumentException(\"Cannot add a null child view to a ViewGroup\"); &#125; // addViewInner() will call child.requestLayout() when setting the new LayoutParams // therefore, we call requestLayout() on ourselves before, so that the child's request // will be blocked at our level requestLayout(); invalidate(true); addViewInner(child, index, params, false); &#125; 这个addView方法最后会调用requestLayout()和invalidate()方法，这两个方法会导致整个View树进行重新绘制，这样就把我们在Activity当中自定义的布局文件给显示出来了！ 整个过程总结如下：Activity.setContentView -&gt; PhoneWindow.setContentView -&gt;初始化PhoneWindow中的mDecor和mContentParent -&gt; 把Activity当中的布局视图加入mContentParent -&gt; 导致整个View树进行重新绘制，从而把布局文件显示出来！ DecorView是怎么显示出来的前面说了DecorView是整个Activity的顶层视图，那么这个DecorView是怎么显示出来了的呢？主要实现过程在ActivityThread的handleResumeActivity方法里面，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); if (!checkAndUpdateLifecycleSeq(seq, r, \"resumeActivity\")) &#123; return; &#125; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration r = performResumeActivity(token, clearHide, reason); if (r != null) &#123; final Activity a = r.activity; if (localLOGV) Slog.v( TAG, \"Resume \" + r + \" started activity: \" + a.mStartedActivity + \", hideForNow: \" + r.hideForNow + \", finished: \" + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; ................................ &#125;&#125; 如上述方法所示，首先从ActivityThread保存的mActivities列表里面得到一个ActivityClientRecord对象，这个对象保存了Activity的一些信息。 得到Activity之后调用View decor = r.window.getDecorView();方法得到顶层视图DecorView，这个视图前面说过是保存在PhoneWindow里面，也就是一个Activity对应一个 PhoneWindow，从而对应一个DecorView。 然后是调用ViewManager wm = a.getWindowManager();方法得到Activity当中的WindowManager对象，那为什么返回的是ViewManager对象呢？查看WindowManager接口，如下所示，发现WindowManager是继承自ViewManager接口的。 1public interface WindowManager extends ViewManager &#123; ViewManager接口如下所示，从注释可以看出这个接口主要是用来往Activity当中添加或者移除View。 12345678910111213141516171819/** Interface to let you add and remove child views to an Activity. To get an instance * of this class, call &#123;@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()&#125;. */public interface ViewManager&#123; /** * Assign the passed LayoutParams to the passed View and add the view to the window. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.BadTokenException&#125; for certain programming * errors, such as adding a second view to a window without removing the first view. * &lt;p&gt;Throws &#123;@link android.view.WindowManager.InvalidDisplayException&#125; if the window is on a * secondary &#123;@link Display&#125; and the specified display can't be found * (see &#123;@link android.app.Presentation&#125;). * @param view The view to be added to this window. * @param params The LayoutParams to assign to view. */ public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 得到Activity当中的WindowManager之后，调用wm.addView(decor, l);方法，就把DecorView加入了WindowManager。我们知道WindowManager只是一个接口，具体的实现类是WindowManagerImpl,看下其addView方法： 12345@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; 发现这个addView方法其实是调用了成员变量mGlobal的addVeiw方法，mGlobal是WindowManagerGlobal类型，我们来看下其addView方法，如下所示： 123456789101112131415161718192021222324252627282930public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ........................ ViewRootImpl root; View panelParentView = null; ......................... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); ........................... // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) &#123; final int index = findViewLocked(view, false); if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; &#125; throw e; &#125; &#125; 通过上述代码可以发现顶层视图DecorView最终被加入到了ViewRootImpl里面，且应该是在其setView方法里面执行了某些操作，导致DecorView被显示出来。这个方法比较长，大家可以自行查看，在里面有一句关键的代码： 1234// Schedule the first layout -before- adding to the window// manager, to make sure we do the relayout before receiving// any other events from the system.requestLayout(); requestLayout方法如下： 12345678@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; 在这个方法当中调用了scheduleTraversals方法，如下所示： 12345678910111213void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125; &#125; 在这个方法当中把mTraversalRunnable给post到了消息队列里面，来看看这个Runnable里面执行了什么操作： 1234567final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125; &#125; final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); 从上面可以看出在TraversalRunnable里面执行了doTraversal方法： 1234567891011121314151617void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(\"ViewAncestor\"); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125; &#125; 在这个方法当中又执行了performTraversals方法，这个方法最终负责整个View树的绘制流程，因此这个方法比较关键。这个方法比较长，其负责绘制的View树的核心语句如下，其中mView就是顶层视图DecorView。 123456789101112private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ...... mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); ...... mView.draw(canvas); ...... &#125; 上面对顶层视图DecorView的显示机制进行了深入剖析，通过一层层分析，最终得出ViewRootImpl负责整个View树的绘制。measure,layout,draw是View树绘制三个主要流程，只有理解了这三个基本流程的原理，在自定义View的时候才能做到游刃有余（当然还有View事件分发机制也很关键）！关于这三个流程的具体细节剖析将在下一篇博客中进行讲解。感谢大家的阅读！","categories":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://easyliu.com/categories/Android源码解析/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Hello World","slug":"hexo/hello-world","date":"2017-03-18T06:51:26.000Z","updated":"2021-02-02T03:35:02.360Z","comments":true,"path":"2017/03/18/hexo/hello-world/","link":"","permalink":"http://easyliu.com/2017/03/18/hexo/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://easyliu.com/categories/开发工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://easyliu.com/tags/hexo/"}]},{"title":"自定义圆形进度条的实现","slug":"android/CustomizeProgressBar","date":"2017-03-16T11:09:47.000Z","updated":"2017-06-01T15:59:36.000Z","comments":true,"path":"2017/03/16/android/CustomizeProgressBar/","link":"","permalink":"http://easyliu.com/2017/03/16/android/CustomizeProgressBar/","excerpt":"","text":"概述Android中自带有进度条，但是有的时候自带的进度条不能满足我们的需求，这时候就需要自定义进度条了，今天带来的就是一个自定义的圆形进度条首先来看效果，效果如下所示。 实现从上面的效果可以看出，主要有以下几个自定义属性： 背景颜色 进度扇形颜色 半径 起始角度 因此，在attrs.xml中定义如下属性： 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"SimpleRoundProgressBar\"&gt; &lt;attr format=\"color\" name=\"roundColor\"/&gt; &lt;attr format=\"color\" name=\"roundProgressColor\"/&gt; &lt;attr format=\"dimension\" name=\"circleRadius\"/&gt; &lt;attr format=\"integer\" name=\"startAngle\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 下面是SimpleRoundProgressBar代码，在onMeasure当中确定view的大小，在onDraw来进行绘制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.easyliu.demo.customizeview;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.RectF;import android.util.AttributeSet;import android.view.View;/*** Created by easyliu on 2017/2/24.*/public class SimpleRoundProgressBar extends View &#123; private Paint mPaint;//画笔 private RectF mRectF;//扇形绘制的矩形范围 private int mRoundColor;//圆环的颜色 private int mRoundProgressColor; //进度条的颜色 private float mRadius;//半径 private int mWidth; //宽度 private int mHeight; //高度 private int mCenterX; //中心X坐标 private int mCenterY; //中心Y坐标 private int mStartAngle; //初始角度 private int mSweepAngle; //扫过的角度 private static final int DEFAULT_INIT_ANGLE = 0;//默认的初始化角度 private static final int DEFAULT_RADIUS = 10;//默认的半径 public SimpleRoundProgressBar(Context context) &#123; this(context, null); &#125; public SimpleRoundProgressBar(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SimpleRoundProgressBar(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mPaint = new Paint(); mRectF = new RectF(); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.SimpleRoundProgressBar); mRoundColor = typedArray.getColor(R.styleable.SimpleRoundProgressBar_roundColor, Color.GRAY); mRoundProgressColor = typedArray.getColor(R.styleable.SimpleRoundProgressBar_roundProgressColor, Color.RED); mRadius = typedArray.getDimension(R.styleable.SimpleRoundProgressBar_circleRadius, DEFAULT_RADIUS); mStartAngle = typedArray.getInteger(R.styleable.SimpleRoundProgressBar_startAngle, DEFAULT_INIT_ANGLE); typedArray.recycle(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //获取测量模式 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); //获取测量大小 int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); //如果为确定值 if (heightMode == MeasureSpec.EXACTLY) &#123; mHeight = heightSize; &#125; else &#123; //如果为wrap_content，高度为半径大小乘以2，注意padding mHeight = (int) (mRadius * 2) + getPaddingTop() + getPaddingBottom(); &#125; //如果为确定值 if (widthMode == MeasureSpec.EXACTLY) &#123; mWidth = widthSize; mHeight=mWidth;//宽和高相等 &#125; else &#123; //如果为wrap_content，宽度为半径大小乘以2,注意padding mWidth = (int) (mRadius * 2) + getPaddingLeft() + getPaddingRight(); &#125; //设置视图的大小 setMeasuredDimension(mWidth, mHeight); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setColor(mRoundColor); mPaint.setAntiAlias(true); mCenterX = mWidth / 2; mCenterY = mHeight / 2; //注意处理padding mRadius = (mWidth - getPaddingLeft() - getPaddingRight()) / 2; //画圆 canvas.drawCircle(mCenterX, mCenterY, mRadius, mPaint); mPaint.setColor(mRoundProgressColor); //注意处理padding mRectF.left = getPaddingLeft(); mRectF.right = mWidth - getPaddingRight(); mRectF.top = getPaddingTop(); mRectF.bottom = mHeight - getPaddingBottom(); //画扇形 canvas.drawArc(mRectF, (float) mStartAngle, mSweepAngle, true, mPaint); &#125; public int getRoundColor() &#123; return mRoundColor; &#125; public void setRoundColor(int roundColor) &#123; this.mRoundColor = roundColor; &#125; /** * 得到初始角度 */ public synchronized int getStartAngle() &#123; return mStartAngle; &#125; /** * 设置初始角度 */ public synchronized void setStartAngle(int startAngle) &#123; if (startAngle &lt; -360) &#123; throw new IllegalArgumentException(\"the angle can not less than -360\"); &#125; if (startAngle &gt; 360) &#123; throw new IllegalArgumentException(\"the angle can not larger than 360\"); &#125; this.mStartAngle = startAngle; &#125; /** * 得到扫过的角度 */ public synchronized int getSweepAngle() &#123; return mSweepAngle; &#125; /** * 设置扫过的角度,相对于起始点 * * @param sweepAngle 0~360 */ public synchronized void setSweepAngle(int sweepAngle) &#123; if (sweepAngle &lt; 0) &#123; throw new IllegalArgumentException(\"the angle can not less than 0\"); &#125; if (sweepAngle &gt; 360) &#123; throw new IllegalArgumentException(\"the angle can not larger than 360\"); &#125; this.mSweepAngle = sweepAngle; postInvalidate(); &#125;&#125; 定义好了之后就可以使用了，首先是xml文件： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:easyliu=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.easyliu.demo.customizeview.RoundProgressBarActivity\" &gt; &lt;com.easyliu.demo.customizeview.SimpleRoundProgressBar android:id=\"@+id/progress_demo\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:padding=\"10dp\" easyliu:circleRadius=\"50dp\" easyliu:roundColor=\"#5F000000\" easyliu:roundProgressColor=\"#ff8d33\" /&gt; &lt;com.easyliu.demo.customizeview.SimpleRoundProgressBar android:id=\"@+id/progress_demo2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/progress_demo\" android:layout_centerHorizontal=\"true\" android:padding=\"10dp\" easyliu:circleRadius=\"60dp\" easyliu:roundColor=\"@color/colorPrimary\" easyliu:roundProgressColor=\"@color/colorAccent\" /&gt;&lt;/RelativeLayout&gt; 然后是Activity代码，在代码中使用定时器来定时更新进度即可。 123456789101112131415161718192021222324252627282930313233343536package com.easyliu.demo.customizeview;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import java.util.Timer;import java.util.TimerTask;public class RoundProgressBarActivity extends AppCompatActivity &#123; private int mCurrentAngle = 0; private SimpleRoundProgressBar mRoundProgressBar1; private SimpleRoundProgressBar mRoundProgressBar2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_progress_bar); initViews(); Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; mCurrentAngle++; mRoundProgressBar1.setSweepAngle(mCurrentAngle); mRoundProgressBar2.setSweepAngle(mCurrentAngle); if (mCurrentAngle &gt;= 360) &#123; mCurrentAngle = 0; &#125; &#125; &#125;, 0, 20); &#125; private void initViews()&#123; mRoundProgressBar1 = (SimpleRoundProgressBar) findViewById(R.id.progress_demo); mRoundProgressBar1.setStartAngle(-90); mRoundProgressBar2= (SimpleRoundProgressBar) findViewById(R.id.progress_demo2); mRoundProgressBar2.setStartAngle(0); &#125;&#125; 这样就完成了一个简单的圆形进度条的自定义。","categories":[{"name":"Android自定义控件","slug":"Android自定义控件","permalink":"http://easyliu.com/categories/Android自定义控件/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://easyliu.com/tags/Android/"}]},{"title":"Hexo搭建个人博客","slug":"hexo/hexo","date":"2017-03-15T15:28:55.000Z","updated":"2021-02-18T11:58:18.074Z","comments":true,"path":"2017/03/15/hexo/hexo/","link":"","permalink":"http://easyliu.com/2017/03/15/hexo/hexo/","excerpt":"","text":"您好，欢迎来到easyliu的技术博客！ 相关链接： 在 hexo 中无痛使用本地图片 程序猿修炼之道(4)-技能篇之Markdown（附：工具推荐） hexo官网 大道至简——Hexo简洁主题推荐 npm install reports error “npm ERR! Unexpected end of JSON input while parsing near hueman-theme 关于hexo中使用连续{报错的解决方案:把括号进行隔开即可 hexo隐藏文章功能 相关笔记： 代码块高亮的方式为三个```之后加上语言，记得之间的空格，不然无效 对于引用图片，在同一目录下面新建asset文件夹，把图片放入其中，然后引用即可 在_post下面的ios目录下面新建xcode_shortcut.md文件：hexo new –path ios/xcode_shortcut “xcode_shortcut” 查看隐藏文件列表：hexo hidden:list","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://easyliu.com/categories/开发工具/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://easyliu.com/tags/hexo/"}]}]}